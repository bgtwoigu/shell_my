From 88303ccd293e9b03e0e1d2400ccc5c258a5feeb8 Mon Sep 17 00:00:00 2001
From: "haolong.zhang" <haolong.zhang@ck-telecom.com>
Date: Wed, 15 Oct 2014 15:28:20 +0800
Subject: [PATCH] 0001-touch_comable_step_3.patch

Change-Id: I5b9dddd13d10469c8e3c4673c76ff53322cb5750
---
 mediatek/config/ckt95_lw_kk/ProjectConfig.mk       |    2 +-
 .../touchpanel/msg2133_and_ektf2k/ektf2k_driver.c  | 2724 ++++++++++++++
 .../touchpanel/msg2133_and_ektf2k/ektf2k_driver.h  |   90 +
 .../msg2133_and_ektf2k/ektf2k_firmware.h           |   33 +
 .../touchpanel/msg2133_and_ektf2k/huaruichuan_03.i |  250 ++
 .../msg2133_and_ektf2k/mstar_drv_common.c          |  152 +
 .../msg2133_and_ektf2k/mstar_drv_common.h          |  320 ++
 .../mstar_drv_ic_fw_porting_layer.c                |  195 +
 .../mstar_drv_ic_fw_porting_layer.h                |   90 +
 .../touchpanel/msg2133_and_ektf2k/mstar_drv_main.c |  987 +++++
 .../touchpanel/msg2133_and_ektf2k/mstar_drv_main.h |   89 +
 .../touchpanel/msg2133_and_ektf2k/mstar_drv_mtk.c  |  288 ++
 .../mstar_drv_platform_interface.c                 |  147 +
 .../mstar_drv_platform_interface.h                 |   47 +
 .../mstar_drv_platform_porting_layer.c             |  598 +++
 .../mstar_drv_platform_porting_layer.h             |  155 +
 .../msg2133_and_ektf2k/mstar_drv_self_fw_control.c | 3974 ++++++++++++++++++++
 .../msg2133_and_ektf2k/mstar_drv_self_fw_control.h |  154 +
 .../mstar_drv_utility_adaption.c                   |  406 ++
 .../mstar_drv_utility_adaption.h                   |  101 +
 .../msg2133_and_ektf2k/tpd_custom_ektf2k.h         |   46 +
 21 files changed, 10847 insertions(+), 1 deletion(-)
 create mode 100755 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_driver.c
 create mode 100755 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_driver.h
 create mode 100755 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_firmware.h
 create mode 100755 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/huaruichuan_03.i
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_common.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_common.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_ic_fw_porting_layer.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_ic_fw_porting_layer.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_main.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_main.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_mtk.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_interface.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_interface.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_porting_layer.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_porting_layer.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_self_fw_control.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_self_fw_control.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_utility_adaption.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_utility_adaption.h
 create mode 100755 mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/tpd_custom_ektf2k.h

diff --git a/mediatek/config/ckt95_lw_kk/ProjectConfig.mk b/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
index 8d7d391..fda8f33 100755
--- a/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
+++ b/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
@@ -169,7 +169,7 @@ CUSTOM_KERNEL_SUB_IMGSENSOR=
 CUSTOM_KERNEL_SUB_LENS=
 
 # touch driver  need to report correct touch axes
-CUSTOM_KERNEL_TOUCHPANEL=ektf2k  #GT9XX_hotknot
+CUSTOM_KERNEL_TOUCHPANEL=msg2133_and_ektf2k  #GT9XX_hotknot
 
 # Configuration for USB PHY
 CUSTOM_KERNEL_USB=mt6577
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_driver.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_driver.c
new file mode 100755
index 0000000..9a22620
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_driver.c
@@ -0,0 +1,2724 @@
+//TP driver
+#include "tpd.h"
+#include "ektf2k_driver.h"
+#include "tpd_custom_ektf2k.h"
+#include "ektf2k_firmware.h"
+#include <linux/dma-mapping.h>
+
+#ifdef TP_PROXIMITY_SENSOR_NEW
+#include <linux/hwmsensor.h>
+#include <linux/hwmsen_dev.h>
+#include <linux/sensors_io.h>
+static int PROXIMITY =0;
+static int PROXIMITY_STATE = -1;
+static U8 PROXIMITY_SLEEP = 0;
+
+static int CTP_Face_Mode_State(void);
+static  int CTP_Face_Mode_Switch(int onoff_state);
+static  int Get_Ctp_Face_Mode(void);
+s32 ektf2k_ps_operate(void *self, u32 command, void *buff_in, s32 size_in,
+                      void *buff_out, s32 size_out, s32 *actualout);
+#endif
+
+#ifdef ESD_CHECK
+int have_interrupts = 0;
+struct workqueue_struct *esd_wq = NULL;
+struct delayed_work esd_work;
+unsigned long delay = 2*HZ;
+static void elan_touch_esd_func(struct work_struct *work);
+#endif
+
+#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
+static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
+static int tpd_wb_end_local[TPD_WARP_CNT]   = TPD_WARP_END;
+#endif
+#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
+static int tpd_calmat_local[8]     = TPD_CALIBRATION_MATRIX;
+static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
+#endif
+
+//below add for ekt and mstar compat
+int ektf2k_probed = 0;
+int have_ektf2k_chip_on_board = 0;
+//end add for ekt and mstar compat
+#define MTK_ELAN_DEBUG
+#ifdef MTK_ELAN_DEBUG
+static int ekt_debug = 0,  ekt_debug_in = 0, man_made = 0;
+module_param(ekt_debug, int, 00664);
+module_param(man_made, int, 00664);
+#define MTK_TP_DEBUG(fmt, args ...) \
+do { \
+	if (ekt_debug || ekt_debug_in) { \
+		printk("Elan: %5d: " fmt, __LINE__,##args); \
+	} \
+} while(0)
+#else
+#define MTK_TP_DEBUG(fmt, args ...)
+#endif
+//below add for reflush IC
+#ifdef _DMA_MODE_
+#define NEED_FLUSH_DMA 150
+#endif
+#define NEED_RESET_IC 155
+static unsigned int err_buf_times = 0;
+static unsigned int dma_alloc_err = 0;
+//end add for reflush IC
+#ifdef TPD_HAVE_BUTTON
+#define TPD_BUTTON_HEIGH                100
+#define TPD_KEY_COUNT           2
+#define TPD_KEYS                { KEY_MENU, KEY_BACK}
+#define TPD_KEYS_DIM            {{107,1370,109,TPD_BUTTON_HEIGH},{300,1370,109,TPD_BUTTON_HEIGH}}
+static struct kobject *ektf2t_kobj;
+static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
+static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
+#endif
+
+// modify
+#define SYSTEM_RESET_PIN_SR   135
+
+//Add these Define
+
+#ifdef IAP_PORTION                         //upgrade  FW DMA mode
+#define _DMA_FW_UPGRADE_MODE_
+#endif
+#define PAGERETRY                   30
+#define IAPRESTART                  5
+
+
+#ifdef _DMA_MODE_
+static uint8_t *gpDMABuf_va = NULL;
+static uint32_t *gpDMABuf_pa = NULL;
+#endif
+
+#ifdef _DMA_FW_UPGRADE_MODE_
+static uint8_t *gpDMAFWBuf_va = NULL;
+static uint32_t *gpDMAFWBuf_pa = NULL;
+static int elan_i2c_dma_fw_recv_data(struct i2c_client *client, uint8_t *buf,uint8_t len);
+static int elan_i2c_dma_fw_send_data(struct i2c_client *client, uint8_t *buf,uint8_t len);
+#endif
+
+// For Firmware Update
+#define ELAN_IOCTLID                            0xD0
+#define IOCTL_I2C_SLAVE                 _IOW(ELAN_IOCTLID, 1, int)
+#define IOCTL_MAJOR_FW_VER                  _IOR(ELAN_IOCTLID, 2, int)
+#define IOCTL_MINOR_FW_VER                  _IOR(ELAN_IOCTLID, 3, int)
+#define IOCTL_RESET                                 _IOR(ELAN_IOCTLID, 4, int)
+#define IOCTL_IAP_MODE_LOCK                 _IOR(ELAN_IOCTLID, 5, int)
+#define IOCTL_CHECK_RECOVERY_MODE   _IOR(ELAN_IOCTLID, 6, int)
+#define IOCTL_FW_VER                            _IOR(ELAN_IOCTLID, 7, int)
+#define IOCTL_X_RESOLUTION                  _IOR(ELAN_IOCTLID, 8, int)
+#define IOCTL_Y_RESOLUTION                  _IOR(ELAN_IOCTLID, 9, int)
+#define IOCTL_FW_ID                                 _IOR(ELAN_IOCTLID, 10, int)
+#define IOCTL_ROUGH_CALIBRATE           _IOR(ELAN_IOCTLID, 11, int)
+#define IOCTL_IAP_MODE_UNLOCK           _IOR(ELAN_IOCTLID, 12, int)
+#define IOCTL_I2C_INT                           _IOR(ELAN_IOCTLID, 13, int)
+#define IOCTL_RESUME                            _IOR(ELAN_IOCTLID, 14, int)
+#define IOCTL_POWER_LOCK                    _IOR(ELAN_IOCTLID, 15, int)
+#define IOCTL_POWER_UNLOCK                  _IOR(ELAN_IOCTLID, 16, int)
+#define IOCTL_FW_UPDATE                         _IOR(ELAN_IOCTLID, 17, int)
+#define IOCTL_BC_VER                            _IOR(ELAN_IOCTLID, 18, int)
+#define IOCTL_2WIREICE                          _IOR(ELAN_IOCTLID, 19, int)
+
+#define CUSTOMER_IOCTLID                        0xA0
+#define IOCTL_CIRCUIT_CHECK                 _IOR(CUSTOMER_IOCTLID, 1, int)
+#define IOCTL_GET_UPDATE_PROGREE    _IOR(CUSTOMER_IOCTLID, 2, int)
+
+extern struct tpd_device *tpd;
+
+uint8_t RECOVERY=0x00;
+int FW_VERSION=0x00;
+int X_RESOLUTION=0x00;
+int Y_RESOLUTION=0x00;
+int FW_ID=0x00;
+int BC_VERSION = 0x00;
+int work_lock=0x00;
+int power_lock=0x00;
+int circuit_ver=0x01;
+int button_state = 0;
+static int probe_flage=0;
+
+/*++++i2c transfer start+++++++*/
+#ifdef ELAN_3K_IC_SOLUTION
+int file_fops_addr=0x10;
+#else
+int file_fops_addr=0x15;
+#endif
+/*++++i2c transfer end+++++++*/
+
+int tpd_down_flag=0;
+int tpd_reg_flag=0;// 1 -->elan; 0 -->other;
+
+struct i2c_client *i2c_client = NULL;
+struct task_struct *thread = NULL;
+struct task_struct *update_thread = NULL;
+
+static DECLARE_WAIT_QUEUE_HEAD(waiter);
+static inline int elan_ktf2k_ts_parse_xy(uint8_t *data,
+        uint16_t *x, uint16_t *y);
+extern void mt_eint_unmask(unsigned int line);
+extern void mt_eint_mask(unsigned int line);
+extern void mt_eint_set_hw_debounce(unsigned int eintno, unsigned int ms);
+extern unsigned int mt_eint_set_sens(unsigned int eintno, unsigned int sens);
+extern void mt_eint_registration(unsigned int eint_num, unsigned int flag,
+                                 void (EINT_FUNC_PTR) (void), unsigned int is_auto_umask);
+
+
+static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
+static int tpd_detect(struct i2c_client *client, int kind, struct i2c_board_info *info);
+static int tpd_remove(struct i2c_client *client);
+static int touch_event_handler(void *unused);
+
+
+static int tpd_flag = 0;
+
+#ifdef IAP_PORTION
+uint8_t ic_status=0x00;  //0:OK 1:master fail 2:slave fail
+int update_progree=0;
+
+#ifdef ELAN_3K_IC_SOLUTION
+uint8_t I2C_DATA[3] = {0x10, 0x20, 0x21};/*I2C devices address*/
+#else
+uint8_t I2C_DATA[3] = {0x15, 0x20, 0x21};/*I2C devices address*/
+#endif
+
+int is_OldBootCode = 0; // 0:new 1:old
+
+static uint8_t* file_fw_data = NULL;
+
+enum
+{
+    PageSize           = 132,
+    PageNum            = 249,
+    ACK_Fail           = 0x00,
+    ACK_OK             = 0xAA,
+    ACK_REWRITE        = 0x55,
+};
+
+enum
+{
+    E_FD               = -1,
+};
+#endif
+
+static const struct i2c_device_id tpd_id[] =
+{
+    { "ektf2k", 0 },
+    { }
+};
+
+#ifdef ELAN_3K_IC_SOLUTION
+static struct i2c_board_info __initdata ektf2k_i2c_tpd = { I2C_BOARD_INFO("ektf2k", (0x20>>1))};
+#else
+static struct i2c_board_info __initdata ektf2k_i2c_tpd = { I2C_BOARD_INFO("ektf2k", (0x2a>>1))};
+#endif
+
+static struct i2c_driver tpd_i2c_driver =
+{
+    .driver = {
+        .name = "ektf2k",
+//        .owner = THIS_MODULE,
+    },
+    .probe = tpd_probe,
+    .remove =  tpd_remove,
+    .id_table = tpd_id,
+    .detect = tpd_detect,
+//    .address_data = &addr_data,
+};
+
+struct elan_ktf2k_ts_data
+{
+    struct i2c_client *client;
+    struct input_dev *input_dev;
+    struct workqueue_struct *elan_wq;
+    struct work_struct work;
+    struct early_suspend early_suspend;
+    int intr_gpio;
+// Firmware Information
+    int fw_ver;
+    int fw_id;
+    int bc_ver;
+    int x_resolution;
+    int y_resolution;
+// For Firmare Update
+    struct miscdevice firmware;
+    struct hrtimer timer;
+};
+
+static struct elan_ktf2k_ts_data *private_ts;
+static int __hello_packet_handler(struct i2c_client *client);
+static int __check_ekt_ic_on_board(struct i2c_client *client);
+static int __fw_packet_handler(struct i2c_client *client);
+static int elan_ktf2k_ts_rough_calibrate(struct i2c_client *client);
+static int tpd_resume(struct i2c_client *client);
+
+#ifdef IAP_PORTION
+static int update_fw_handler(void *unused);
+int Update_FW_One(/*struct file *filp,*/ struct i2c_client *client, int recovery);
+int IAPReset();
+#endif
+
+#ifdef _DMA_MODE_
+static int elan_i2c_dma_recv_data(struct i2c_client *client, uint8_t *buf,uint8_t len)
+{
+    int rc;
+    uint8_t *pReadData = 0;
+    unsigned short addr = 0;
+    addr = client->addr ;
+    client->addr |= I2C_DMA_FLAG;
+    pReadData = gpDMABuf_va;
+    if(!pReadData)
+    {
+        printk("[elan] dma_alloc_coherent failed!\n");
+        return -1;
+    }
+    rc = i2c_master_recv(client, gpDMABuf_pa, len);
+    printk("[elan] elan_i2c_dma_recv_data rc=%d!\n",rc);
+    copy_to_user(buf, pReadData, len);
+    client->addr = addr;
+    return rc;
+}
+
+static int elan_i2c_dma_send_data(struct i2c_client *client, uint8_t *buf,uint8_t len)
+{
+    int rc;
+    unsigned short addr = 0;
+    addr = client->addr ;
+    client->addr |= I2C_DMA_FLAG;
+    uint8_t *pWriteData = gpDMABuf_va;
+    if(!pWriteData)
+    {
+        printk("[elan] dma_alloc_coherent failed!\n");
+        return -1;
+    }
+    copy_from_user(pWriteData, ((void*)buf), len);
+
+    rc = i2c_master_send(client, gpDMABuf_pa, len);
+    printk("[elan] elan_i2c_dma_send_data rc=%d!\n",rc);
+    client->addr = addr;
+    return rc;
+}
+#endif
+
+//DMA_FW_Upgrade Start Function
+#ifdef _DMA_FW_UPGRADE_MODE_
+static int elan_i2c_dma_fw_recv_data(struct i2c_client *client, uint8_t *buf,uint8_t len)
+{
+    int rc;
+    uint8_t *pReadData = 0;
+    unsigned short addr = 0;
+    addr = client->addr ;
+    client->addr |= I2C_DMA_FLAG;
+    pReadData = gpDMAFWBuf_va;
+    if(!pReadData)
+    {
+        printk("[elan] dma_alloc_coherent failed!\n");
+        return -1;
+    }
+    rc = i2c_master_recv(client, gpDMAFWBuf_pa, len);
+    printk("[elan] elan_i2c_dma_recv_data rc=%d!\n",rc);
+    copy_to_user(buf, pReadData, len);
+    client->addr = addr;
+    return rc;
+}
+
+static int elan_i2c_dma_fw_send_data(struct i2c_client *client, uint8_t *buf,uint8_t len)
+{
+    int rc;
+    unsigned short addr = 0;
+    addr = client->addr ;
+    client->addr |= I2C_DMA_FLAG;
+    uint8_t *pWriteData = gpDMAFWBuf_va;
+    if(!pWriteData)
+    {
+        printk("[elan] dma_alloc_coherent failed!\n");
+        return -1;
+    }
+    copy_from_user(pWriteData, ((void*)buf), len);
+
+    rc = i2c_master_send(client, gpDMAFWBuf_pa, len);
+    printk("[elan] elan_i2c_dma_send_data rc=%d!\n",rc);
+    client->addr = addr;
+    return rc;
+}
+#endif
+//DMA_FW_Upgrade End Function
+
+// For Firmware Update
+int elan_iap_open(struct inode *inode, struct file *filp)
+{
+
+    printk("[ELAN]into elan_iap_open\n");
+    if (private_ts == NULL)  printk("private_ts is NULL~~~");
+
+    return 0;
+}
+
+int elan_iap_release(struct inode *inode, struct file *filp)
+{
+    return 0;
+}
+
+static ssize_t elan_iap_write(struct file *filp, const char *buff, size_t count, loff_t *offp)
+{
+    int ret;
+    char *tmp;
+
+    printk("[ELAN]into elan_iap_write\n");
+    if (count > 8192)
+        count = 8192;
+
+    tmp = kmalloc(count, GFP_KERNEL);
+
+    if (tmp == NULL)
+        return -ENOMEM;
+
+    if (copy_from_user(tmp, buff, count))
+    {
+        return -EFAULT;
+    }
+#if 0 //_DMA_MODE_
+    ret = elan_i2c_dma_send_data(private_ts->client, tmp, count);
+#else
+    ret = i2c_master_send(private_ts->client, tmp, count);
+#endif
+    kfree(tmp);
+    return (ret == 1) ? count : ret;
+
+}
+
+ssize_t elan_iap_read(struct file *filp, char *buff, size_t count, loff_t *offp)
+{
+    char *tmp;
+    int ret;
+    long rc;
+
+    printk("[ELAN]into elan_iap_read\n");
+    if (count > 8192)
+        count = 8192;
+
+    tmp = kmalloc(count, GFP_KERNEL);
+
+    if (tmp == NULL)
+        return -ENOMEM;
+#if 0 // _DMA_MODE_
+    ret = elan_i2c_dma_recv_data(private_ts->client, tmp, count);
+#else
+    ret = i2c_master_recv(private_ts->client, tmp, count);
+#endif
+    if (ret >= 0)
+        rc = copy_to_user(buff, tmp, count);
+
+    kfree(tmp);
+
+    //return ret;
+    return (ret == 1) ? count : ret;
+
+}
+
+static long elan_iap_ioctl(/*struct inode *inode,*/ struct file *filp,    unsigned int cmd, unsigned long arg)
+{
+
+    int __user *ip = (int __user *)arg;
+    printk("[ELAN]into elan_iap_ioctl\n");
+    printk("[ELAN]cmd value %x\n",cmd);
+
+    switch (cmd)
+    {
+        case IOCTL_I2C_SLAVE:
+            private_ts->client->addr = (int __user)arg;
+            private_ts->client->addr &= I2C_MASK_FLAG;
+            private_ts->client->addr |= I2C_ENEXT_FLAG;
+            //file_fops_addr = 0x15;
+            break;
+        case IOCTL_MAJOR_FW_VER:
+            break;
+        case IOCTL_MINOR_FW_VER:
+            break;
+        case IOCTL_RESET:
+
+            mt_set_gpio_mode( GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO );
+            mt_set_gpio_dir( GPIO_CTP_RST_PIN, GPIO_DIR_OUT );
+            mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+            msleep(10);
+            //#if !defined(EVB)
+            mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);
+            //#endif
+            msleep(10);
+            mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+
+            break;
+        case IOCTL_IAP_MODE_LOCK:
+            if(work_lock==0)
+            {
+                printk("[elan]%s %x=IOCTL_IAP_MODE_LOCK\n", __func__,IOCTL_IAP_MODE_LOCK);
+                work_lock=1;
+                //disable_irq(CUST_EINT_TOUCH_PANEL_NUM);
+                mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+                //cancel_work_sync(&private_ts->work);
+            }
+            break;
+        case IOCTL_IAP_MODE_UNLOCK:
+            if(work_lock==1)
+            {
+                work_lock=0;
+                //enable_irq(CUST_EINT_TOUCH_PANEL_NUM);
+                mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+            }
+            break;
+        case IOCTL_CHECK_RECOVERY_MODE:
+            return RECOVERY;
+            break;
+        case IOCTL_FW_VER:
+            __fw_packet_handler(private_ts->client);
+            return FW_VERSION;
+            break;
+        case IOCTL_X_RESOLUTION:
+            __fw_packet_handler(private_ts->client);
+            return X_RESOLUTION;
+            break;
+        case IOCTL_Y_RESOLUTION:
+            __fw_packet_handler(private_ts->client);
+            return Y_RESOLUTION;
+            break;
+        case IOCTL_FW_ID:
+            __fw_packet_handler(private_ts->client);
+            return FW_ID;
+            break;
+        case IOCTL_ROUGH_CALIBRATE:
+            return elan_ktf2k_ts_rough_calibrate(private_ts->client);
+        case IOCTL_I2C_INT:
+            put_user(mt_get_gpio_in(GPIO_CTP_EINT_PIN),ip);
+            printk("[elan]GPIO_CTP_EINT_PIN = %d\n", mt_get_gpio_in(GPIO_CTP_EINT_PIN));
+
+            break;
+        case IOCTL_RESUME:
+            tpd_resume(private_ts->client);
+            break;
+        case IOCTL_CIRCUIT_CHECK:
+            return circuit_ver;
+            break;
+        case IOCTL_POWER_LOCK:
+            power_lock=1;
+            break;
+        case IOCTL_POWER_UNLOCK:
+            power_lock=0;
+            break;
+#ifdef IAP_PORTION
+        case IOCTL_GET_UPDATE_PROGREE:
+            update_progree=(int __user)arg;
+            break;
+
+        case IOCTL_FW_UPDATE:
+            //RECOVERY = IAPReset(private_ts->client);
+            RECOVERY=0;
+            Update_FW_One(private_ts->client, RECOVERY);
+#endif
+        case IOCTL_BC_VER:
+            __fw_packet_handler(private_ts->client);
+            return BC_VERSION;
+            break;
+        default:
+            break;
+    }
+    return 0;
+}
+
+struct file_operations elan_touch_fops =
+{
+    .open =             elan_iap_open,
+    .write =            elan_iap_write,
+    .read =             elan_iap_read,
+    .release =              elan_iap_release,
+    .unlocked_ioctl = elan_iap_ioctl,
+};
+
+#ifdef IAP_PORTION
+int EnterISPMode(struct i2c_client *client, uint8_t  *isp_cmd)
+{
+    char buff[4] = {0};
+    int len = 0;
+
+#ifdef _DMA_FW_UPGRADE_MODE_
+    len = elan_i2c_dma_fw_send_data(private_ts->client,isp_cmd,  sizeof(isp_cmd));
+#else
+    len = i2c_master_send(private_ts->client, isp_cmd,  sizeof(isp_cmd));
+#endif
+
+    if (len != sizeof(buff))
+    {
+        printk("[ELAN] ERROR: EnterISPMode fail! len=%d\r\n", len);
+        return -1;
+    }
+    else
+        printk("[ELAN] IAPMode write data successfully! cmd = [%2x, %2x, %2x, %2x]\n", isp_cmd[0], isp_cmd[1], isp_cmd[2], isp_cmd[3]);
+    return 0;
+}
+
+int ExtractPage(struct file *filp, uint8_t * szPage, int byte)
+{
+    int len = 0;
+
+    len = filp->f_op->read(filp, szPage,byte, &filp->f_pos);
+    if (len != byte)
+    {
+        printk("[ELAN] ExtractPage ERROR: read page error, read error. len=%d\r\n", len);
+        return -1;
+    }
+
+    return 0;
+}
+
+int WritePage(uint8_t * szPage, int byte)
+{
+    int len = 0;
+
+#ifdef _DMA_FW_UPGRADE_MODE_
+    len = elan_i2c_dma_fw_send_data(private_ts->client, szPage,  byte);
+#else
+    len = i2c_master_send(private_ts->client, szPage,  byte);
+#endif
+
+    if (len != byte)
+    {
+        printk("[ELAN] ERROR: write page error, write error. len=%d\r\n", len);
+        return -1;
+    }
+
+    return 0;
+}
+
+int GetAckData(struct i2c_client *client)
+{
+    int len = 0;
+
+    char buff[2] = {0};
+
+#ifdef _DMA_FW_UPGRADE_MODE_
+    len = elan_i2c_dma_fw_recv_data(private_ts->client, buff, sizeof(buff));
+#else
+    len = i2c_master_recv(private_ts->client, buff, sizeof(buff));
+#endif
+
+    if (len != sizeof(buff))
+    {
+        printk("[ELAN] ERROR: read data error, write 50 times error. len=%d\r\n", len);
+        return -1;
+    }
+
+    printk("[ELAN] GetAckData:%x,%x\n",buff[0],buff[1]);
+    if (buff[0] == 0xaa/* && buff[1] == 0xaa*/)
+        return ACK_OK;
+    else if (buff[0] == 0x55 && buff[1] == 0x55)
+        return ACK_REWRITE;
+    else
+        return ACK_Fail;
+
+    return 0;
+}
+
+void print_progress(int page, int ic_num, int j)
+{
+    int i, percent,page_tatol,percent_tatol;
+    char str[256];
+    str[0] = '\0';
+    for (i=0; i<((page)/10); i++)
+    {
+        str[i] = '#';
+        str[i+1] = '\0';
+    }
+
+    page_tatol=page+249*(ic_num-j);
+    percent = ((100*page)/(249));
+    percent_tatol = ((100*page_tatol)/(249*ic_num));
+
+    if ((page) == (249))
+        percent = 100;
+
+    if ((page_tatol) == (249*ic_num))
+        percent_tatol = 100;
+
+    printk("\rprogress %s| %d%%", str, percent);
+
+    if (page == (249))
+        printk("\n");
+}
+
+/*
+* Restet and (Send normal_command ?)
+* Get Hello Packet
+*/
+int  IAPReset()
+{
+    int res;
+
+    mt_set_gpio_mode( GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO );
+    mt_set_gpio_dir( GPIO_CTP_RST_PIN, GPIO_DIR_OUT );
+    mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+    msleep(10);
+    //#if !defined(EVB)
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);
+    //#endif
+    msleep(10);
+    mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+    return 1;
+
+#if 0
+    printk("[ELAN] read Hello packet data!\n");
+    res= __hello_packet_handler(client);
+    return res;
+#endif
+}
+
+/* Check Master & Slave is "55 aa 33 cc" */
+int CheckIapMode(void)
+{
+    char buff[4] = {0},len = 0;
+    //WaitIAPVerify(1000000);
+    //len = read(fd, buff, sizeof(buff));
+
+
+#ifdef _DMA_FW_UPGRADE_MODE_
+    len = elan_i2c_dma_fw_recv_data(private_ts->client, buff, sizeof(buff));
+#else
+    len = i2c_master_recv(private_ts->client, buff, sizeof(buff));
+#endif
+
+    if (len != sizeof(buff))
+    {
+        printk("[ELAN] CheckIapMode ERROR: read data error,len=%d\r\n", len);
+        return -1;
+    }
+    else
+    {
+
+        if (buff[0] == 0x55 && buff[1] == 0xaa && buff[2] == 0x33 && buff[3] == 0xcc)
+        {
+            //printk("[ELAN] CheckIapMode is 55 aa 33 cc\n");
+            return 0;
+        }
+        else// if ( j == 9 )
+        {
+            printk("[ELAN] Mode= 0x%x 0x%x 0x%x 0x%x\r\n", buff[0], buff[1], buff[2], buff[3]);
+            printk("[ELAN] ERROR:  CheckIapMode error\n");
+            return -1;
+        }
+    }
+    printk("\n");
+}
+
+int Update_FW_One(struct i2c_client *client, int recovery)
+{
+    int res = 0,ic_num = 1;
+    int iPage = 0, rewriteCnt = 0; //rewriteCnt for PAGE_REWRITE
+    int i = 0;
+    uint8_t data;
+
+    int restartCnt = 0, checkCnt = 0; // For IAP_RESTART
+    //uint8_t recovery_buffer[4] = {0};
+    int byte_count;
+    uint8_t *szBuff = NULL;
+    int curIndex = 0;
+#ifdef ELAN_3K_IC_SOLUTION
+    uint8_t isp_cmd[] = {0x45, 0x49, 0x41, 0x50};         //45 49 41 50
+#else
+    uint8_t isp_cmd[] = {0x54, 0x00, 0x12, 0x34};         //54 00 12 34
+#endif
+    uint8_t recovery_buffer[4] = {0};
+
+IAP_RESTART:
+
+    data=I2C_DATA[0];//Master
+    printk("[ELAN] %s: address data=0x%x \r\n", __func__, data);
+
+    if(RECOVERY != 0x80)
+    {
+        printk("[ELAN] Firmware upgrade normal mode !\n");
+
+        IAPReset();
+        msleep(20);
+
+        res = EnterISPMode(private_ts->client, isp_cmd); //enter ISP mode
+
+
+#ifdef _DMA_FW_UPGRADE_MODE_
+        res = elan_i2c_dma_fw_recv_data(private_ts->client, recovery_buffer, 4);
+#else
+        res = i2c_master_recv(private_ts->client, recovery_buffer, 4);   //55 aa 33 cc
+#endif
+
+        printk("[ELAN] recovery byte data:%x,%x,%x,%x \n",recovery_buffer[0],recovery_buffer[1],recovery_buffer[2],recovery_buffer[3]);
+
+        msleep(10);
+    }
+    else
+        printk("[ELAN] Firmware upgrade recovery mode !\n");
+    // Send Dummy Byte
+    printk("[ELAN] send one byte data:%x,%x",private_ts->client->addr,data);
+
+#ifdef _DMA_FW_UPGRADE_MODE_
+    res = elan_i2c_dma_fw_send_data(private_ts->client, &data,  sizeof(data));
+#else
+    res = i2c_master_send(private_ts->client, &data,  sizeof(data));
+#endif
+
+    if(res!=sizeof(data))
+    {
+        printk("[ELAN] dummy error code = %d\n",res);
+    }
+    msleep(50);
+
+    // Start IAP
+    for( iPage = 1; iPage <= PageNum; iPage++ )
+    {
+    PAGE_REWRITE:
+
+#if 1 // 132byte mode                
+        szBuff = file_fw_data + curIndex;
+        curIndex =  curIndex + PageSize;
+        res = WritePage(szBuff, PageSize);
+#endif
+
+        msleep(50);
+        res = GetAckData(private_ts->client);
+
+        if (ACK_OK != res)
+        {
+            msleep(50);
+            printk("[ELAN] ERROR: GetAckData fail! res=%d\r\n", res);
+            if ( res == ACK_REWRITE )
+            {
+                rewriteCnt = rewriteCnt + 1;
+                if (rewriteCnt == PAGERETRY)
+                {
+                    printk("[ELAN] ID 0x%02x %dth page ReWrite %d times fails!\n", data, iPage, PAGERETRY);
+                    return E_FD;
+                }
+                else
+                {
+                    printk("[ELAN] ---%d--- page ReWrite %d times!\n",  iPage, rewriteCnt);
+                    curIndex = curIndex - PageSize;
+                    goto PAGE_REWRITE;
+                }
+            }
+            else
+            {
+                restartCnt = restartCnt + 1;
+                if (restartCnt >= 5)
+                {
+                    printk("[ELAN] ID 0x%02x ReStart %d times fails!\n", data, IAPRESTART);
+                    return E_FD;
+                }
+                else
+                {
+                    printk("[ELAN] ===%d=== page ReStart %d times!\n",  iPage, restartCnt);
+                    goto IAP_RESTART;
+                }
+            }
+        }
+        else
+        {
+            printk("  data : 0x%02x ",  data);
+            rewriteCnt=0;
+            print_progress(iPage,ic_num,i);
+        }
+
+        msleep(10);
+    } // end of for(iPage = 1; iPage <= PageNum; iPage++)
+
+    //if (IAPReset() > 0)
+    printk("[ELAN] Update ALL Firmware successfully!\n");
+    return 0;
+}
+
+#endif
+// End Firmware Update
+
+
+#if 0
+static void elan_ktf2k_ts_early_suspend(struct early_suspend *h);
+static void elan_ktf2k_ts_late_resume(struct early_suspend *h);
+#endif
+
+static ssize_t elan_ktf2k_gpio_show(struct device *dev,
+                                    struct device_attribute *attr, char *buf)
+{
+    int ret = 0;
+    struct elan_ktf2k_ts_data *ts = private_ts;
+
+    //ret = gpio_get_value(ts->intr_gpio);
+    ret = mt_get_gpio_in(GPIO_CTP_EINT_PIN);
+    printk(KERN_DEBUG "GPIO_TP_INT_N=%d\n", ts->intr_gpio);
+    sprintf(buf, "GPIO_TP_INT_N=%d\n", ret);
+    ret = strlen(buf) + 1;
+    return ret;
+}
+
+static DEVICE_ATTR(gpio, S_IRUGO, elan_ktf2k_gpio_show, NULL);
+
+static ssize_t elan_ktf2k_vendor_show(struct device *dev,
+                                      struct device_attribute *attr, char *buf)
+{
+    ssize_t ret = 0;
+    struct elan_ktf2k_ts_data *ts = private_ts;
+
+    sprintf(buf, "%s_x%4.4x\n", "ELAN_KTF2K", ts->fw_ver);
+    ret = strlen(buf) + 1;
+    return ret;
+}
+
+static int __elan_ktf2k_ts_poll(struct i2c_client *client)
+{
+    struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+    int status = 0, retry = 10;
+
+    do
+    {
+        //status = gpio_get_value(ts->intr_gpio);
+        status = mt_get_gpio_in(GPIO_CTP_EINT_PIN);
+        printk("mtk-tpd:[elan]: %s: status = %d\n", __func__, status);
+        retry--;
+        msleep(20);
+    }
+    while (status == 1 && retry > 0);
+
+    printk( "mtk-tpd:[elan]%s: poll interrupt status %s\n",
+            __func__, status == 1 ? "high" : "low");
+
+    //status=0;
+    //printk("[elan]: %s: force status = 0\n", __func__);
+
+    return (status == 0 ? 0 : -ETIMEDOUT);
+}
+
+static int elan_ktf2k_ts_poll(struct i2c_client *client)
+{
+    return __elan_ktf2k_ts_poll(client);
+}
+
+static int elan_ktf2k_ts_get_data(struct i2c_client *client, uint8_t *cmd,
+                                  uint8_t *buf, size_t size)
+{
+    int rc;
+
+    dev_dbg(&client->dev, "[elan]%s: enter\n", __func__);
+
+    if (buf == NULL)
+        return -EINVAL;
+
+
+    if ((i2c_master_send(client, cmd, 4)) != 4)
+    {
+        dev_err(&client->dev,
+                "[elan]%s: i2c_master_send failed\n", __func__);
+        return -EINVAL;
+    }
+
+    rc = elan_ktf2k_ts_poll(client);
+    if (rc < 0)
+        return -EINVAL;
+    else
+    {
+
+        if (i2c_master_recv(client, buf, size) != size ||
+            buf[0] != CMD_S_PKT)
+        {
+            printk("mtk-tpd:[elan_ktf2k_ts_get_data] buf[0]=%x buf[1]=%x buf[2]=%x buf[3]=%x\n", buf[0], buf[1], buf[2], buf[3]);
+            return -EINVAL;
+        }
+    }
+
+    return 0;
+}
+
+static int __check_ekt_ic_on_board(struct i2c_client *client)
+{
+	int rc;
+	uint8_t buf_recv[8] = { 0 };
+
+	msleep(100);
+	rc = elan_ktf2k_ts_poll(client);
+	if (rc < 0)
+	{
+		printk( "mtk-tpd:[elan] %s: Int poll failed!\n", __func__);	
+		return rc;
+	}
+	rc = i2c_master_recv(client, buf_recv, 8);
+
+	return rc;
+}
+static int __hello_packet_handler(struct i2c_client *client)
+{
+    int rc = 0;
+    uint8_t buf_recv[8] = { 0 };
+    //uint8_t buf_recv1[4] = { 0 };
+
+    //msleep(1500);
+    msleep(100);
+    //rc = elan_ktf2k_ts_poll(client);
+    if (rc < 0)
+    {
+        printk( "mtk-tpd:[elan] %s: Int poll failed!\n", __func__);
+        RECOVERY=0x80;
+        return RECOVERY;
+    }
+
+    rc = i2c_master_recv(client, buf_recv, 8);
+
+    printk("mtk-tpd:[elan] %s: Hello Packet %2x:%2X:%2x:%2x\n", __func__, buf_recv[0], buf_recv[1], buf_recv[2], buf_recv[3]);
+    /*  Received 8 bytes data will let TP die on old firmware on ektf21xx carbon player and MK5
+        rc = i2c_master_recv(client, buf_recv, 8);
+             printk("[elan] %s: hello packet %2x:%2X:%2x:%2x:%2x:%2X:%2x:%2x\n", __func__, buf_recv[0], buf_recv[1], buf_recv[2], buf_recv[3] , buf_recv[4], buf_recv[5], buf_recv[6], buf_recv[7]);
+    */
+  if((buf_recv[0]==0x55 && buf_recv[1]==0x55) ||(buf_recv[0]==0xCC && buf_recv[1]==0xCC))
+         {
+         	tpd_reg_flag=1;// 1 -->elan; 0 -->other;
+         }
+    if(buf_recv[0]==0x55 && buf_recv[1]==0x55 && buf_recv[2]==0x80 && buf_recv[3]==0x80)
+    {
+        RECOVERY=0x80;
+        FW_ID =  buf_recv[5] << 8 | buf_recv[4];// RECOVERY MODE for yeji TP 2013/11/27 no need to read FW ID
+        printk("[elan] FW_ID = %x\r\n", FW_ID);
+
+        rc = i2c_master_recv(client, buf_recv, 8);
+
+        printk("mtk-tpd:[elan] %s: Bootcode Verson %2x:%2X:%2x:%2x\n", __func__, buf_recv[0], buf_recv[1], buf_recv[2], buf_recv[3]);
+        return RECOVERY;
+    }
+
+    return 0;
+}
+//record the FW ID in IC section
+static int write_check_fwid_to_rom(struct i2c_client *client, uint8_t *cmd, size_t size)
+{
+    int rc;
+    uint8_t get_cmd[] = {0x53, 0xD3, 0x00, 0x01}; /* Get CHECK FWID */
+    uint8_t buf_recv[4] = { 0 };
+
+    printk("[elan] check cmd: %02x, %02x, %02x, %02x\n", cmd[0], cmd[1], cmd[2], cmd[3]);
+
+    rc = elan_ktf2k_ts_get_data(client, get_cmd, buf_recv, 4);//get the infomation and show out
+    if (rc < 0)
+    {
+        return rc;
+    }
+    printk("[elan] read SENSOR option: %02x, %02x, %02x, %02x\n", buf_recv[0], buf_recv[1], buf_recv[2], buf_recv[3]);
+
+    if(buf_recv[2] == cmd[2])
+        return 0;
+
+    if ((i2c_master_send(client, cmd, sizeof(cmd))) != sizeof(cmd))
+    {
+        printk("[elan] %s: i2c_master_send failed\n", __func__);
+        return -1;
+    }
+    msleep(50);
+
+    return 0;
+}
+
+static int __fw_packet_handler(struct i2c_client *client)
+{
+    int rc;
+    int major, minor;
+    uint8_t cmd[] = {CMD_R_PKT, 0x00, 0x00, 0x01}; /* Get Firmware Version*/
+    uint8_t cmd_x[] = {0x53, 0x60, 0x00, 0x00};        /*Get x resolution*/
+    uint8_t cmd_y[] = {0x53, 0x63, 0x00, 0x00};        /*Get y resolution*/
+    uint8_t cmd_id[] = {0x53, 0xf0, 0x00, 0x01};   /*Get firmware ID*/
+    uint8_t cmd_check_fwid[] = { 0x54, 0XD2, 0xFF,0xFF };  /* Get Check FWID */
+    //uint8_t cmd_bc[] = {CMD_R_PKT, 0x01, 0x00, 0x01};/* Get BootCode Version*/
+    uint8_t cmd_bc[] = {CMD_R_PKT, 0x10, 0x00, 0x01};/* Get BootCode Version*/
+    uint8_t buf_recv[8] = {0};
+
+    printk( "mtk-tpd:[elan] %s: n", __func__);
+
+#if 1
+// Firmware version
+    rc = elan_ktf2k_ts_get_data(client, cmd, buf_recv, 4);
+    if (rc < 0)
+        return rc;
+    major = ((buf_recv[1] & 0x0f) << 4) | ((buf_recv[2] & 0xf0) >> 4);
+    minor = ((buf_recv[2] & 0x0f) << 4) | ((buf_recv[3] & 0xf0) >> 4);
+//      ts->fw_ver = major << 8 | minor;
+    FW_VERSION = major << 8 | minor;
+
+#endif
+
+#if 1
+// Firmware ID
+    rc = elan_ktf2k_ts_get_data(client, cmd_id, buf_recv, 4);
+    if (rc < 0)
+        return rc;
+    major = ((buf_recv[1] & 0x0f) << 4) | ((buf_recv[2] & 0xf0) >> 4);
+    minor = ((buf_recv[2] & 0x0f) << 4) | ((buf_recv[3] & 0xf0) >> 4);
+    //ts->fw_id = major << 8 | minor;
+    cmd_check_fwid[2] = major;
+    cmd_check_fwid[3] = minor;
+    rc = write_check_fwid_to_rom(client, cmd_check_fwid , 4);  // write check fwid info
+
+    FW_ID = major << 8 | minor;
+#endif
+
+#if 1
+// X Resolution
+    rc = elan_ktf2k_ts_get_data(client, cmd_x, buf_recv, 4);
+    if (rc < 0)
+        return rc;
+    minor = ((buf_recv[2])) | ((buf_recv[3] & 0xf0) << 4);
+    //ts->x_resolution =minor;
+    X_RESOLUTION = minor;
+#endif
+
+#if 1
+// Y Resolution
+    rc = elan_ktf2k_ts_get_data(client, cmd_y, buf_recv, 4);
+    if (rc < 0)
+        return rc;
+    minor = ((buf_recv[2])) | ((buf_recv[3] & 0xf0) << 4);
+    //ts->y_resolution =minor;
+    Y_RESOLUTION = minor;
+#endif
+
+#if 1
+// Bootcode version
+    rc = elan_ktf2k_ts_get_data(client, cmd_bc, buf_recv, 4);
+    if (rc < 0)
+        return rc;
+    major = ((buf_recv[1] & 0x0f) << 4) | ((buf_recv[2] & 0xf0) >> 4);
+    minor = ((buf_recv[2] & 0x0f) << 4) | ((buf_recv[3] & 0xf0) >> 4);
+    //ts->bc_ver = major << 8 | minor;
+    BC_VERSION = major << 8 | minor;
+#endif
+
+    printk( "mtk-tpd:[elan] %s: firmware version: 0x%4.4x\n",
+            __func__, FW_VERSION);
+    printk( "mtk-tpd:[elan] %s: firmware ID: 0x%4.4x\n",
+            __func__, FW_ID);
+    printk( "mtk-tpd:[elan] %s: x resolution: %d, y resolution: %d\n",
+            __func__, X_RESOLUTION, Y_RESOLUTION);
+    printk( "mtk-tpd:[elan] %s: bootcode version: 0x%4.4x\n",
+            __func__, BC_VERSION);
+    return 0;
+}
+
+static inline int elan_ktf2k_ts_parse_xy(uint8_t *data,
+        uint16_t *x, uint16_t *y)
+{
+    *x = *y = 0;
+
+    *x = (data[0] & 0xf0);
+    *x <<= 4;
+    *x |= data[1];
+
+    *y = (data[0] & 0x0f);
+    *y <<= 8;
+    *y |= data[2];
+
+    return 0;
+}
+
+static int elan_ktf2k_ts_setup(struct i2c_client *client)
+{
+    int rc;
+
+    rc = __hello_packet_handler(client);
+    printk("[elan] hellopacket's rc = %d\n",rc);
+
+    msleep(10);
+    if (rc != 0x80)
+    {
+        rc = __fw_packet_handler(client);
+        if (rc < 0)
+            printk("mtk-tpd:[elan] %s, fw_packet_handler fail, rc = %d", __func__, rc);
+        else
+            printk("mtk-tpd:[elan] %s: firmware checking done.\n", __func__);
+        /* Check for FW_VERSION, if 0x0000 means FW update fail! */
+        if ( FW_VERSION == 0x00)
+        {
+            rc = 0x80;
+			RECOVERY = 0x80; //ZZ add	
+            printk("mtk-tpd:[elan] FW_VERSION = %d, last FW update fail\n", FW_VERSION);
+        }
+    }
+    return rc; /* Firmware need to be update if rc equal to 0x80(Recovery mode)   */
+}
+
+static int elan_ktf2k_ts_rough_calibrate(struct i2c_client *client)
+{
+    uint8_t cmd[] = {CMD_W_PKT, 0x29, 0x00, 0x01};
+
+    printk("[elan] %s: enter\n", __func__);
+    printk("[elan] dump cmd: %02x, %02x, %02x, %02x\n",
+           cmd[0], cmd[1], cmd[2], cmd[3]);
+
+    if ((i2c_master_send(client, cmd, sizeof(cmd))) != sizeof(cmd))
+    {
+        dev_err(&client->dev,
+                "[elan] %s: i2c_master_send failed\n", __func__);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int elan_ktf2k_ts_set_power_state(struct i2c_client *client, int state)
+{
+    uint8_t cmd[] = {CMD_W_PKT, 0x50, 0x00, 0x01};
+
+    dev_dbg(&client->dev, "[elan] %s: enter\n", __func__);
+
+    cmd[1] |= (state << 3);
+
+    dev_dbg(&client->dev,
+            "[elan] dump cmd: %02x, %02x, %02x, %02x\n",
+            cmd[0], cmd[1], cmd[2], cmd[3]);
+
+    if ((i2c_master_send(client, cmd, sizeof(cmd))) != sizeof(cmd))
+    {
+        dev_err(&client->dev,
+                "[elan] %s: i2c_master_send failed\n", __func__);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int elan_ktf2k_ts_get_power_state(struct i2c_client *client)
+{
+    int rc = 0;
+    uint8_t cmd[] = {CMD_R_PKT, 0x50, 0x00, 0x01};
+    uint8_t buf[4], power_state;
+
+    rc = elan_ktf2k_ts_get_data(client, cmd, buf, 4);
+    if (rc)
+        return rc;
+
+    power_state = buf[1];
+    dev_dbg(&client->dev, "[elan] dump repsponse: %0x\n", power_state);
+    power_state = (power_state & PWR_STATE_MASK) >> 3;
+    dev_dbg(&client->dev, "[elan] power state = %s\n",power_state == PWR_STATE_DEEP_SLEEP ? "Deep Sleep" : "Normal/Idle");
+
+    return power_state;
+}
+
+static int elan_ktf2k_read_block(struct i2c_client *client, u8 addr, u8 *data, u8 len)
+{
+    int err;
+    u8 beg = addr;
+    struct i2c_msg msgs[2] =
+    {
+        {
+            .addr = client->addr,
+            .flags = 0,
+            .len = 1,
+            .buf= &beg
+        },
+        {
+            .addr = client->addr,
+            .flags = I2C_M_RD,
+            .len = len,
+            .buf = data,
+            .ext_flag = I2C_DMA_FLAG,
+        }
+    };
+
+    if (!client)
+        return -EINVAL;
+
+    err = i2c_transfer(client->adapter, msgs, sizeof(msgs)/sizeof(msgs[0]));
+    if (err != len)
+    {
+        printk("[elan] elan_ktf2k_read_block err=%d\n", err);
+        err = -EIO;
+    }
+    else
+    {
+        printk("[elan] elan_ktf2k_read_block ok\n");
+        err = 0;    /*no error*/
+    }
+    return err;
+}
+
+
+static int elan_ktf2k_ts_recv_data(struct i2c_client *client, uint8_t *buf)
+{
+    int rc, bytes_to_recv=PACKET_SIZE;
+    uint8_t *pReadData = 0;
+    unsigned short addr = 0;
+
+    if ((buf == NULL) || (dma_alloc_err == 1))
+	{
+		printk("----------%s:[%d]------\n", __func__, __LINE__);
+		return -EINVAL;
+	}
+    memset(buf, 0, bytes_to_recv);
+
+#ifdef _DMA_MODE_
+    addr = client->addr ;
+    client->addr |= I2C_DMA_FLAG;
+    pReadData = gpDMABuf_va;
+    if(!pReadData)
+    {
+        printk("mtk-tpd:[elan] dma_alloc_coherent failed!\n");
+    }
+	MTK_TP_DEBUG("----%s:[%d]----\n", __func__, __LINE__);
+    rc = i2c_master_recv(client, gpDMABuf_pa, bytes_to_recv);
+    copy_to_user(buf, pReadData, bytes_to_recv);
+	MTK_TP_DEBUG("----%s:[%d]----\n", __func__, __LINE__);
+    client->addr = addr;
+#ifdef ELAN_DEBUG
+    MTK_TP_DEBUG("[elan_debug] %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\n", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15],buf[16], buf[17]);
+#endif
+
+#else
+#ifdef NON_MTK_MODE    //I2C support > 8bits transfer
+    rc = i2c_master_recv(client, buf, bytes_to_recv);      //for two finger and non-mtk five finger and ten finger
+    if (rc != bytes_to_recv)
+        printk("mtk-tpd:[elan_debug] The package error.\n");
+    MTK_TP_DEBUG("[elan_recv] %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\n", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15],buf[16], buf[17]);
+#else
+    rc = i2c_master_recv(client, buf, 8);  //for two finger and non-mtk five finger and ten finger
+    if (rc != 8)
+        printk("mtk-tpd:[elan_debug] The first package error.\n");
+    MTK_TP_DEBUG("[elan_recv] %x %x %x %x %x %x %x %x\n", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+	msleep(1);
+
+    if (buf[0] == MTK_FINGERS_PKT)             //for mtk five finger
+    {
+        rc = i2c_master_recv(client, buf+ 8, 8);
+        if (rc != 8)
+            printk("mtk-tpd:[elan_debug] The second package error.\n");
+        MTK_TP_DEBUG("[elan_recv] %x %x %x %x %x %x %x %x\n", buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]);
+
+        rc = i2c_master_recv(client, buf+ 16, 2);
+        if (rc != 2)
+            printk("mtk-tpd:[elan_debug] The third package error.\n");
+        MTK_TP_DEBUG("[elan_recv] %x %x \n", buf[16], buf[17]);
+
+    }
+    else if (buf[0] == TEN_FINGERS_PKT)        //for ten finger
+    {
+        rc = i2c_master_recv(client, buf+ 8, 8);
+        if (rc != 8)
+            printk("[elan_debug] The second package error.\n");
+        MTK_TP_DEBUG("[elan_recv] %x %x %x %x %x %x %x %x\n", buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]);
+
+        rc = i2c_master_recv(client, buf+ 16, 8);
+        if (rc != 8)
+            printk("mtk-tpd:[elan_debug] The third package error.\n");
+        MTK_TP_DEBUG("[elan_recv] %x %x %x %x %x %x %x %x\n", buf[16], buf[17], buf[18], buf[19], buf[20], buf[21], buf[22], buf[23]);
+
+        rc = i2c_master_recv(client, buf+ 24, 8);
+        if (rc != 8)
+            printk("[elan_debug] The four package error.\n");
+        MTK_TP_DEBUG("[elan_recv] %x %x %x %x %x %x %x %x\n", buf[24], buf[25], buf[26], buf[27], buf[28], buf[29], buf[30], buf[31]);
+
+        rc = i2c_master_recv(client, buf+ 32, 8);
+        if (rc != 8)
+            printk("mtk-tpd:[elan_debug] The five package error.\n");
+        MTK_TP_DEBUG("mtk-tpd:[elan_recv] %x %x %x %x %x %x %x %x\n", buf[32], buf[33], buf[34], buf[35], buf[36], buf[37], buf[38], buf[39]);
+
+        rc = i2c_master_recv(client, buf+ 40, 4);
+        if (rc != 4)
+            printk("mtk-tpd:[elan_debug] The six package error.\n");
+        MTK_TP_DEBUG("mtk-tpd:[elan_recv] %x %x %x %x\n", buf[40], buf[41], buf[42], buf[43]);
+
+    }
+#endif
+#endif
+	//below add for reflush IC
+	if ((buf[0] != 0 && buf[0] != 120 && buf[0] != 90) || (man_made != 0))
+	{
+		printk("-----%s:[%d]----err comming ----err_buf_times = %d\n", __func__, __LINE__, err_buf_times);
+		ekt_debug_in = 1; //fisrt open debug info
+		err_buf_times++;
+	#ifdef _DMA_MODE_
+		if (err_buf_times == NEED_FLUSH_DMA)
+		{
+			printk("reason one: DMA err, alloc new DMA -----%s:[%d]----\n",  __func__, __LINE__);
+			dma_free_coherent(NULL, 4096, gpDMABuf_va, gpDMABuf_pa);//free old
+			gpDMABuf_va = NULL;
+			gpDMABuf_pa = NULL;
+			msleep(10);
+			printk("reason one: DMA err, alloc new DMA -----%s:[%d]----\n",  __func__, __LINE__);
+			gpDMABuf_va = (u8 *)dma_alloc_writecombine(NULL, 4096, &gpDMABuf_pa, GFP_KERNEL);
+			if (!gpDMABuf_va){
+				printk("reason one: DMA err, alloc failed -----%s:[%d]----\n",  __func__, __LINE__);
+				dma_alloc_err = 1;
+			}
+			printk("reason one: DMA err, alloc new DMA ok -----%s:[%d]----\n",  __func__, __LINE__);
+		}
+	#endif
+		if (err_buf_times == NEED_RESET_IC)
+		{
+			printk("-----%s:[%d] need reset IC----\n", __func__, __LINE__);
+			// Reset Touch Pannel
+			mt_set_gpio_mode( GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO );
+			mt_set_gpio_dir( GPIO_CTP_RST_PIN, GPIO_DIR_OUT );
+			mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);
+			msleep(50);
+			mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+			msleep(300);
+			// End Reset Touch Pannel
+			err_buf_times = 0;
+		}
+	}else{
+		ekt_debug_in = 0; //close debug info
+	} 
+
+
+	//end reflush IC
+
+    return rc;
+}
+
+#ifdef SOFTKEY_AXIS_VER //SOFTKEY is reported via AXI
+static void elan_ktf2k_ts_report_data(struct i2c_client *client, uint8_t *buf)
+{
+    //struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+    struct input_dev *idev = tpd->dev;
+    uint16_t x, y;
+    uint16_t fbits=0;
+    uint8_t i, num, reported = 0;
+    uint8_t idx, btn_idx;
+    int finger_num;
+    int limitY = Y_RESOLUTION - 100; // limitY need define by Case!
+
+#ifdef TP_PROXIMITY_SENSOR_NEW
+    hwm_sensor_data sensor_data;
+    int ret = 0;
+
+    if (buf[0] == 0x55)
+    {
+        if (PROXIMITY == 1)
+        {
+            CTP_Face_Mode_Switch(1);
+            MTK_TP_DEBUG("mtk-tpd:[elan] 55 55 55 55--PS ON---\n", __func__);
+        }
+    }
+    else if(buf[0] == 0xFA)
+    {
+        if(buf[2] == 0xAA && PROXIMITY == 1 ) // close to
+        {
+            PROXIMITY_STATE = 0;
+            MTK_TP_DEBUG("tpd_touchinfo PROXIMITY_STATE %d\n",PROXIMITY_STATE );
+        }
+        else if(buf[2] == 0x55 && PROXIMITY == 1 ) // leave
+        {
+            PROXIMITY_STATE = 1;
+            MTK_TP_DEBUG("tpd_touchinfo PROXIMITY_STATE %d\n",PROXIMITY_STATE );
+        }
+        if (PROXIMITY == 1)
+        {
+            //get raw data
+            MTK_TP_DEBUG(" ps change\n");
+            //map and store data to hwm_sensor_data
+            sensor_data.values[0] = Get_Ctp_Face_Mode();
+            sensor_data.value_divide = 1;
+            sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+            //report to the up-layer
+            ret = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data);
+
+            if (ret)
+            {
+                MTK_TP_DEBUG("Call hwmsen_get_interrupt_data fail = %d\n", ret);
+            }
+        }
+    }
+#endif
+    /* for 10 fingers       */
+    if (buf[0] == TEN_FINGERS_PKT)
+    {
+        finger_num = 10;
+        num = buf[2] & 0x0f;
+        fbits = buf[2] & 0x30;
+        fbits = (fbits << 4) | buf[1];
+        idx=3;
+        btn_idx=33;
+    }
+// for 5 fingers
+    else if ((buf[0] == MTK_FINGERS_PKT) || (buf[0] == FIVE_FINGERS_PKT))
+    {
+        finger_num = 5;
+        num = buf[1] & 0x07;
+        fbits = buf[1] >>3;
+        idx=2;
+        btn_idx=17;
+    }
+    else
+    {
+// for 2 fingers
+        finger_num = 2;
+        num = buf[7] & 0x03;
+        fbits = buf[7] & 0x03;
+        idx=1;
+        btn_idx=7;
+    }
+
+    switch (buf[0])
+    {
+        case MTK_FINGERS_PKT:
+        case TWO_FINGERS_PKT:
+        case FIVE_FINGERS_PKT:
+        case TEN_FINGERS_PKT:
+            //input_report_key(idev, BTN_TOUCH, 1);
+            if (num == 0)
+            {
+                //dev_dbg(&client->dev, "no press\n");
+                if(key_pressed < 0)
+                {
+                    input_report_key(tpd->dev, BTN_TOUCH, 0);
+                    input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 0);
+                    input_report_abs(idev, ABS_MT_WIDTH_MAJOR, 0);
+                    input_mt_sync(idev);
+                    if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+                    {
+                        tpd_button(x, y, 0);
+                    }
+                    TPD_EM_PRINT(x, y, x, y, 0, 0);
+                }
+                else
+                {
+                    //dev_err(&client->dev, "[elan] KEY_RELEASE: key_code:%d\n",OSD_mapping[key_pressed].key_event);
+                    input_report_key(idev, OSD_mapping[key_pressed].key_event, 0);
+                    key_pressed = -1;
+                }
+            }
+            else
+            {
+                //dev_dbg(&client->dev, "[elan] %d fingers\n", num);
+                //input_report_key(idev, BTN_TOUCH, 1);
+                for (i = 0; i < finger_num; i++)
+                {
+                    if ((fbits & 0x01))
+                    {
+                        elan_ktf2k_ts_parse_xy(&buf[idx], &x, &y);
+                        //elan_ktf2k_ts_parse_xy(&buf[idx], &y, &x);
+                        //x = X_RESOLUTION-x;
+                        //y = Y_RESOLUTION-y;
+#if 1
+                        if(X_RESOLUTION > 0 && Y_RESOLUTION > 0)
+                        {
+                            x = ( x * LCM_X_MAX )/X_RESOLUTION;
+                            y = ( y * LCM_Y_MAX )/Y_RESOLUTION;
+                        }
+                        else
+                        {
+                            x = ( x * LCM_X_MAX )/ELAN_X_MAX;
+                            y = ( y * LCM_Y_MAX )/ELAN_Y_MAX;
+                        }
+#endif
+                        MTK_TP_DEBUG("[elan_debug SOFTKEY_AXIS_VER] %s, x=%d, y=%d\n",__func__, x , y);
+
+                        if (!((x<=0) || (y<=0) || (x>=X_RESOLUTION) || (y>=Y_RESOLUTION)))
+                        {
+                            if ( y < limitY )
+                            {
+                                MTK_TP_DEBUG("mtk-tpd elan_ktf2k_ts_report_data x=%d y=%d id=%d \n",x,y,i);
+                                input_report_key(tpd->dev, BTN_TOUCH, 1);
+                                input_report_abs(idev, ABS_MT_TRACKING_ID, i);
+                                input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 8);
+                                input_report_abs(idev, ABS_MT_POSITION_X, x);
+                                input_report_abs(idev, ABS_MT_POSITION_Y, y);
+                                input_mt_sync(idev);
+                                if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+                                {
+                                    tpd_button(x, y, 1);
+                                }
+                                TPD_EM_PRINT(x, y, x, y, i-1, 1);
+                            }
+                            else
+                            {
+                                int i=0;
+                                for(i=0; i<4; i++)
+                                {
+                                    if((x > OSD_mapping[i].left_x) && (x < OSD_mapping[i].right_x))
+                                    {
+                                        //dev_err(&client->dev, "[elan] KEY_PRESS: key_code:%d\n",OSD_mapping[i].key_event);
+                                        //printk("[elan] %d KEY_PRESS: key_code:%d\n", i, OSD_mapping[i].key_event);
+                                        input_report_key(idev, OSD_mapping[i].key_event, 1);
+                                        key_pressed = i;
+                                    }
+                                }
+                            }
+                            reported++;
+
+                        } // end if border
+                    } // end if finger status
+                    fbits = fbits >> 1;
+                    idx += 3;
+                } // end for
+            }
+
+            if (reported)
+                input_sync(idev);
+            else
+            {
+                input_mt_sync(idev);
+                input_sync(idev);
+                MTK_TP_DEBUG("mtk-tpd elan_ktf2k_ts_report_data up\n");
+            }
+
+            break;
+        default:
+            MTK_TP_DEBUG("[elan] %s: unknown packet type: %0x\n", __func__, buf[0]);
+#if 0
+            if(buf[0]==0x66)
+            {
+                uint8_t cmd[] = {CMD_W_PKT, 0x50, 0x00, 0x01};
+
+                printk("[elan] TP enter into sleep mode\n");
+                if ((i2c_master_send(private_ts->client, cmd, sizeof(cmd))) != sizeof(cmd))
+                {
+                    printk("[elan] %s: i2c_master_send failed\n", __func__);
+                    //return -retval;
+                }
+                mt_set_gpio_mode( GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO );
+                mt_set_gpio_dir( GPIO_CTP_RST_PIN, GPIO_DIR_OUT );
+                mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+                msleep(10);
+                mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);
+                msleep(10);
+                mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+                mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+                printk("mtk-tpd elan_ktf2k_ts_report_data packet 0x66 reset\n");
+
+            }
+#endif
+            break;
+    } // end switch
+    return;
+}
+#else //SOFTKEY is reported via BTN bit
+static void elan_ktf2k_ts_report_data(struct i2c_client *client, uint8_t *buf)
+{
+    /*struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);*/
+    struct input_dev *idev = tpd->dev;
+    uint16_t x, y;
+    uint16_t fbits=0;
+    uint8_t i, num, reported = 0;
+    uint8_t idx, btn_idx;
+    int finger_num;
+#ifdef TP_PROXIMITY_SENSOR_NEW
+    hwm_sensor_data sensor_data;
+    int ret = 0;
+
+    if (buf[0] == 0x55)
+    {
+    	//for finger up 
+        input_report_key(idev, BTN_TOUCH, 0);
+        input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 0);
+        input_report_abs(idev, ABS_MT_WIDTH_MAJOR, 0);
+        input_mt_sync(idev);
+        input_sync(idev);
+		
+        if (PROXIMITY == 1)
+        {
+            CTP_Face_Mode_Switch(1);
+            MTK_TP_DEBUG("mtk-tpd:[elan] 55 55 55 55--PS ON---\n", __func__);
+        }
+    }
+    else if(buf[0] == 0xFA)
+    {
+        if(buf[2] == 0xAA && PROXIMITY == 1 ) // close to
+        {
+            PROXIMITY_STATE = 0;
+            MTK_TP_DEBUG("tpd_touchinfo PROXIMITY_STATE %d\n",PROXIMITY_STATE );
+        }
+        else if(buf[2] == 0x55 && PROXIMITY == 1 ) // leave
+        {
+            PROXIMITY_STATE = 1;
+            MTK_TP_DEBUG("tpd_touchinfo PROXIMITY_STATE %d\n",PROXIMITY_STATE );
+        }
+        if (PROXIMITY == 1)
+        {
+            //get raw data
+            MTK_TP_DEBUG(" ps change\n");
+            //map and store data to hwm_sensor_data
+            sensor_data.values[0] = Get_Ctp_Face_Mode();
+            sensor_data.value_divide = 1;
+            sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+            //report to the up-layer
+            ret = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data);
+
+            if (ret)
+            {
+                MTK_TP_DEBUG("Call hwmsen_get_interrupt_data fail = %d\n", ret);
+            }
+        }
+    }
+#endif
+
+    /* for 10 fingers       */
+    if (buf[0] == TEN_FINGERS_PKT)
+    {
+        finger_num = 10;
+        num = buf[2] & 0x0f;
+        fbits = buf[2] & 0x30;
+        fbits = (fbits << 4) | buf[1];
+        idx=3;
+        btn_idx=33;
+    }
+// for 5 fingers
+    else if ((buf[0] == MTK_FINGERS_PKT) || (buf[0] == FIVE_FINGERS_PKT))
+    {
+        finger_num = 5;
+        num = buf[1] & 0x07;
+        fbits = buf[1] >>3;
+        idx=2;
+        btn_idx=17;
+    }
+    else
+    {
+// for 2 fingers
+        finger_num = 2;
+        num = buf[7] & 0x03;
+        fbits = buf[7] & 0x03;
+        idx=1;
+        btn_idx=7;
+    }
+
+    switch (buf[0])
+    {
+        case MTK_FINGERS_PKT:
+        case TWO_FINGERS_PKT:
+        case FIVE_FINGERS_PKT:
+        case TEN_FINGERS_PKT:
+            //input_report_key(idev, BTN_TOUCH, 1);
+            if (num == 0)
+            {
+                dev_dbg(&client->dev, "no press\n");
+#ifdef ELAN_DEBUG
+                printk("button_state0 = %x\n",button_state);
+                printk("buf[btn_idx] = %x KEY_MENU=%x KEY_HOME=%x KEY_BACK=%x KEY_SEARCH =%x\n",buf[btn_idx], KEY_MENU, KEY_HOME, KEY_BACK, KEY_SEARCH);
+#endif
+				 printk("button_state0 = %x\n",button_state);
+                printk("buf[btn_idx] = %x KEY_MENU=%x KEY_HOME=%x KEY_BACK=%x KEY_SEARCH =%x\n",buf[btn_idx], KEY_MENU, KEY_HOME, KEY_BACK, KEY_SEARCH);
+                //if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+                //{
+                //  tpd_button(x, y, 0);
+                //}
+                //TPD_EM_PRINT(x, y, x, y, 0, 0);
+
+#ifdef ELAN_BUTTON
+
+                switch (buf[btn_idx]&0xFC)
+                {
+                    case ELAN_KEY_BACK:
+                        printk("KEY back 1\n");
+#ifndef LCT_VIRTUAL_KEY
+                        input_report_key(idev, KEY_BACK, 1);
+#else
+                        input_report_key(idev, BTN_TOUCH, 1);
+                        input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 8);
+                        input_report_abs(idev, ABS_MT_POSITION_X, 617);
+                        input_report_abs(idev, ABS_MT_POSITION_Y, 1360);
+#endif
+                        if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+                        {
+                            x=617;
+                            y=1360;
+                            tpd_button(x, y, 1);
+                            MTK_TP_DEBUG("[elan] FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode()\n\n",button_state);
+                        }
+                        button_state = KEY_BACK;
+                        break;
+
+                    case ELAN_KEY_HOME:
+                        printk("KEY home 1\n");
+#ifndef LCT_VIRTUAL_KEY
+                        input_report_key(idev, KEY_HOMEPAGE, 1);
+#else
+                        input_report_key(idev, BTN_TOUCH, 1);
+                        input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 8);
+                        input_report_abs(idev, ABS_MT_POSITION_X, 300);
+                        input_report_abs(idev, ABS_MT_POSITION_Y, 1370);
+#endif
+                        if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+                        {
+                            x=300;
+                            y=1360;
+                           tpd_button(x, y, 1);
+				  //input_report_key(idev, KEY_BACK, 1);
+				 // input_sync(idev);
+
+                            MTK_TP_DEBUG("[elan] FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode()\n\n",button_state);
+                        }
+
+                        button_state = KEY_HOMEPAGE;
+                        break;
+
+                    case ELAN_KEY_MENU:
+                        printk("KEY menu 1\n");
+#ifndef LCT_VIRTUAL_KEY
+                        input_report_key(idev, KEY_MENU, 1);
+#else
+                        input_report_key(idev, BTN_TOUCH, 1);
+                        input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 8);
+                        input_report_abs(idev, ABS_MT_POSITION_X, 107);
+                        input_report_abs(idev, ABS_MT_POSITION_Y, 1370);
+#endif
+                        if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+                        {
+                            x=107;
+                            y=1360;
+                            tpd_button(x, y, 1);
+                            MTK_TP_DEBUG("[elan] FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode()\n\n",button_state);
+                        }
+                        button_state = KEY_MENU;
+                        break;
+
+                    // TOUCH release
+                    default:
+                        printk("mtk-tpd:[ELAN ] test tpd up\n");
+                        input_report_key(idev, BTN_TOUCH, 0);
+                        input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 0);
+                        input_report_abs(idev, ABS_MT_WIDTH_MAJOR, 0);
+                        input_mt_sync(idev);
+                        tpd_down_flag = 0;
+                        if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+                        {
+                            tpd_button(x, y, 0);
+                            MTK_TP_DEBUG("[elan] FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode()\n\n",button_state);
+                        }
+
+                        button_state = 0;
+                        break;
+                }
+                if (!(FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode()))
+                   input_sync(idev);
+#endif
+            }
+            else
+            {
+                //dev_dbg(&client->dev, "[elan] %d fingers\n", num);
+                input_report_key(idev, BTN_TOUCH, 1);
+                for (i = 0; i < finger_num; i++)
+                {
+                    if ((fbits & 0x01))
+                    {
+                        elan_ktf2k_ts_parse_xy(&buf[idx], &x, &y);
+                        //elan_ktf2k_ts_parse_xy(&buf[idx], &y, &x);
+#if 1
+                        if(X_RESOLUTION > 0 && Y_RESOLUTION > 0)
+                        {
+                            x = ( x * LCM_X_MAX )/X_RESOLUTION;
+                            y = ( y * LCM_Y_MAX )/Y_RESOLUTION;
+                        }
+                        else
+                        {
+                            x = ( x * LCM_X_MAX )/ELAN_X_MAX;
+                            y = ( y * LCM_Y_MAX )/ELAN_Y_MAX;
+                        }
+#endif
+
+                        //x = ( x * LCM_X_MAX )/ELAN_X_MAX;
+                        //y = ( y * LCM_Y_MAX )/ELAN_Y_MAX;
+#ifdef ELAN_DEBUG
+                        MTK_TP_DEBUG("mtk-tpd:[elan_debug  BTN bit] %s, x=%d, y=%d\n",__func__, x , y);
+#endif
+                        //x = LCM_X_MAX-x;
+                        //y = Y_RESOLUTION-y;
+                        if (!((x>=LCM_X_MAX) || (y>=LCM_Y_MAX)))
+                        {
+                            input_report_key(idev, BTN_TOUCH, 1);
+                            input_report_abs(idev, ABS_MT_TRACKING_ID, i);
+                            input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 8);
+                            input_report_abs(idev, ABS_MT_POSITION_X, x);
+                            input_report_abs(idev, ABS_MT_POSITION_Y, y);
+                            input_mt_sync(idev);
+
+                            if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+                            {
+                                tpd_button(x, y, 1);
+                            }
+                            TPD_EM_PRINT(x, y, x, y, i-1, 1);
+
+                            reported++;
+                            tpd_down_flag=1;
+                        } // end if border
+                    } // end if finger status
+                    fbits = fbits >> 1;
+                    idx += 3;
+                } // end for
+            }
+            if (reported)
+                input_sync(idev);
+            else
+            {
+                input_mt_sync(idev);
+                input_sync(idev);
+            }
+            break;
+        default:
+            MTK_TP_DEBUG("mtk-tpd:[elan] %s: unknown packet type: %0x\n", __func__, buf[0]);
+            break;
+    } // end switch
+    return;
+}
+#endif
+
+static void elan_ktf2k_ts_work_func(struct work_struct *work)
+{
+    int rc;
+    struct elan_ktf2k_ts_data *ts =
+        container_of(work, struct elan_ktf2k_ts_data, work);
+    uint8_t buf[PACKET_SIZE] = { 0 };
+
+//               if (gpio_get_value(ts->intr_gpio))
+    if (mt_get_gpio_in(GPIO_CTP_EINT_PIN))
+    {
+        //enable_irq(ts->client->irq);
+        printk("[elan]: Detected Jitter at INT pin. \n");
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+        return;
+    }
+
+    rc = elan_ktf2k_ts_recv_data(ts->client, buf);
+
+    if (rc < 0)
+    {
+        //enable_irq(ts->client->irq);
+        printk("[elan] elan_ktf2k_ts_recv_data Error, Error code %d \n", rc);
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+        return;
+    }
+
+    //printk("[elan] %2x,%2x,%2x,%2x,%2x,%2x\n",buf[0],buf[1],buf[2],buf[3],buf[5],buf[6]);
+    elan_ktf2k_ts_report_data(ts->client, buf);
+
+    //enable_irq(ts->client->irq);
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+
+    return;
+}
+
+static irqreturn_t elan_ktf2k_ts_irq_handler(int irq, void *dev_id)
+{
+    struct elan_ktf2k_ts_data *ts = dev_id;
+    struct i2c_client *client = ts->client;
+
+    dev_dbg(&client->dev, "[elan] %s\n", __func__);
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+    tpd_flag = 1;
+    wake_up_interruptible(&waiter);
+    return IRQ_HANDLED;
+}
+
+static int elan_ktf2k_ts_register_interrupt(struct i2c_client *client)
+{
+    struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+    int err = 0;
+
+    err = request_irq(client->irq, elan_ktf2k_ts_irq_handler,
+                      IRQF_TRIGGER_LOW, client->name, ts);
+    if (err)
+        dev_err(&client->dev, "[elan] %s: request_irq %d failed\n",
+                __func__, client->irq);
+
+    return err;
+}
+
+#ifdef IAP_PORTION
+static int update_fw_handler(void *unused)
+{
+    int New_FW_ID;
+    int New_FW_VER;
+    //struct i2c_client client= private_ts->client;
+
+    struct sched_param param = { .sched_priority = 4 };
+    sched_setscheduler(current, SCHED_RR, &param);
+
+    while(probe_flage == 0){
+        msleep(20);//2014/7/8 for update
+    	}
+
+        work_lock=1;
+    //disable_irq(CUST_EINT_TOUCH_PANEL_NUM);
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+    power_lock=1;
+    printk("[elan] start fw update\n");
+
+    /* FW ID & FW VER*/
+#ifdef ELAN_3K_IC_SOLUTION
+    /*For ektf31xx iap ekt file   */
+    printk("[ELAN] [0x7d64]=0x%02x,  [0x7d65]=0x%02x, [0x7d66]=0x%02x, [0x7d67]=0x%02x\n",  file_fw_data[32100],file_fw_data[32101],file_fw_data[32102],file_fw_data[32103]);
+    New_FW_ID = file_fw_data[0x7d67]<<8  | file_fw_data[0x7d66] ;
+    New_FW_VER = file_fw_data[0x7d65]<<8  | file_fw_data[0x7d64] ;
+
+    printk(" FW_ID=0x%x,   New_FW_ID=0x%x \n",  FW_ID, New_FW_ID);
+    printk(" FW_VERSION=0x%x,   New_FW_VER=0x%x \n",  FW_VERSION  , New_FW_VER);
+#else
+    /* For ektf21xx and ektf20xx iap ekt file  */
+    printk("[ELAN]  [7bd0]=0x%02x,  [7bd1]=0x%02x, [7bd2]=0x%02x, [7bd3]=0x%02x\n",  file_fw_data[31696],file_fw_data[31697],file_fw_data[31698],file_fw_data[31699]);
+    New_FW_ID = file_fw_data[31699]<<8  | file_fw_data[31698] ;
+    New_FW_VER = file_fw_data[31697]<<8  | file_fw_data[31696] ;
+    printk(" FW_ID=0x%x,   New_FW_ID=0x%x \n",  FW_ID, New_FW_ID);
+    printk(" FW_VERSION=0x%x,   New_FW_VER=0x%x \n",  FW_VERSION  , New_FW_VER);
+#endif
+
+    /* for firmware auto-upgrade*/
+    if (New_FW_ID   ==  FW_ID)
+    {
+        if (New_FW_VER > (FW_VERSION))
+            Update_FW_One(private_ts->client, RECOVERY);
+
+    }
+    else
+    {
+        printk("FW_ID is different!");
+        Update_FW_One(private_ts->client, RECOVERY);
+    }
+
+    //Update_FW_One(private_ts->client, RECOVERY);
+    // Reset Touch Pannel
+    mt_set_gpio_mode( GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO );
+    mt_set_gpio_dir( GPIO_CTP_RST_PIN, GPIO_DIR_OUT );
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);
+    msleep(50);
+    mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+    msleep(300);
+    // End Reset Touch Pannel
+
+	//read TP infomation again for update new FW 20140708
+    elan_ktf2k_ts_setup(private_ts->client);
+
+    power_lock=0;
+    work_lock=0;
+    //enable_irq(CUST_EINT_TOUCH_PANEL_NUM);
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+    printk("[elan] end fw update\n");
+
+    kthread_should_stop();
+#ifdef _DMA_FW_UPGRADE_MODE_
+    if(gpDMAFWBuf_va)
+    {
+        dma_free_coherent(NULL, 4096, gpDMAFWBuf_va, gpDMAFWBuf_pa);
+        gpDMAFWBuf_va = NULL;
+        gpDMAFWBuf_pa = NULL;
+    }
+#endif
+    return 0;
+}
+#endif
+
+static int touch_event_handler(void *unused)
+{
+    int rc;
+    uint8_t buf[PACKET_SIZE] = { 0 };
+
+    int touch_state = 3;
+//      int button_state = 0;
+    unsigned long time_eclapse;
+    struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
+    sched_setscheduler(current, SCHED_RR, &param);
+    int last_key = 0;
+    int key;
+    int index = 0;
+    int i =0;
+    MTK_TP_DEBUG("mtk-tpd interrupt touch_event_handler\n");
+
+    do
+    {
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+        MTK_TP_DEBUG("mtk-tpd touch_event_handler mt_eint_unmask tpd_flag = %d\n", tpd_flag);
+        set_current_state(TASK_INTERRUPTIBLE);
+        wait_event_interruptible(waiter, tpd_flag != 0);
+        tpd_flag = 0;
+        set_current_state(TASK_RUNNING);
+        mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+        MTK_TP_DEBUG("mtk-tpd touch_event_handler mt_eint_mask\n");
+        rc = elan_ktf2k_ts_recv_data(private_ts->client, buf);
+
+        if (rc < 0)
+        {
+            printk("mtk-tpd:[elan] rc<0 rc = %d\n", rc);
+
+            continue;
+        }
+
+        elan_ktf2k_ts_report_data(/*ts*/private_ts->client, buf);
+
+    }
+    while(!kthread_should_stop());
+
+    return 0;
+}
+
+static int tpd_detect(struct i2c_client *client, int kind, struct i2c_board_info *info)
+{
+    strcpy(info->type, TPD_DEVICE);
+
+    return 0;
+}
+
+static void tpd_eint_interrupt_handler(void)
+{
+    MTK_TP_DEBUG("TPD interrupt has been triggered\n");
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#ifdef ESD_CHECK
+    have_interrupts = 1;
+#endif
+    tpd_flag = 1;
+    wake_up_interruptible(&waiter);
+}
+
+static int __RE_K_handler(struct i2c_client *client)
+{
+    int rc;
+    uint8_t buf_recv[4] = { 0 };
+
+    rc = elan_ktf2k_ts_poll(client);
+    if (rc < 0)
+    {
+        printk( "[elan] %s: Int poll failed!\n", __func__);
+    }
+
+    i2c_master_recv(client, buf_recv, 4);
+
+    printk("[elan] %s: RE-K Packet %2x:%2X:%2x:%2x\n", __func__, buf_recv[0], buf_recv[1], buf_recv[2], buf_recv[3]);
+
+    return 0;
+}
+
+static void ctp_power_on(void)
+{
+    //power on, need confirm with SA
+#ifdef TPD_POWER_SOURCE_CUSTOM
+    hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
+#else
+    hwPowerOn(MT6323_POWER_LDO_VGP2, VOL_2800, "TP");
+#endif
+
+#ifdef TPD_POWER_SOURCE_1800
+    hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
+#endif
+
+}
+
+#ifdef IAP_PORTION
+extern char tpd_desc[50];
+static void get_vendor_info()
+{
+    int i,vendor_num = 0;
+    //FW ID CHECK ----start by baojun.fu
+    printk("KERN_ERR [elan] %s:  FW_ID: 0x%4.4x \n", __func__, FW_ID);
+    vendor_num = sizeof(g_vendor_map)/sizeof(g_vendor_map[0]);
+	if (vendor_num == 1)
+	{
+		file_fw_data = g_vendor_map[0].fw_array;
+		return;
+	}
+	else
+	{
+		for(i=0; i < vendor_num; i++)
+		{
+			if(FW_ID == g_vendor_map[i].vendor_id)
+			{
+				file_fw_data = g_vendor_map[i].fw_array;
+#ifdef TINNO_DEVICE_INFO
+				sprintf(tpd_desc, "%s",g_vendor_map[i].vendor_name);
+				printk("[elan] %s:  tpd_desc=%s \n", __func__, g_vendor_map[i].vendor_name);
+#endif
+				return;
+				}
+			}
+		}
+    printk(KERN_ERR "[elan] TP ID is error: no support!\n");
+}
+#endif
+static ssize_t ekt2k_show_version(struct device *dev,
+                                      struct device_attribute *attr, char *buf)
+{
+    ssize_t ret = 0;
+    struct elan_ktf2k_ts_data *ts = private_ts;
+	__fw_packet_handler(private_ts->client);
+	return sprintf(buf, "FW_VERSION = 0x%x, FW_ID = 0x%x, IC = ektf2k, VENDOR = ekt\n", FW_VERSION, FW_ID);
+}
+static ssize_t ekt2k_show_fw_need_update(struct device *dev,
+                                      struct device_attribute *attr, char *buf)
+{
+	//Implementation later 
+}
+static DEVICE_ATTR(ektf2k_version, S_IRUGO|S_IWUSR|S_IWGRP,ekt2k_show_version, NULL);
+static DEVICE_ATTR(ektf2k_fw_need_update, S_IRUGO|S_IWUSR|S_IWGRP, ekt2k_show_fw_need_update, NULL);
+
+static struct attribute *ektf2k_attributes[] = {
+	&dev_attr_ektf2k_version.attr,
+	&dev_attr_ektf2k_fw_need_update.attr,
+	NULL
+	};
+static struct attribute_group ektf2k_attribute_group = {
+	.attrs = ektf2k_attributes
+	};
+static struct kobject *viatel_kobj;
+/*
+struct kobject *viatel_kobject_add(const char *name)
+{
+	struct kobject *kobj = NULL;
+	if(viatel_kobj){
+			kobj = kobject_create_and_add(name, viatel_kobj);
+		}
+		return kobj;
+}
+*/
+static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    int fw_err = 0;
+    int New_FW_ID;
+    int New_FW_VER;
+    int retval = TPD_OK;
+	int check_ic_ret = 0;
+	char data;
+    static struct elan_ktf2k_ts_data ts;
+
+#ifdef TP_PROXIMITY_SENSOR_NEW
+    struct hwmsen_object obj_ps;
+    s32 err = 0;
+#endif
+
+    client->addr |= I2C_ENEXT_FLAG;
+
+    printk("mtk-tpd:[elan] %s:client addr is %x, TPD_DEVICE = ektf2k\n",__func__,client->addr);
+    client->timing =  100;
+#if 1
+    i2c_client = client;
+    private_ts = &ts;
+    private_ts->client = client;
+#endif
+    ctp_power_on();
+    msleep(10);
+
+    MTK_TP_DEBUG("[elan] ELAN enter tpd_probe ,the i2c addr=0x%x\n", client->addr);
+
+
+    // Reset Touch Pannel
+    mt_set_gpio_mode( GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO );
+    mt_set_gpio_dir( GPIO_CTP_RST_PIN, GPIO_DIR_OUT );
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);
+    msleep(50);
+    mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+    msleep(300);
+    // End Reset Touch Pannel
+	//below add for compat ekt and mstar chip
+	check_ic_ret = __check_ekt_ic_on_board(client);
+	printk("--%s:[%d]--check ekt ic on board result = %d\n", __func__, __LINE__, check_ic_ret);
+	if (check_ic_ret < 0)
+	{
+		printk("--%s:[%d]--no ekt chip on board \n", __func__, __LINE__);
+		have_ektf2k_chip_on_board = 0;
+		ektf2k_probed = 1;
+		return -1;
+	}else
+	{
+		printk("--%s:[%d]--find ekt chip on board \n", __func__, __LINE__);
+		have_ektf2k_chip_on_board = 1;
+		ektf2k_probed = 1;
+	}
+	//end add for compat ekt and mstar chip
+#ifdef _DMA_MODE_
+    gpDMABuf_va = (u8 *)dma_alloc_coherent(NULL, 4096, &gpDMABuf_pa, GFP_KERNEL);
+    if(!gpDMABuf_va)
+    {
+        printk(KERN_INFO "[elan] Allocate DMA I2C Buffer failed\n");
+    }
+#endif
+#ifdef _DMA_FW_UPGRADE_MODE_
+    gpDMAFWBuf_va = (u8 *)dma_alloc_coherent(NULL, 4096, &gpDMAFWBuf_pa, GFP_KERNEL);
+    if(!gpDMAFWBuf_va)
+    {
+        printk(KERN_INFO "[elan] Allocate DMA I2C Buffer failed\n");
+    }
+#endif
+    fw_err = elan_ktf2k_ts_setup(client);
+    if (fw_err < 0)
+    {
+        printk(KERN_INFO "[elan] No Elan chip inside\n");
+    }
+	if(tpd_reg_flag == 0)//// 1 -->elan; 0 -->other;
+	{
+		//return -1; //do not return for a chance to pc tool force update FW
+	}
+
+#ifndef LCT_VIRTUAL_KEY
+    set_bit( KEY_BACK,  tpd->dev->keybit );
+    set_bit( KEY_HOMEPAGE,  tpd->dev->keybit );
+    set_bit( KEY_MENU,  tpd->dev->keybit );
+#endif
+
+    // Setup Interrupt Pin
+    mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
+    mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
+    mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_DISABLE);
+    //mt_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
+    mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_FALLING, tpd_eint_interrupt_handler, 0);
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+    msleep(10);
+    // End Setup Interrupt Pin
+
+    tpd_load_status = 1;
+
+    thread = kthread_run(touch_event_handler, 0, TPD_DEVICE);
+    if(IS_ERR(thread))
+    {
+        retval = PTR_ERR(thread);
+        printk(TPD_DEVICE "mtk-tpd:[elan]  failed to create kernel thread: %ld\n", retval);
+    }
+
+    printk("mtk-tpd:[elan]  ELAN Touch Panel Device Probe %s\n", (retval < TPD_OK) ? "FAIL" : "PASS");
+
+    // Firmware Update
+    // MISC
+    ts.firmware.minor = MISC_DYNAMIC_MINOR;
+    ts.firmware.name = "elan-iap";
+    ts.firmware.fops = &elan_touch_fops;
+    ts.firmware.mode = S_IRWXUGO;
+
+    if (misc_register(&ts.firmware) < 0)
+        printk("mtk-tpd:[elan] misc_register failed!!\n");
+    else
+        MTK_TP_DEBUG("[elan] misc_register finished!!\n");
+    // End Firmware Update
+
+#ifdef IAP_PORTION
+    get_vendor_info();
+    //if no matched FW ID , DO NOT to update
+    if (file_fw_data != NULL)
+    {
+        update_thread = kthread_run(update_fw_handler, 0, TPD_DEVICE);
+        if(IS_ERR(update_thread))
+        {
+            retval = PTR_ERR(update_thread);
+            printk(TPD_DEVICE "failed to create kernel update thread: %ld\n", retval);
+        }
+    }
+#endif
+
+#ifdef TP_PROXIMITY_SENSOR_NEW
+    obj_ps.polling = 0;        //0--interrupt mode;1--polling mode;
+    obj_ps.sensor_operate = ektf2k_ps_operate;
+
+    if ((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
+    {
+        TPD_DEBUG("hwmsen attach fail, return:%d.", err);
+    }
+#endif
+
+#ifdef ESD_CHECK
+    INIT_DELAYED_WORK(&esd_work, elan_touch_esd_func);
+    esd_wq = create_singlethread_workqueue("esd_wq");
+    if (!esd_wq)
+    {
+        return -ENOMEM;
+
+    }
+    queue_delayed_work(esd_wq, &esd_work, delay);
+#endif
+
+    probe_flage = 1;
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+	//add attribute struct input_dev *idev = tpd->dev;
+	retval = sysfs_create_group(&client->dev.kobj, &ektf2k_attribute_group);
+	/*ektf2t_kobj = viatel_kobject_add("ektf2k_touch");
+	if (!ektf2t_kobj){
+			printk(KERN_ERR,  "error viatel_kobject_add!\n");
+			retval = -ENOMEM;
+		}
+	
+	retval = sysfs_create_group(ektf2t_kobj, &ektf2k_attribute_group);
+	*/
+	if(retval)
+	{
+		printk(KERN_ERR"add attribute failed\n");
+		//return retval;
+	}
+    return 0;
+}
+
+#ifdef TP_PROXIMITY_SENSOR_NEW
+static int CTP_Face_Mode_State(void)
+{
+    return PROXIMITY;
+}
+
+static  int CTP_Face_Mode_Switch(int onoff_state)
+
+{
+
+    if(work_lock == 1)
+    {
+        return -1;
+    }
+    U8 bWriteData[4] =
+    {
+        0x54, 0xC1, 0x00, 0x01
+    };
+
+    if(onoff_state==1)
+    {
+        PROXIMITY =1;
+        bWriteData[1] = 0xC1;
+        PROXIMITY_STATE = 1;
+        PROXIMITY_SLEEP = 0;
+    }
+    else
+    {
+        PROXIMITY =0;
+        bWriteData[1] = 0xC0;
+        PROXIMITY_STATE = -1;
+        PROXIMITY_SLEEP = 0;
+    }
+
+    printk("CTP_Face_Mode_Switch  onoff_state %d, PROXIMITY %d\n",onoff_state, PROXIMITY);
+
+    return i2c_master_send( i2c_client, &bWriteData[0], 4);
+}
+static  int Get_Ctp_Face_Mode(void)
+{
+    printk("Get_Ctp_Face_Mode PROXIMITY_STATE %d\n",PROXIMITY_STATE);
+
+    return PROXIMITY_STATE;
+}
+
+
+s32 ektf2k_ps_operate(void *self, u32 command, void *buff_in, s32 size_in,
+                      void *buff_out, s32 size_out, s32 *actualout)
+{
+    s32 err = 0;
+    s32 value;
+    hwm_sensor_data *sensor_data;
+
+    switch (command)
+    {
+        case SENSOR_DELAY:
+            printk("hdx ektf2k_ps_operate SENSOR_DELAY\n");
+            if ((buff_in == NULL) || (size_in < sizeof(int)))
+            {
+                TPD_DEBUG("Set delay parameter error!");
+                err = -EINVAL;
+            }
+
+            // Do nothing
+            break;
+
+        case SENSOR_ENABLE:
+            printk("hdx ektf2k_ps_operate SENSOR_ENABLE");
+            if ((buff_in == NULL) || (size_in < sizeof(int)))
+            {
+                TPD_DEBUG("Enable sensor parameter error!");
+                err = -EINVAL;
+            }
+            else
+            {
+                value = *(int *)buff_in;
+                CTP_Face_Mode_Switch(value);
+            }
+
+            break;
+
+        case SENSOR_GET_DATA:
+            printk("hdx ektf2k_ps_operate SENSOR_GET_DATA\n");
+            if ((buff_out == NULL) || (size_out < sizeof(hwm_sensor_data)))
+            {
+                TPD_DEBUG("Get sensor data parameter error!");
+                err = -EINVAL;
+            }
+            else
+            {
+                sensor_data = (hwm_sensor_data *)buff_out;
+                sensor_data->values[0] = Get_Ctp_Face_Mode();
+                sensor_data->value_divide = 1;
+                sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
+            }
+
+            break;
+
+        default:
+            TPD_DEBUG("proxmy sensor operate function no this parameter %d!\n", command);
+            err = -1;
+            break;
+    }
+
+    return err;
+}
+#endif
+
+#ifdef ESD_CHECK
+static void elan_touch_esd_func(struct work_struct *work)
+{
+    int res;
+    uint8_t cmd[] = {0x53, 0x00, 0x00, 0x01};
+    struct i2c_client *client = private_ts->client;
+    //add by baojun.fu for i'm alive
+    static int por_cnt = 0;
+
+    printk("[elan esd] %s: enter.......\n", __FUNCTION__);      /* elan_dlx */
+    if(work_lock == 1) //updating or doing something else
+    {
+        printk("[elan esd] %s: work locked ..\n", __FUNCTION__);        /* elan_dlx */
+	    queue_delayed_work(esd_wq, &esd_work, delay);//add queue for IAP
+        return;
+    }
+
+    if(have_interrupts == 1)
+    {
+        printk("[elan esd] %s: had interrup not need check\n", __func__);
+    }
+    else
+    {
+        if ((++por_cnt) >= 2)
+        {
+            por_cnt = 0;
+            printk("[elan esd] %s: i'm alive failed need reset!\n", __func__);
+            //reset here
+            mt_set_gpio_mode(GPIO_CTP_RST_PIN, 0);
+            mt_set_gpio_dir(GPIO_CTP_RST_PIN, 1);
+            mt_set_gpio_out(GPIO_CTP_RST_PIN, 0);
+            msleep(10);
+
+            // for enable/reset pin
+            mt_set_gpio_mode(GPIO_CTP_RST_PIN, 0);
+            mt_set_gpio_dir(GPIO_CTP_RST_PIN, 1);
+            mt_set_gpio_out(GPIO_CTP_RST_PIN, 1);
+            msleep(10);
+        }
+        else
+        {
+            res = i2c_master_send(client, cmd, sizeof(cmd));
+            if (res != sizeof(cmd))
+            {
+                printk("[elan esd] %s: i2c_master_send failed reset now\n", __func__);
+                //reset here
+                mt_set_gpio_mode(GPIO_CTP_RST_PIN, 0);
+                mt_set_gpio_dir(GPIO_CTP_RST_PIN, 1);
+                mt_set_gpio_out(GPIO_CTP_RST_PIN, 0);
+                msleep(10);
+
+                // for enable/reset pin
+                mt_set_gpio_mode(GPIO_CTP_RST_PIN, 0);
+                mt_set_gpio_dir(GPIO_CTP_RST_PIN, 1);
+                mt_set_gpio_out(GPIO_CTP_RST_PIN, 1);
+                msleep(10);
+
+            }
+            else
+            {
+                printk("[elan esd] %s: i2c_master_send successful\n", __func__);
+
+                msleep(20);
+
+                if(have_interrupts == 1)
+                {
+                    printk("[elan esd] %s: i2c_master_send successful, had response\n", __func__);
+                }
+                else
+                {
+                    printk("[elan esd] %s: i2c_master_send successful, no response need reset\n", __func__);
+                    //reset here
+                    mt_set_gpio_mode(GPIO_CTP_RST_PIN, 0);
+                    mt_set_gpio_dir(GPIO_CTP_RST_PIN, 1);
+                    mt_set_gpio_out(GPIO_CTP_RST_PIN, 0);
+                    msleep(10);
+
+                    // for enable/reset pin
+                    mt_set_gpio_mode(GPIO_CTP_RST_PIN, 0);
+                    mt_set_gpio_dir(GPIO_CTP_RST_PIN, 1);
+                    mt_set_gpio_out(GPIO_CTP_RST_PIN, 1);
+                    msleep(10);
+                }
+            }
+        }
+    }
+
+    have_interrupts = 0;
+    queue_delayed_work(esd_wq, &esd_work, delay);
+    printk("[elan esd] %s: exit.......\n", __FUNCTION__);       /* elan_dlx */
+}
+#endif
+
+#ifdef TINNO_DEVICE_INFO
+static int ektf2k_tpd_get_fw_version( void )
+{
+    return FW_VERSION;
+}
+
+static void ektf2k_tpd_get_fw_vendor_name(char * fw_vendor_name)
+{
+    sprintf(fw_vendor_name, "%s", tpd_desc);
+}
+#endif
+
+static int tpd_remove(struct i2c_client *client)
+{
+    printk("mtk-tpd:[elan] TPD removed\n");
+
+#ifdef _DMA_MODE_
+    if(gpDMABuf_va)
+    {
+        dma_free_coherent(NULL, 4096, gpDMABuf_va, gpDMABuf_pa);
+        gpDMABuf_va = NULL;
+        gpDMABuf_pa = NULL;
+    }
+#endif
+
+    return 0;
+}
+
+
+static int tpd_suspend(struct i2c_client *client, pm_message_t message)
+{
+    int retval = TPD_OK;
+    static char data = 0x3;
+    uint8_t cmd[] = {CMD_W_PKT, 0x50, 0x00, 0x01};
+
+    printk("mtk-tpd:[elan] TP enter into sleep mode\n");
+    if(work_lock == 1) //updating or doing something else
+    {
+        printk(" [elan]%s: TP work locked \n", __func__);
+        return -1;
+    }
+
+#if defined(TP_PROXIMITY_SENSOR_NEW)
+    if( PROXIMITY == 1 )//PROXIMITY_STATE
+    {
+        PROXIMITY_SLEEP = 1;
+        printk("mtk-tpd:[elan] TP enter into sleep mode  ps return!\n");
+        return ;
+    }
+#endif //TP_PROXIMITY_SENSOR_NEW
+
+#ifdef ESD_CHECK
+    cancel_delayed_work_sync(&esd_work);
+#endif
+
+    if ((i2c_master_send(private_ts->client, cmd, sizeof(cmd))) != sizeof(cmd))
+    {
+        printk("mtk-tpd:[elan] %s: i2c_master_send failed\n", __func__);
+        return -retval;
+    }
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+
+    return retval;
+}
+
+
+static int tpd_resume(struct i2c_client *client)
+{
+    int retval = TPD_OK;
+    uint8_t cmd[] = {CMD_W_PKT, 0x58, 0x00, 0x01};
+    printk("mtk-tpd:[elan]tpd_resume TPD wake up,FW_ID: 0x%4.4x\n",FW_ID);
+
+    if(work_lock == 1) //updating or doing something else
+    {
+        printk(" [elan]%s: TP work locked \n", __func__);
+        return -1;
+    }
+
+#if defined(TP_PROXIMITY_SENSOR_NEW)
+    if( PROXIMITY== 1)//PROXIMITY_SLEEP
+    {
+        if (PROXIMITY_SLEEP == 1)
+        {
+            PROXIMITY_SLEEP = 0;
+            printk("mtk-tpd:[elan]tpd_resume TPD wake up ps return!\n");
+            return ;
+        }
+    }
+#endif //TP_PROXIMITY_SENSOR_NEW
+
+#ifdef ESD_CHECK
+    queue_delayed_work(esd_wq, &esd_work, delay);
+#endif
+
+#if 1
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);
+    msleep(10);
+    mt_set_gpio_out( GPIO_CTP_RST_PIN, GPIO_OUT_ONE );
+//    msleep(10);
+#else
+    if ((i2c_master_send(private_ts->client, cmd, sizeof(cmd))) != sizeof(cmd))
+    {
+        printk("[elan] %s: i2c_master_send failed\n", __func__);
+        return -retval;
+    }
+    msleep(200);
+#endif
+
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+    return retval;
+}
+
+static int tpd_local_init(void)
+{
+    printk("[mtk-tpd]: ektf I2C Touchscreen Driver init\n");
+    if(i2c_add_driver(&tpd_i2c_driver) != 0)
+    {
+        printk("[mtk-tpd]: unable to add i2c driver.\n");
+        return -1;
+    }
+
+    if(tpd_load_status == 0)
+    {
+        printk("ektf2k add error touch panel driver.\n");
+        i2c_del_driver(&tpd_i2c_driver);
+        return -1;
+    }
+
+#ifdef TPD_HAVE_BUTTON
+    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
+#endif
+
+#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
+    TPD_DO_WARP = 1;
+    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT * 4);
+    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT * 4);
+#endif
+#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
+    memcpy(tpd_calmat, tpd_def_calmat_local, 8*4);
+    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8*4);
+#endif
+
+    printk("mtk-tpd:end %s, %d\n", __FUNCTION__, __LINE__);
+    tpd_type_cap = 1;
+    return 0;
+}
+
+
+static struct tpd_driver_t tpd_device_driver =
+{
+    .tpd_device_name = "ektf2k",
+    .tpd_local_init = tpd_local_init,
+    .suspend = tpd_suspend,
+    .resume = tpd_resume,
+#ifdef TPD_HAVE_BUTTON
+    .tpd_have_button = 1,
+#else
+    .tpd_have_button = 0,
+#endif
+#ifdef TINNO_DEVICE_INFO
+    .tpd_get_fw_version = ektf2k_tpd_get_fw_version,
+    .tpd_get_fw_vendor_name = ektf2k_tpd_get_fw_vendor_name,
+#endif
+};
+
+static int __init tpd_driver_init(void)
+{
+    printk("mtk-tpd ektf2k touch panel driver init\n");
+
+    i2c_register_board_info(I2C_NUM, &ektf2k_i2c_tpd, 1);
+
+    if(tpd_driver_add(&tpd_device_driver) < 0)
+    {
+        printk("[mtk-tpd]: %s driver failed\n", __func__);
+    }
+    return 0;
+}
+
+
+static void __exit tpd_driver_exit(void)
+{
+    printk("[mtk-tpd]: %s elan ektf touch panel driver exit\n", __func__);
+    tpd_driver_remove(&tpd_device_driver);
+}
+
+module_init(tpd_driver_init);
+module_exit(tpd_driver_exit);
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_driver.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_driver.h
new file mode 100755
index 0000000..9af7f2e
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_driver.h
@@ -0,0 +1,90 @@
+#ifndef _LINUX_ELAN_KTF2K_H
+#define _LINUX_ELAN_KTF2K_H
+
+#include <linux/hrtimer.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+//#include <linux/io.h>
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/byteorder/generic.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/rtpm_prio.h>
+
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+#include <mach/mt_gpio.h>
+
+#include <cust_eint.h>
+#include <pmic_drv.h>
+#include <linux/jiffies.h>
+#include <linux/miscdevice.h>
+
+#define ELAN_KTF2K_NAME "elan-ktf2k"
+
+#define PWR_STATE_DEEP_SLEEP              0
+#define PWR_STATE_NORMAL                  1
+#define PWR_STATE_MASK                    BIT(3)
+
+#define CMD_S_PKT                         0x52
+#define CMD_R_PKT                         0x53
+#define CMD_W_PKT                         0x54
+
+#define HELLO_PKT                         	0x55
+#define TWO_FINGERS_PKT             	   	0x5A
+#define FIVE_FINGERS_PKT                  	0x5D
+#define MTK_FINGERS_PKT                   	0x6D    /** 2 Fingers: 5A, 5 Fingers: 5D, 10 Fingers: 62 **/
+#define TEN_FINGERS_PKT              		0x62
+
+#define RESET_PKT                    			0x77
+#define CALIB_PKT                    			0xA8
+
+#define TPD_OK 0
+
+
+struct elan_ktf2k_i2c_platform_data {
+         uint16_t version;
+         int abs_x_min;
+         int abs_x_max;
+         int abs_y_min;
+         int abs_y_max;
+         int intr_gpio;
+         int (*power)(int on);
+};
+
+struct osd_offset{
+        int left_x;
+        int right_x;
+        unsigned int key_event;
+};
+
+//Elan add for OSD bar coordinate
+static struct osd_offset OSD_mapping[] = {
+	{35, 99, KEY_MENU},     		//menu_left_x, menu_right_x, KEY_MENU
+	{203, 267, KEY_HOMEPAGE}, 		//home_left_x, home_right_x, KEY_HOME
+	{373, 437, KEY_BACK},  			//back_left_x, back_right_x, KEY_BACK
+	{541, 605, KEY_SEARCH},   		//search_left_x, search_right_x, KEY_SEARCH
+};
+
+static int key_pressed = -1;
+
+#endif /* _LINUX_ELAN_KTF2K_H */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_firmware.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_firmware.h
new file mode 100755
index 0000000..0be55c4
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/ektf2k_firmware.h
@@ -0,0 +1,33 @@
+#ifdef IAP_PORTION
+
+/*
+const u8 shenyue_fw[]=
+{
+#include "shenyue_03.i"
+};
+const u8 dijing_fw[]=
+{
+#include "dijing_S4010_02.i"
+};
+*/
+const u8 huaruichuan_fw[]=
+{
+#include "huaruichuan_03.i"
+};
+
+struct vendor_map
+{
+	int vendor_id;
+	char vendor_name[30];
+	uint8_t* fw_array;
+};
+const struct vendor_map g_vendor_map[]=
+{
+//	{0x2925,"dijing",dijing_fw},
+//	{0x4010,"shenyue",shenyue_fw},
+	{0x14f0,"huaruichuan",huaruichuan_fw},
+//	{0x2926,"shenyue",shenyue_fw},
+//	{0x03ea,"huaruichuan",huaruichuan_fw}
+};
+
+#endif/*IAP_PORTION*/
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/huaruichuan_03.i b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/huaruichuan_03.i
new file mode 100755
index 0000000..af1d4dd
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/huaruichuan_03.i
@@ -0,0 +1,250 @@
+0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 
+0x40, 0x02, 0x98, 0x3f, 0x28, 0x09, 0x98, 0x3f, 0x29, 0x09, 0x98, 0x3f, 0x2a, 0x09, 0x98, 0x3f, 0xd4, 0x09, 0x98, 0x3f, 0xd5, 0x09, 0x98, 0x3f, 0xd6, 0x09, 0x98, 0x3f, 0xd7, 0x09, 0x98, 0x3f, 0xd8, 0x09, 0x98, 0x3f, 0xd9, 0x09, 0x98, 0x3f, 0xda, 0x09, 0x98, 0x3f, 0xdb, 0x09, 0x98, 0x3f, 0xdc, 0x09, 0x98, 0x3f, 0xdd, 0x09, 0x98, 0x3f, 0xde, 0x09, 0x98, 0x3f, 0xdf, 0x09, 0x98, 0x3f, 0xe0, 0x09, 0x98, 0x3f, 0xe1, 0x09, 0x98, 0x3f, 0xe2, 0x09, 0x98, 0x3f, 0xe3, 0x09, 0x98, 0x3f, 0xe4, 0x09, 0x98, 0x3f, 0xe6, 0x09, 0x98, 0x3f, 0xe8, 0x09, 0x98, 0x3f, 0xe9, 0x09, 0x98, 0x3f, 0xea, 0x09, 0x98, 0x3f, 0xeb, 0x09, 0x98, 0x3f, 0xed, 0x09, 0x98, 0x3f, 0xef, 0x09, 0x98, 0x3f, 0x0d, 0x0a, 0x98, 0x3f, 0x0e, 0x0a, 0x98, 0x3f, 0x0f, 0x0a, 0x98, 0x3f, 0x0e, 0x0b, 0x98, 0x3f, 0xa1, 0x0b, 0x98, 0x32, 
+0x80, 0x02, 0x98, 0x3f, 0x37, 0x0c, 0x98, 0x3f, 0x38, 0x0c, 0x1d, 0xb0, 0x60, 0xa8, 0x58, 0xaa, 0x50, 0xa8, 0x9d, 0xb0, 0x02, 0xa9, 0x41, 0xa9, 0x02, 0x62, 0x03, 0x6a, 0xb0, 0xb2, 0x02, 0x60, 0x40, 0x68, 0x0b, 0x5a, 0xb2, 0xb2, 0x0b, 0x5a, 0xb3, 0xb2, 0x41, 0xab, 0x02, 0xab, 0x27, 0xc4, 0x17, 0xc7, 0x27, 0xc5, 0x3f, 0xc5, 0x5d, 0xc5, 0xb4, 0xc6, 0xe5, 0xc8, 0xf5, 0xc8, 0x7d, 0xc5, 0x3f, 0xc6, 0xca, 0xc5, 0x35, 0xc6, 0x11, 0xc4, 0x92, 0xac, 0xfe, 0x91, 0x20, 0xc4, 0x11, 0xc4, 0xe3, 0xaa, 0xe5, 0xc8, 0xfe, 0xc8, 0xd1, 0xac, 0x02, 0x90, 0x11, 0xc9, 0x16, 0x9e, 0xd9, 0xac, 0x02, 0x90, 0x1f, 0xc9, 0x12, 0x9e, 0xc1, 0xac, 0x07, 0x92, 0xa9, 0xac, 0x18, 0x92, 0xa1, 0xac, 0x16, 0x92, 0x99, 0xac, 0x14, 0x92, 0x2b, 0x9e, 0x95, 0xc6, 0xc9, 0xa8, 0x27, 0xc4, 0xf1, 0xac, 0x01, 0x90, 0x50, 0x63, 
+0xc0, 0x02, 0xf1, 0xaa, 0xc1, 0xac, 0xfb, 0x93, 0xc9, 0xaa, 0xd1, 0xaa, 0xd9, 0xaa, 0x20, 0xc4, 0xd6, 0xc6, 0xe5, 0xc8, 0xf5, 0xc8, 0x7d, 0xc5, 0xca, 0xc5, 0xa8, 0xc6, 0x18, 0x9e, 0x7e, 0xc6, 0xe4, 0xaa, 0xec, 0xaa, 0xa9, 0xac, 0xd7, 0x93, 0xb4, 0xe4, 0xa1, 0xac, 0xd0, 0x93, 0xa1, 0xaa, 0x99, 0xaa, 0xbc, 0xac, 0x0c, 0x90, 0xbc, 0xaa, 0xa2, 0xa8, 0x04, 0x60, 0x27, 0x78, 0x66, 0x60, 0x28, 0x78, 0x29, 0x78, 0x2a, 0x78, 0x2b, 0x78, 0x93, 0xc6, 0xa2, 0xac, 0xfe, 0x93, 0x9e, 0x58, 0xb1, 0x04, 0x19, 0x10, 0x43, 0x8a, 0x83, 0xac, 0x04, 0x90, 0x83, 0xaa, 0x2e, 0xc4, 0x1a, 0x38, 0xfe, 0x9f, 0x94, 0xac, 0x02, 0x90, 0x98, 0x3f, 0x97, 0x06, 0x4a, 0xe7, 0x19, 0xc7, 0x35, 0xc4, 0x99, 0xac, 0x01, 0x90, 0xac, 0x9f, 0x9e, 0x58, 0x6c, 0x04, 0x00, 0xac, 0x1b, 0x90, 0x9e, 0x5a, 0x6d, 0x04, 0x42, 0xc8, 
+0x00, 0x03, 0x25, 0x60, 0x02, 0x68, 0x10, 0x38, 0x0a, 0x04, 0x03, 0x5b, 0x7a, 0x48, 0x0e, 0x80, 0x9e, 0x59, 0xe5, 0x00, 0x19, 0x01, 0xbe, 0x59, 0xe5, 0x00, 0x9e, 0x5a, 0x6e, 0x04, 0x3a, 0x48, 0x09, 0x9c, 0x00, 0x61, 0xbe, 0x59, 0xe5, 0x00, 0xa1, 0xa8, 0x04, 0x9e, 0x00, 0x61, 0xbe, 0x59, 0xe5, 0x00, 0x00, 0x9e, 0x43, 0xcc, 0xa1, 0xac, 0x8a, 0x93, 0x9e, 0x59, 0x90, 0x04, 0x18, 0x31, 0x0d, 0x8a, 0x11, 0xc4, 0xdb, 0xc7, 0x32, 0xb1, 0x29, 0xaa, 0xb2, 0xb1, 0x38, 0xb1, 0x41, 0xaa, 0x29, 0xaa, 0xb8, 0xb1, 0x35, 0xb1, 0x41, 0xa8, 0x29, 0xa8, 0xb5, 0xb1, 0x11, 0xc4, 0xba, 0xac, 0x0f, 0x92, 0xb9, 0xac, 0xfb, 0x91, 0x9e, 0x58, 0x02, 0x01, 0xbe, 0x58, 0x48, 0x00, 0xa0, 0xf8, 0xe0, 0xac, 0x6d, 0x91, 0xb7, 0x60, 0x01, 0x68, 0xbe, 0x58, 0x48, 0x00, 0xa0, 0xf8, 0x67, 0x9f, 0x82, 0xac, 0x15, 0x3b, 
+0x40, 0x03, 0x03, 0x92, 0x54, 0xb0, 0x38, 0xac, 0xfb, 0x93, 0xda, 0xac, 0x67, 0x90, 0xc3, 0xac, 0x10, 0x92, 0x9e, 0x58, 0x4a, 0x00, 0x19, 0x00, 0xbe, 0x58, 0x4a, 0x00, 0x05, 0x61, 0x01, 0x11, 0x07, 0x80, 0xc3, 0xa8, 0x00, 0x60, 0xec, 0xac, 0x01, 0x90, 0x01, 0x60, 0xbe, 0x58, 0x49, 0x00, 0x4e, 0x9f, 0x00, 0x60, 0x9e, 0x59, 0x86, 0x04, 0x38, 0x48, 0x49, 0x8b, 0x41, 0xa9, 0x00, 0x60, 0xc0, 0xb0, 0x41, 0xab, 0x00, 0x60, 0x54, 0x68, 0x82, 0xac, 0x02, 0x92, 0x00, 0x60, 0x4c, 0x68, 0xae, 0xb0, 0xcd, 0xa9, 0x00, 0x60, 0x84, 0x68, 0xa5, 0xb0, 0x08, 0x71, 0x06, 0x79, 0x07, 0x72, 0x59, 0x48, 0x12, 0x82, 0xf2, 0xa8, 0x00, 0x60, 0x9e, 0x59, 0x87, 0x04, 0x38, 0x48, 0x0c, 0x8a, 0x9e, 0x5b, 0x87, 0x04, 0x19, 0x13, 0x67, 0x38, 0x82, 0x03, 0x82, 0xac, 0x02, 0x92, 0x04, 0xc4, 0x01, 0x9e, 0x34, 0x8d, 
+0x80, 0x03, 0x0a, 0xc4, 0x1a, 0x38, 0x1a, 0x38, 0xf2, 0xaa, 0x9e, 0x5b, 0x86, 0x04, 0x19, 0x13, 0x67, 0x38, 0x8f, 0x03, 0x82, 0xac, 0x02, 0x92, 0x04, 0xc4, 0x01, 0x9e, 0x0a, 0xc4, 0x1a, 0x38, 0x1a, 0x38, 0xcd, 0xab, 0x41, 0xa9, 0x28, 0x60, 0xc0, 0xb0, 0x41, 0xab, 0x58, 0x60, 0x02, 0x68, 0x00, 0x61, 0x19, 0x10, 0x19, 0x48, 0xfd, 0x89, 0x00, 0x60, 0x50, 0x68, 0x82, 0xac, 0x02, 0x92, 0x00, 0x60, 0x48, 0x68, 0xae, 0xb0, 0x00, 0x60, 0xa5, 0xb0, 0x00, 0x60, 0x20, 0x68, 0x82, 0xac, 0x02, 0x92, 0x00, 0x60, 0xc0, 0x68, 0x8d, 0xb0, 0x98, 0x3f, 0xa6, 0x02, 0x41, 0xa9, 0x00, 0x60, 0xc0, 0xb0, 0x31, 0xb0, 0x04, 0x38, 0x00, 0x60, 0x1b, 0x28, 0x9e, 0x59, 0x9d, 0x04, 0x1b, 0x21, 0x7f, 0x38, 0x26, 0x59, 0x01, 0x28, 0xf3, 0xac, 0x02, 0x90, 0x05, 0x38, 0x40, 0x00, 0xb1, 0xb0, 0x40, 0xb0, 0x80, 0x0f, 
+0xc0, 0x03, 0x18, 0xa8, 0xc0, 0xb0, 0x00, 0x60, 0x05, 0x68, 0x32, 0x61, 0x07, 0x38, 0xca, 0x03, 0x37, 0x38, 0x1a, 0x38, 0x1a, 0x38, 0x1a, 0x38, 0x40, 0xb0, 0x18, 0xaa, 0xc0, 0xb0, 0x41, 0xab, 0x80, 0x60, 0x54, 0x68, 0x82, 0xac, 0x02, 0x92, 0x80, 0x60, 0x4c, 0x68, 0xae, 0xb0, 0x82, 0xac, 0x02, 0x92, 0x04, 0xc4, 0x01, 0x9e, 0x0a, 0xc4, 0x41, 0xa9, 0x31, 0xb0, 0x04, 0x38, 0x00, 0x60, 0x05, 0x38, 0x41, 0x00, 0x9e, 0x59, 0x9d, 0x04, 0x1b, 0x21, 0x7f, 0x38, 0x26, 0x59, 0x01, 0x28, 0xb1, 0xb0, 0x28, 0x60, 0xc0, 0xb0, 0x41, 0xab, 0x30, 0x60, 0x75, 0x68, 0x00, 0x61, 0x19, 0x10, 0x19, 0x48, 0xfd, 0x89, 0x00, 0x60, 0x50, 0x68, 0x82, 0xac, 0x02, 0x92, 0x00, 0x60, 0x48, 0x68, 0xae, 0xb0, 0x00, 0x60, 0xa5, 0xb0, 0x00, 0x60, 0x20, 0x68, 0x82, 0xac, 0x02, 0x92, 0x00, 0x60, 0xc0, 0x68, 0x1c, 0x79, 
+0x00, 0x04, 0x8d, 0xb0, 0xb4, 0xe4, 0x98, 0x3f, 0xa6, 0x02, 0x54, 0xb1, 0x39, 0xac, 0xfd, 0x93, 0x12, 0xa9, 0x1a, 0x38, 0x3a, 0x38, 0xa2, 0xac, 0xfe, 0x93, 0xaa, 0xac, 0xfc, 0x93, 0x12, 0xa9, 0x1a, 0x38, 0x3a, 0x38, 0x1e, 0x58, 0x1e, 0x59, 0x01, 0xb8, 0x41, 0xab, 0x24, 0xb0, 0x20, 0xa8, 0xa4, 0xb0, 0x7d, 0x60, 0xa1, 0x61, 0x01, 0x40, 0xef, 0xb0, 0x81, 0xb8, 0x3e, 0x59, 0x3e, 0x58, 0x3a, 0x38, 0x1e, 0x58, 0x9e, 0x58, 0x88, 0x04, 0xa4, 0xb0, 0x11, 0xc4, 0x3e, 0x58, 0x3a, 0x38, 0x1e, 0x58, 0x28, 0x60, 0x80, 0x68, 0xa4, 0xb0, 0x11, 0xc4, 0x3e, 0x58, 0x3a, 0x38, 0x1e, 0x58, 0x22, 0x60, 0x80, 0x68, 0xa4, 0xb0, 0x11, 0xc4, 0x3e, 0x58, 0x3a, 0x38, 0xe9, 0xac, 0xe8, 0x92, 0x9e, 0x58, 0x6f, 0x04, 0x18, 0x30, 0xeb, 0x8a, 0xb7, 0x61, 0x01, 0x69, 0x9e, 0x5b, 0x0b, 0x04, 0x9e, 0x5c, 0xf7, 0xd8, 
+0x40, 0x04, 0x02, 0x04, 0x64, 0x03, 0x9e, 0x5c, 0x70, 0x04, 0x18, 0x14, 0x03, 0x8a, 0x9e, 0x5c, 0x01, 0x04, 0x64, 0x03, 0x00, 0x67, 0x9e, 0x5a, 0x36, 0x05, 0x5f, 0x48, 0x01, 0x88, 0x64, 0x62, 0x9e, 0x5e, 0x35, 0x05, 0xdf, 0x48, 0x02, 0x88, 0x30, 0x66, 0x75, 0x6e, 0x67, 0x38, 0x5e, 0x04, 0x25, 0x5d, 0xba, 0x48, 0x01, 0x98, 0xba, 0x9e, 0xbe, 0x48, 0x01, 0x96, 0xb7, 0x9e, 0x1a, 0x38, 0xb7, 0x61, 0x01, 0x69, 0x9e, 0x5b, 0x0b, 0x04, 0x1b, 0x64, 0x24, 0x01, 0x67, 0x38, 0x6e, 0x04, 0x25, 0x5d, 0xba, 0x48, 0x01, 0x98, 0xaa, 0x9e, 0xbe, 0x48, 0x01, 0x96, 0xa7, 0x9e, 0x1a, 0x38, 0xee, 0x60, 0x01, 0x68, 0xb7, 0x61, 0x01, 0x69, 0x9e, 0x5a, 0x73, 0x04, 0x00, 0x63, 0xaf, 0x3e, 0x7e, 0x04, 0x05, 0x5c, 0x25, 0x5d, 0x85, 0x14, 0x9a, 0x48, 0x01, 0x96, 0x19, 0x03, 0x1a, 0x38, 0x9e, 0x5a, 0x31, 0x7a, 
+0x80, 0x04, 0x00, 0x04, 0x50, 0x3a, 0x01, 0x04, 0x50, 0x3a, 0x02, 0x04, 0x50, 0x3a, 0x17, 0x04, 0x9e, 0x58, 0x74, 0x04, 0x40, 0x12, 0x7a, 0x48, 0x93, 0x94, 0x9e, 0x58, 0x71, 0x04, 0x00, 0x61, 0x19, 0x48, 0x8e, 0x8a, 0xb7, 0x60, 0x01, 0x68, 0xee, 0x62, 0x01, 0x6a, 0x9e, 0x5f, 0x75, 0x04, 0x9e, 0x5d, 0x0b, 0x04, 0xa7, 0x38, 0xa1, 0x04, 0x45, 0x5c, 0x05, 0x5d, 0x85, 0x14, 0x9f, 0x48, 0x01, 0x96, 0x44, 0x9e, 0x1a, 0x38, 0xd2, 0x60, 0x01, 0x68, 0x09, 0x62, 0x02, 0x6a, 0x9e, 0x5d, 0x0b, 0x04, 0xa7, 0x38, 0xb0, 0x04, 0x45, 0x5c, 0x05, 0x5d, 0x85, 0x14, 0x9f, 0x48, 0x01, 0x96, 0x35, 0x9e, 0x1a, 0x38, 0x9e, 0x59, 0x02, 0x04, 0x18, 0x31, 0x15, 0x8a, 0xb7, 0x61, 0x01, 0x69, 0x30, 0x39, 0x06, 0x04, 0xee, 0x62, 0x01, 0x6a, 0x50, 0x3a, 0x06, 0x04, 0x9e, 0x5f, 0x76, 0x04, 0x9e, 0x5e, 0x65, 0x61, 
+0xc0, 0x04, 0x12, 0x04, 0xc7, 0x38, 0xc9, 0x04, 0x25, 0x5c, 0x45, 0x5d, 0xa4, 0x15, 0xbf, 0x48, 0x01, 0x96, 0x1c, 0x9e, 0x1a, 0x38, 0x9e, 0x58, 0x70, 0x04, 0x00, 0x61, 0x19, 0x48, 0x50, 0x8a, 0xb7, 0x61, 0x01, 0x69, 0x30, 0x39, 0x03, 0x01, 0xee, 0x62, 0x01, 0x6a, 0x50, 0x3a, 0x03, 0x01, 0x9e, 0x5f, 0x78, 0x04, 0x9e, 0x5e, 0x0d, 0x04, 0xc7, 0x38, 0xe3, 0x04, 0x25, 0x5c, 0x45, 0x5d, 0xa4, 0x15, 0xbf, 0x48, 0x01, 0x96, 0x02, 0x9e, 0x1a, 0x38, 0x3a, 0x9e, 0x9e, 0x58, 0xe6, 0x00, 0x19, 0x00, 0xbe, 0x58, 0xe6, 0x00, 0x9e, 0x59, 0x77, 0x04, 0x19, 0x48, 0x38, 0x9a, 0xb7, 0x60, 0x01, 0x68, 0xee, 0x62, 0x01, 0x6a, 0x9e, 0x5d, 0x0b, 0x04, 0x9e, 0x5e, 0x02, 0x04, 0xa6, 0x05, 0x9e, 0x5e, 0x01, 0x04, 0xa6, 0x05, 0xa7, 0x38, 0xfd, 0x04, 0x05, 0x5c, 0x9d, 0x5a, 0xd2, 0x61, 0x01, 0x69, 0x34, 0x09, 
+0x00, 0x05, 0x09, 0x63, 0x02, 0x6b, 0x9e, 0x5d, 0x0b, 0x04, 0xa1, 0x5d, 0xa7, 0x38, 0x08, 0x05, 0x25, 0x5c, 0x9d, 0x5b, 0x15, 0x9e, 0x9e, 0x59, 0xe4, 0x00, 0x19, 0x01, 0xbe, 0x59, 0xe4, 0x00, 0x9e, 0x5a, 0x79, 0x04, 0x3a, 0x48, 0x13, 0x96, 0x99, 0xa8, 0x0a, 0x9e, 0x9e, 0x59, 0xe3, 0x00, 0x19, 0x01, 0xbe, 0x59, 0xe3, 0x00, 0x9e, 0x5a, 0x77, 0x04, 0x3a, 0x48, 0x08, 0x96, 0x99, 0xa8, 0x00, 0x63, 0xbe, 0x5b, 0xe3, 0x00, 0xbe, 0x5b, 0xe6, 0x00, 0xbe, 0x5b, 0xe4, 0x00, 0x3a, 0x38, 0x00, 0x60, 0x0f, 0x68, 0x96, 0xb0, 0x00, 0x60, 0x80, 0xb0, 0x00, 0x60, 0x81, 0xb0, 0x41, 0xa9, 0x32, 0xb0, 0x18, 0xaa, 0xb2, 0xb0, 0x41, 0xab, 0x00, 0x60, 0x82, 0xb0, 0x00, 0x60, 0x83, 0xb0, 0x00, 0x60, 0x9c, 0xb0, 0xc0, 0x60, 0x13, 0x68, 0x9d, 0xb0, 0x00, 0x60, 0xa5, 0xb0, 0x3a, 0x38, 0xff, 0x60, 0x7e, 0xfb, 
+0x40, 0x05, 0xff, 0x68, 0x84, 0xb0, 0x85, 0xb0, 0x86, 0xb0, 0x00, 0x60, 0xb0, 0xb0, 0xb1, 0xb0, 0xb2, 0xb0, 0xff, 0x60, 0xff, 0x68, 0xb3, 0xb0, 0xb4, 0xb0, 0xb5, 0xb0, 0x00, 0x60, 0xb6, 0xb0, 0xb7, 0xb0, 0xb8, 0xb0, 0x00, 0x60, 0xb9, 0xb0, 0xba, 0xb0, 0xbb, 0xb0, 0x16, 0xa9, 0x32, 0xb0, 0x10, 0xa8, 0xb2, 0xb0, 0x35, 0xb0, 0x10, 0xaa, 0xb5, 0xb0, 0x3a, 0x38, 0x00, 0x60, 0xff, 0x61, 0x00, 0x62, 0x04, 0x63, 0x00, 0x64, 0x04, 0x6c, 0x04, 0x65, 0x00, 0x66, 0x08, 0x6e, 0x07, 0x67, 0x37, 0x38, 0x1d, 0x5a, 0x19, 0x13, 0xfc, 0x89, 0x37, 0x38, 0x1d, 0x5c, 0x19, 0x15, 0xfc, 0x89, 0x37, 0x38, 0x1d, 0x5e, 0x19, 0x17, 0xfc, 0x89, 0x3a, 0x38, 0x00, 0x60, 0xff, 0x61, 0x3f, 0x69, 0x00, 0x63, 0x27, 0x38, 0x7b, 0x05, 0x0b, 0x5a, 0x62, 0x03, 0x3a, 0x38, 0x82, 0xaa, 0xca, 0xaa, 0x94, 0xaa, 0x82, 0xd2, 
+0x80, 0x05, 0x90, 0xaa, 0xa2, 0xaa, 0xa1, 0xaa, 0x99, 0xaa, 0x81, 0xaa, 0xb9, 0xaa, 0xba, 0xa8, 0xb8, 0xa8, 0xc0, 0xaa, 0x80, 0xaa, 0x88, 0xaa, 0xa8, 0xa8, 0xb0, 0xa8, 0xda, 0xa8, 0xc3, 0xa8, 0x00, 0x60, 0xbe, 0x58, 0x49, 0x00, 0xbe, 0x58, 0x4a, 0x00, 0x2c, 0x60, 0x01, 0x68, 0x07, 0x78, 0x00, 0x60, 0x06, 0x78, 0xa3, 0xaa, 0x00, 0x60, 0x88, 0xb0, 0x89, 0xb0, 0x78, 0xa9, 0x9e, 0x58, 0x95, 0x04, 0xbe, 0x58, 0x4c, 0x00, 0x9e, 0x58, 0x94, 0x04, 0xbe, 0x58, 0xf6, 0x00, 0x00, 0x60, 0xbe, 0x58, 0xf9, 0x00, 0x9e, 0x58, 0xc2, 0x04, 0x19, 0x30, 0x0b, 0x88, 0x9e, 0x59, 0xc3, 0x04, 0x25, 0x38, 0x00, 0x00, 0x06, 0x8a, 0x22, 0x39, 0xe8, 0x03, 0x03, 0x8a, 0x01, 0x60, 0xbe, 0x58, 0xf9, 0x00, 0x9e, 0x58, 0x55, 0x04, 0xbe, 0x58, 0x23, 0x01, 0xd8, 0xaa, 0xe9, 0xaa, 0x8d, 0xaa, 0x00, 0x60, 0x9b, 0x2d, 
+0xc0, 0x05, 0xbe, 0x58, 0xfc, 0x00, 0xf0, 0xa8, 0xff, 0x60, 0x7f, 0x68, 0xbe, 0x58, 0x38, 0x01, 0xbe, 0x58, 0x39, 0x01, 0x3a, 0x38, 0x41, 0x60, 0xbe, 0x58, 0x62, 0x00, 0xbe, 0x58, 0x67, 0x00, 0x24, 0x60, 0xbe, 0x58, 0x63, 0x00, 0xbe, 0x58, 0x68, 0x00, 0x9e, 0x58, 0x32, 0x04, 0x19, 0x30, 0x29, 0x8a, 0x9e, 0x5a, 0xd2, 0x04, 0x44, 0x3a, 0xff, 0x00, 0x07, 0x8a, 0x40, 0x62, 0x1a, 0x48, 0x04, 0x9c, 0xbe, 0x5a, 0x31, 0x04, 0xe5, 0xc8, 0xf5, 0xc8, 0x9e, 0x58, 0x31, 0x04, 0x02, 0x3d, 0x01, 0x00, 0x9e, 0x5e, 0xd2, 0x04, 0xc4, 0x3e, 0xff, 0x00, 0x03, 0x88, 0xbf, 0x38, 0xa8, 0x5d, 0x02, 0x9e, 0x5f, 0x38, 0xa8, 0x5d, 0x19, 0x05, 0x00, 0x61, 0x1c, 0x5d, 0xbe, 0x5d, 0x0e, 0x01, 0xbe, 0x58, 0x0f, 0x01, 0xa0, 0x40, 0xbe, 0x58, 0x13, 0x01, 0x9e, 0x58, 0x0f, 0x01, 0x01, 0x61, 0x20, 0x01, 0x78, 0xb7, 
+0x00, 0x06, 0x05, 0x9e, 0x9e, 0x58, 0x0f, 0x01, 0x08, 0x58, 0x01, 0x61, 0x20, 0x01, 0x11, 0x61, 0x9e, 0x5a, 0xd2, 0x04, 0x44, 0x3a, 0xff, 0x00, 0x02, 0x8a, 0x03, 0x62, 0x22, 0x29, 0xbe, 0x59, 0x66, 0x00, 0xbe, 0x59, 0x6b, 0x00, 0xbe, 0x58, 0x65, 0x00, 0xbe, 0x58, 0x6a, 0x00, 0x20, 0x60, 0x80, 0x68, 0x9e, 0x59, 0x37, 0x04, 0x01, 0x29, 0xbe, 0x59, 0x52, 0x00, 0x9e, 0x59, 0x38, 0x04, 0x01, 0x29, 0xbe, 0x59, 0x53, 0x00, 0x9e, 0x59, 0x39, 0x04, 0x01, 0x29, 0xbe, 0x59, 0x54, 0x00, 0x9e, 0x59, 0x3a, 0x04, 0x01, 0x29, 0xbe, 0x59, 0x55, 0x00, 0x9e, 0x59, 0x3b, 0x04, 0x01, 0x29, 0xbe, 0x59, 0x64, 0x00, 0xbe, 0x59, 0x69, 0x00, 0xb4, 0xe4, 0x3a, 0x38, 0x04, 0x60, 0x27, 0x78, 0x55, 0x60, 0x28, 0x78, 0x29, 0x78, 0x2a, 0x78, 0x2b, 0x78, 0xa2, 0xa8, 0x93, 0xc6, 0x3a, 0x38, 0x82, 0xac, 0xca, 0x40, 
+0x40, 0x06, 0x1d, 0x92, 0x00, 0x60, 0x48, 0x68, 0xae, 0xb0, 0x35, 0xb2, 0x32, 0xaa, 0x3a, 0xaa, 0xb5, 0xb2, 0x3b, 0xb2, 0x32, 0xa8, 0x3a, 0xa8, 0xbb, 0xb2, 0x20, 0x60, 0xc4, 0x68, 0xd2, 0xb0, 0x9e, 0x58, 0xfb, 0x00, 0xd4, 0xb0, 0x00, 0x60, 0x1b, 0x78, 0x92, 0xaa, 0xca, 0xac, 0x01, 0x90, 0x92, 0xa8, 0xaa, 0xaa, 0xf9, 0xab, 0xf1, 0xab, 0xfd, 0xa9, 0xf5, 0xa9, 0x1c, 0x9e, 0x00, 0x60, 0x50, 0x68, 0xae, 0xb0, 0x35, 0xb2, 0x42, 0x3a, 0x30, 0x01, 0xb5, 0xb2, 0x3b, 0xb2, 0x50, 0x3a, 0x30, 0x01, 0xbb, 0xb2, 0x80, 0x60, 0xe9, 0x68, 0xf8, 0xb0, 0x00, 0x60, 0x1b, 0x78, 0x28, 0x70, 0xf9, 0xb0, 0x92, 0xaa, 0xca, 0xac, 0x01, 0x90, 0x92, 0xa8, 0xaa, 0xaa, 0x00, 0x60, 0x20, 0x68, 0x99, 0xb0, 0xe9, 0xab, 0xed, 0xa9, 0xca, 0xac, 0x01, 0x92, 0xa8, 0xc6, 0x3a, 0x38, 0x9e, 0x58, 0x62, 0x00, 0x1c, 0x2e, 
+0x80, 0x06, 0xbe, 0x58, 0x67, 0x00, 0x9e, 0x58, 0x63, 0x00, 0xbe, 0x58, 0x68, 0x00, 0x9e, 0x58, 0x64, 0x00, 0xbe, 0x58, 0x69, 0x00, 0x9e, 0x58, 0x66, 0x00, 0xbe, 0x58, 0x6b, 0x00, 0x9e, 0x58, 0x65, 0x00, 0xbe, 0x58, 0x6a, 0x00, 0x3a, 0x38, 0x16, 0xab, 0x3a, 0x38, 0x16, 0xa9, 0x3a, 0x38, 0x05, 0xa9, 0x34, 0xb1, 0x01, 0xaa, 0xb4, 0xb1, 0x31, 0xb1, 0x01, 0xa8, 0xb1, 0xb1, 0x1a, 0x38, 0x24, 0xb0, 0x20, 0xa8, 0xa4, 0xb0, 0x05, 0xad, 0x02, 0x92, 0x05, 0xa9, 0xf8, 0x9f, 0x05, 0xab, 0xf6, 0x9f, 0x41, 0xa9, 0x31, 0xb1, 0x9e, 0x58, 0x9c, 0x04, 0x18, 0x30, 0x02, 0x8a, 0x69, 0xa8, 0x01, 0x9e, 0x69, 0xaa, 0xb1, 0xb1, 0x41, 0xab, 0x3a, 0x38, 0x00, 0x60, 0x3e, 0x68, 0x00, 0x61, 0x04, 0x69, 0xff, 0x62, 0x01, 0x6a, 0x47, 0x38, 0xc1, 0x06, 0x0b, 0x5c, 0x86, 0x3b, 0xff, 0xff, 0x01, 0x88, 0x99, 0xaf, 
+0xc0, 0x06, 0x00, 0x64, 0x9d, 0x59, 0xc0, 0x60, 0x3c, 0x68, 0x09, 0x58, 0xff, 0x61, 0xff, 0x69, 0x01, 0x5a, 0xfe, 0x5a, 0x02, 0x32, 0x59, 0x48, 0x05, 0x88, 0x04, 0x38, 0x7f, 0x00, 0xbe, 0x58, 0xfb, 0x00, 0x03, 0x9e, 0x15, 0x60, 0xbe, 0x58, 0xfb, 0x00, 0xd6, 0xc6, 0x3a, 0x38, 0x9e, 0x58, 0x09, 0x04, 0xbe, 0x58, 0x03, 0x01, 0x9e, 0x58, 0x01, 0x04, 0x18, 0x30, 0x02, 0x88, 0xbe, 0x58, 0x0d, 0x04, 0x9e, 0x58, 0x02, 0x04, 0x18, 0x30, 0x02, 0x88, 0xbe, 0x58, 0x12, 0x04, 0x00, 0x60, 0x16, 0x38, 0xa3, 0x04, 0x04, 0x88, 0x10, 0x60, 0x27, 0x68, 0xbe, 0x58, 0xa3, 0x04, 0x00, 0x60, 0x16, 0x38, 0xa4, 0x04, 0x04, 0x88, 0x10, 0x60, 0x27, 0x68, 0xbe, 0x58, 0xa4, 0x04, 0x00, 0x60, 0x16, 0x38, 0xb0, 0x04, 0x04, 0x88, 0x90, 0x60, 0x01, 0x68, 0xbe, 0x58, 0xb0, 0x04, 0x00, 0x60, 0x16, 0x38, 0xdd, 0x62, 
+0x00, 0x07, 0xc4, 0x04, 0x04, 0x88, 0x9e, 0x58, 0x91, 0x04, 0xbe, 0x58, 0xc4, 0x04, 0x00, 0x60, 0x16, 0x38, 0xd9, 0x04, 0x04, 0x88, 0x9e, 0x58, 0x05, 0x04, 0xbe, 0x58, 0xd9, 0x04, 0x00, 0x60, 0x16, 0x38, 0xda, 0x04, 0x04, 0x88, 0x9e, 0x58, 0x04, 0x04, 0xbe, 0x58, 0xda, 0x04, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x9e, 0x58, 0x33, 0x01, 0x08, 0xac, 0x5e, 0x90, 0x27, 0xc4, 0x9e, 0x59, 0x34, 0x01, 0x9e, 0x5a, 0x35, 0x01, 0x50, 0x63, 0x0b, 0x6b, 0xb7, 0x64, 0x01, 0x6c, 0x20, 0x3d, 0x30, 0x0b, 0x18, 0x12, 0x17, 0x88, 0x00, 0x66, 0xdb, 0x5d, 0x40, 0xac, 0x07, 0x90, 0x48, 0xac, 0x02, 0x90, 0x7c, 0xc7, 0x08, 0x9e, 0xbe, 0x59, 0xd2, 0x04, 0x05, 0x9e, 0x20, 0x3e, 0x08, 0x00, 0xfe, 0x5e, 0xbe, 0x5e, 0x3b, 0x04, 0xe5, 0xc8, 0xf5, 0xc8, 0xca, 0xc5, 0x01, 0x62, 0xbe, 0x5a, 0x35, 0x01, 0x53, 0xfc, 
+0x40, 0x07, 0x3a, 0x9e, 0x05, 0x66, 0x5e, 0x48, 0x11, 0x9c, 0x00, 0x66, 0x35, 0x67, 0xe7, 0x38, 0x4e, 0x07, 0x63, 0x5f, 0x97, 0x17, 0x01, 0x8c, 0xe2, 0x5f, 0xc7, 0x06, 0x19, 0x03, 0x19, 0x04, 0xa3, 0x5f, 0xe6, 0x07, 0x02, 0x80, 0xff, 0x67, 0xff, 0x6f, 0xfb, 0x5d, 0x35, 0x67, 0x50, 0x63, 0x0b, 0x6b, 0xb7, 0x64, 0x01, 0x6c, 0xe7, 0x38, 0x5d, 0x07, 0x85, 0x5e, 0xdd, 0x5b, 0x19, 0x02, 0xbe, 0x5a, 0x35, 0x01, 0x69, 0x67, 0x5f, 0x48, 0x17, 0x9c, 0x19, 0x01, 0x19, 0x05, 0xbe, 0x59, 0x34, 0x01, 0x40, 0xac, 0x07, 0x90, 0x48, 0xac, 0x02, 0x90, 0x05, 0x67, 0x05, 0x9e, 0x9e, 0x5f, 0x36, 0x01, 0x02, 0x9e, 0x9e, 0x5f, 0x36, 0x01, 0x3f, 0x48, 0xb5, 0x81, 0x00, 0x61, 0x30, 0x65, 0x0b, 0x6d, 0xbe, 0x59, 0x34, 0x01, 0xaf, 0x9f, 0x3a, 0x38, 0x00, 0x66, 0x3e, 0x48, 0x0c, 0x8a, 0x01, 0x66, 0x49, 0x43, 
+0x80, 0x07, 0x3e, 0x48, 0x19, 0x8a, 0x02, 0x66, 0x3e, 0x48, 0x26, 0x8a, 0x03, 0x66, 0x3e, 0x48, 0x33, 0x8a, 0x04, 0x66, 0x3e, 0x48, 0x40, 0x8a, 0x04, 0x66, 0xbe, 0x5e, 0x30, 0x04, 0x40, 0x66, 0xbe, 0x5e, 0x31, 0x04, 0x02, 0x66, 0xbe, 0x5e, 0xd2, 0x04, 0x04, 0x66, 0xbe, 0x5e, 0xd3, 0x04, 0x01, 0x66, 0xbe, 0x5e, 0xd4, 0x04, 0x3f, 0x9e, 0x04, 0x66, 0xbe, 0x5e, 0x30, 0x04, 0x40, 0x66, 0xbe, 0x5e, 0x31, 0x04, 0x02, 0x66, 0xbe, 0x5e, 0xd2, 0x04, 0x04, 0x66, 0xbe, 0x5e, 0xd3, 0x04, 0x02, 0x66, 0xbe, 0x5e, 0xd4, 0x04, 0x2f, 0x9e, 0x04, 0x66, 0xbe, 0x5e, 0x30, 0x04, 0x40, 0x66, 0xbe, 0x5e, 0x31, 0x04, 0x0a, 0x66, 0xbe, 0x5e, 0xd2, 0x04, 0x04, 0x66, 0xbe, 0x5e, 0xd3, 0x04, 0x01, 0x66, 0xbe, 0x5e, 0xd4, 0x04, 0x1f, 0x9e, 0x04, 0x66, 0xbe, 0x5e, 0x30, 0x04, 0x40, 0x66, 0xbe, 0x5e, 0x4a, 0xb8, 
+0xc0, 0x07, 0x31, 0x04, 0x0b, 0x66, 0xbe, 0x5e, 0xd2, 0x04, 0x04, 0x66, 0xbe, 0x5e, 0xd3, 0x04, 0x01, 0x66, 0xbe, 0x5e, 0xd4, 0x04, 0x0f, 0x9e, 0x04, 0x66, 0xbe, 0x5e, 0x30, 0x04, 0x40, 0x66, 0xbe, 0x5e, 0x31, 0x04, 0x00, 0x66, 0xbe, 0x5e, 0xd2, 0x04, 0x04, 0x66, 0xbe, 0x5e, 0xd3, 0x04, 0x02, 0x66, 0xbe, 0x5e, 0xd4, 0x04, 0x3a, 0x38, 0x35, 0xb1, 0x29, 0xaa, 0xb5, 0xb1, 0x38, 0xb1, 0x29, 0xa8, 0xb8, 0xb1, 0x46, 0xad, 0x01, 0x90, 0x3a, 0x38, 0x00, 0x67, 0x00, 0x66, 0x73, 0xc8, 0xbe, 0x5e, 0x40, 0x01, 0x00, 0x67, 0x00, 0x66, 0x73, 0xc8, 0xbe, 0x5e, 0x41, 0x01, 0x9e, 0x5e, 0x40, 0x01, 0x7e, 0xac, 0x48, 0x90, 0x32, 0xb1, 0x29, 0xa8, 0xb2, 0xb1, 0x9e, 0x5e, 0x40, 0x01, 0x66, 0xac, 0x12, 0x92, 0x5e, 0xac, 0x01, 0x90, 0x0d, 0xc8, 0xff, 0x61, 0x03, 0x69, 0x9e, 0x5a, 0x40, 0x01, 0xba, 0x17, 
+0x00, 0x08, 0x22, 0x21, 0x19, 0x11, 0x9e, 0x5b, 0x41, 0x01, 0x27, 0x38, 0x09, 0x08, 0x00, 0x67, 0x63, 0x5e, 0x83, 0xc8, 0x19, 0x03, 0x3a, 0x38, 0x0d, 0xc8, 0x3a, 0x38, 0x9e, 0x59, 0x2f, 0x00, 0x1b, 0x21, 0x24, 0x38, 0x01, 0x00, 0x24, 0x3a, 0x02, 0x00, 0x48, 0x5a, 0x02, 0x00, 0x26, 0x59, 0x26, 0x59, 0x26, 0x59, 0x78, 0x21, 0x20, 0x29, 0xfe, 0x59, 0x9e, 0x5e, 0x29, 0x00, 0x26, 0x2e, 0x00, 0x67, 0x83, 0xc8, 0x9e, 0x59, 0x2a, 0x00, 0xfe, 0x59, 0x9e, 0x5e, 0x2b, 0x00, 0x26, 0x2e, 0x00, 0x67, 0x83, 0xc8, 0x9e, 0x59, 0x2c, 0x00, 0xfe, 0x59, 0x9e, 0x5e, 0x2d, 0x00, 0x26, 0x2e, 0x00, 0x67, 0x83, 0xc8, 0x9e, 0x59, 0x2e, 0x00, 0xfe, 0x59, 0x00, 0x66, 0xff, 0x6e, 0x26, 0x2e, 0x00, 0x67, 0x83, 0xc8, 0x3a, 0x38, 0xfa, 0xa8, 0x9e, 0x5e, 0x40, 0x01, 0x00, 0x61, 0x60, 0x69, 0x26, 0x26, 0x3d, 0x4d, 
+0x40, 0x08, 0x3e, 0x48, 0x0f, 0x8a, 0x9e, 0x59, 0x40, 0x01, 0xff, 0x62, 0x03, 0x6a, 0x22, 0x22, 0x19, 0x12, 0x9e, 0x5b, 0x41, 0x01, 0x47, 0x38, 0x4f, 0x08, 0x00, 0x67, 0x00, 0x66, 0x73, 0xc8, 0xdd, 0x5b, 0x3a, 0x38, 0x9e, 0x5b, 0x41, 0x01, 0x36, 0x65, 0x21, 0x6d, 0x7d, 0x48, 0x40, 0x8a, 0x02, 0x65, 0xff, 0x6d, 0x7d, 0x48, 0x6e, 0x8a, 0x00, 0x67, 0x00, 0x66, 0x73, 0xc8, 0xdb, 0x5b, 0x9e, 0x59, 0x40, 0x01, 0xff, 0x62, 0x03, 0x6a, 0x22, 0x22, 0x01, 0x67, 0x5f, 0x48, 0x0b, 0x8a, 0x1a, 0x12, 0x47, 0x38, 0x71, 0x08, 0x00, 0x67, 0x00, 0x66, 0x73, 0xc8, 0xc1, 0x5b, 0x00, 0x67, 0x00, 0x66, 0x73, 0xc8, 0xdb, 0x5b, 0x3a, 0x38, 0x46, 0xad, 0xfe, 0x91, 0x19, 0x07, 0x46, 0xad, 0xfe, 0x93, 0x2e, 0xad, 0x03, 0x92, 0x00, 0xab, 0xca, 0x5e, 0x02, 0x9e, 0x00, 0xa9, 0xca, 0x5e, 0x10, 0x65, 0x47, 0x63, 
+0x80, 0x08, 0xfd, 0x48, 0xf1, 0x89, 0x3a, 0x38, 0x32, 0xb1, 0x29, 0xa8, 0xb2, 0xb1, 0x46, 0xad, 0xfe, 0x91, 0x19, 0x07, 0x7e, 0xac, 0x02, 0x92, 0x2e, 0xab, 0x01, 0x9e, 0x2e, 0xa9, 0x46, 0xad, 0xfe, 0x93, 0xca, 0x5e, 0x10, 0x65, 0xfd, 0x48, 0xf2, 0x89, 0x46, 0xad, 0xfe, 0x91, 0x3a, 0x38, 0x00, 0x67, 0x00, 0x66, 0x73, 0xc8, 0x88, 0x65, 0x88, 0x6d, 0xbe, 0x48, 0x10, 0x88, 0x5a, 0x62, 0xe1, 0x6a, 0xac, 0xb2, 0x40, 0x61, 0x0a, 0x69, 0x40, 0x60, 0x3d, 0x68, 0xff, 0x3f, 0x7a, 0x38, 0xff, 0x3f, 0x7a, 0x38, 0xff, 0x3f, 0x7a, 0x38, 0x00, 0x62, 0xac, 0xb2, 0x1a, 0x9e, 0x77, 0x65, 0x77, 0x6d, 0xbe, 0x48, 0x16, 0x88, 0x5a, 0x62, 0xe1, 0x6a, 0xac, 0xb2, 0x40, 0x61, 0x0a, 0x69, 0x00, 0x60, 0x3e, 0x68, 0xff, 0x3f, 0x7a, 0x38, 0xff, 0x3f, 0x7a, 0x38, 0xff, 0x3f, 0x7a, 0x38, 0xff, 0x3f, 0x45, 0xad, 
+0xc0, 0x08, 0x7a, 0x38, 0xff, 0x3f, 0x7a, 0x38, 0xff, 0x3f, 0x7a, 0x38, 0x00, 0x62, 0xac, 0xb2, 0xa1, 0xa8, 0x3a, 0x38, 0x40, 0x61, 0x0a, 0x69, 0x40, 0x60, 0x3d, 0x68, 0xff, 0x3f, 0x0f, 0x59, 0xff, 0x3f, 0x0f, 0x59, 0xff, 0x3f, 0x0f, 0x59, 0x3a, 0x38, 0x00, 0x61, 0x0b, 0x69, 0x00, 0x60, 0x3e, 0x68, 0xff, 0x3f, 0x0f, 0x59, 0xff, 0x3f, 0x0f, 0x59, 0xff, 0x3f, 0x0f, 0x59, 0xff, 0x3f, 0x0f, 0x59, 0xff, 0x3f, 0x0f, 0x59, 0xff, 0x3f, 0x0f, 0x59, 0x3a, 0x38, 0x00, 0x60, 0x00, 0x61, 0xff, 0x65, 0x01, 0x6d, 0x00, 0x66, 0x04, 0x6e, 0xa7, 0x38, 0xef, 0x08, 0xc5, 0x5b, 0x03, 0x00, 0x18, 0x09, 0xbe, 0x58, 0x2f, 0x01, 0xbe, 0x59, 0x30, 0x01, 0x3a, 0x38, 0x9e, 0x58, 0x2f, 0x01, 0xbe, 0x58, 0x31, 0x01, 0x9e, 0x58, 0x30, 0x01, 0xbe, 0x58, 0x32, 0x01, 0x3a, 0x38, 0x9e, 0x58, 0x2f, 0x01, 0xc5, 0x13, 
+0x00, 0x09, 0x16, 0x38, 0x31, 0x01, 0x0b, 0x88, 0x9e, 0x58, 0x30, 0x01, 0x16, 0x38, 0x32, 0x01, 0x06, 0x88, 0x41, 0xa9, 0x50, 0xb0, 0x00, 0xac, 0x03, 0x90, 0x00, 0xaa, 0xd0, 0xb0, 0x83, 0xa8, 0x41, 0xab, 0x3a, 0x38, 0x00, 0x60, 0xbe, 0x58, 0x3d, 0x05, 0xbe, 0x58, 0x20, 0x05, 0xbe, 0x58, 0x50, 0x05, 0xbe, 0x58, 0x38, 0x05, 0xbe, 0x58, 0xa5, 0x04, 0xbe, 0x58, 0x1f, 0x05, 0x3a, 0x38, 0x01, 0x60, 0xbe, 0x58, 0xb1, 0x04, 0x00, 0x60, 0xbe, 0x58, 0xd2, 0x04, 0xbe, 0x58, 0xd4, 0x04, 0x3a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x01, 0xb8, 0x00, 0xb8, 0x1e, 0x58, 0x1e, 0x59, 0x1e, 0x5a, 0x1e, 0x5b, 0x1e, 0x5c, 0x1e, 0x5d, 0x1e, 0x5e, 0x1e, 0x5f, 0x01, 0xb8, 0x41, 0xab, 0x13, 0xb8, 0x14, 0xb8, 0x15, 0xb8, 0x41, 0xa9, 0x46, 0xb0, 0x00, 0xaa, 0xc6, 0xb0, 0x45, 0xb0, 0x03, 0x61, 0x01, 0x20, 0xac, 0x6c, 
+0x40, 0x09, 0x19, 0x48, 0x43, 0x8a, 0x47, 0xb0, 0x0e, 0x78, 0x48, 0xb0, 0x0f, 0x78, 0x9e, 0x58, 0x0d, 0x01, 0x18, 0x00, 0x08, 0x88, 0xbe, 0x58, 0x0a, 0x01, 0xbe, 0x58, 0x0b, 0x01, 0xbe, 0x58, 0x0c, 0x01, 0xbe, 0x58, 0x09, 0x01, 0x9e, 0x5f, 0x09, 0x01, 0x00, 0x62, 0x01, 0x66, 0xe6, 0x23, 0x09, 0x88, 0x40, 0x3b, 0x0e, 0x00, 0x40, 0x38, 0x0a, 0x01, 0x63, 0x59, 0x11, 0x01, 0x3b, 0x58, 0x01, 0x80, 0xe6, 0x2f, 0xbe, 0x5f, 0x09, 0x01, 0xc6, 0x5e, 0x19, 0x02, 0x42, 0x3b, 0x02, 0x00, 0xee, 0x81, 0xc9, 0xc9, 0x9e, 0x59, 0x0e, 0x01, 0x9e, 0x58, 0x0d, 0x01, 0x19, 0x00, 0xbe, 0x58, 0x0d, 0x01, 0x19, 0x48, 0x37, 0x80, 0x00, 0x62, 0x01, 0x66, 0xff, 0x60, 0xff, 0x68, 0x40, 0x3b, 0x0e, 0x00, 0x40, 0x3d, 0x0a, 0x01, 0xe6, 0x21, 0x01, 0x88, 0xa3, 0x58, 0x1b, 0x5b, 0xc6, 0x5e, 0x19, 0x02, 0x41, 0x0a, 
+0x80, 0x09, 0x42, 0x3b, 0x02, 0x00, 0xf1, 0x81, 0xbf, 0xc9, 0x26, 0x9e, 0x9e, 0x5a, 0x0f, 0x01, 0x9e, 0x5b, 0x0d, 0x01, 0x43, 0x40, 0x10, 0x3c, 0x10, 0x01, 0x9e, 0x5d, 0x13, 0x01, 0x19, 0x12, 0x81, 0x59, 0x47, 0x38, 0x95, 0x09, 0x47, 0xb0, 0x1b, 0x59, 0x19, 0x01, 0x1a, 0x38, 0x85, 0x01, 0x47, 0x38, 0x9c, 0x09, 0x48, 0xb0, 0x1b, 0x59, 0x19, 0x01, 0x1a, 0x38, 0xc9, 0xc9, 0x9e, 0x59, 0x0e, 0x01, 0x9e, 0x58, 0x0d, 0x01, 0x19, 0x00, 0xbe, 0x58, 0x0d, 0x01, 0x19, 0x48, 0x02, 0x80, 0xbf, 0xc9, 0x02, 0x9e, 0x01, 0x60, 0xc6, 0xb0, 0x41, 0xab, 0x90, 0xab, 0x98, 0xab, 0xa0, 0xab, 0x41, 0xab, 0x95, 0xb8, 0x94, 0xb8, 0x93, 0xb8, 0x81, 0xb8, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x5a, 0x38, 0x00, 0x60, 0x88, 0x74, 
+0xc0, 0x09, 0xbe, 0x58, 0x0d, 0x01, 0x9e, 0x58, 0x11, 0x01, 0x19, 0x00, 0x78, 0xaa, 0xbe, 0x58, 0x11, 0x01, 0x3a, 0x38, 0xcc, 0x60, 0x0c, 0x68, 0xc6, 0xb0, 0x00, 0x60, 0xc6, 0xb0, 0x40, 0xb0, 0x10, 0xa8, 0xc0, 0xb0, 0x10, 0xaa, 0xc0, 0xb0, 0x3a, 0x38, 0x55, 0x9f, 0x54, 0x9f, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x99, 0xab, 0x5a, 0x38, 0xa1, 0xab, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0xc1, 0xab, 0x5a, 0x38, 0xc9, 0xab, 0x5a, 0x38, 0xd3, 0xac, 0x1a, 0x92, 0xcb, 0xac, 0x02, 0x92, 0xcb, 0xa8, 0x16, 0x9e, 0x01, 0xb8, 0x00, 0xb8, 0x1e, 0x58, 0x1e, 0x59, 0x1e, 0x5a, 0x1e, 0x5b, 0x1e, 0x5c, 0x1e, 0x5d, 0x1e, 0x5e, 0x1e, 0x5f, 0xcb, 0xaa, 0x78, 0x69, 
+0x00, 0x0a, 0xd3, 0xa8, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0xd1, 0xab, 0x5a, 0x38, 0x5a, 0x38, 0x5a, 0x38, 0x01, 0xb8, 0x00, 0xb8, 0x1e, 0x58, 0x1e, 0x59, 0x1e, 0x5a, 0x1e, 0x5b, 0x1e, 0x5c, 0x1e, 0x5d, 0x1e, 0x5e, 0x1e, 0x5f, 0x41, 0xab, 0xa2, 0xac, 0x74, 0x92, 0x16, 0xa9, 0x16, 0xab, 0x1b, 0x70, 0x00, 0x3a, 0x1c, 0x00, 0x7a, 0xb1, 0x24, 0x39, 0xff, 0x00, 0x3b, 0x5a, 0x19, 0x00, 0x1b, 0x78, 0x06, 0x39, 0x01, 0x00, 0x38, 0x8a, 0x06, 0x39, 0x02, 0x00, 0x08, 0x88, 0x1d, 0x71, 0x24, 0x39, 0xf0, 0x00, 0x26, 0x39, 0x90, 0x00, 0x02, 0x88, 0x06, 0x63, 0x3c, 0x7b, 0x16, 0x39, 0x3c, 0x00, 0x10, 0x8a, 0xaa, 0xa8, 0xe9, 0xab, 0xff, 0x60, 0xf9, 0xb0, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0xb9, 0xba, 
+0x40, 0x0a, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x16, 0xa9, 0x5a, 0x38, 0xea, 0xf1, 0xa2, 0xac, 0x98, 0x3c, 0x01, 0x3a, 0xa2, 0xaa, 0xaa, 0xaa, 0x00, 0x60, 0x1b, 0x78, 0xe9, 0xab, 0x39, 0x60, 0x0c, 0x68, 0x19, 0x00, 0x09, 0x58, 0xf9, 0xb0, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x16, 0xa9, 0x5a, 0x38, 0x04, 0x60, 0x1c, 0x71, 0xba, 0xac, 0x0f, 0x90, 0x26, 0x3b, 0x96, 0x00, 0x02, 0x88, 0x06, 0x60, 0x14, 0x9e, 0x26, 0x3b, 0x97, 0x00, 0x02, 0x88, 0x06, 0x60, 0x0f, 0x9e, 0x26, 0x3b, 0x98, 0x00, 0x0c, 0x88, 0x06, 0x60, 0x0a, 0x9e, 0x26, 0x3b, 0x59, 0x00, 0x04, 0x88, 0x01, 0x60, 0x1b, 0x78, 0x0b, 0x60, 0x03, 0x9e, 0x00, 0x60, 0x1b, 0x78, 0x04, 0x60, 0x3c, 0x78, 0x56, 0x51, 
+0x80, 0x0a, 0xaa, 0xa8, 0xe9, 0xab, 0xff, 0x60, 0xf9, 0xb0, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x16, 0xa9, 0x5a, 0x38, 0x7b, 0xb0, 0x00, 0xac, 0xfd, 0x93, 0x7b, 0xb0, 0x10, 0xac, 0xfd, 0x93, 0x1b, 0x70, 0x27, 0x71, 0x19, 0x11, 0x01, 0x31, 0x5c, 0x8a, 0x81, 0xac, 0x04, 0x92, 0x00, 0x3a, 0x29, 0x00, 0x43, 0x59, 0x47, 0x9e, 0x06, 0x3a, 0x00, 0x00, 0x17, 0x8a, 0x06, 0x3a, 0x01, 0x00, 0x16, 0x8a, 0x3e, 0x72, 0x18, 0x32, 0x15, 0x88, 0x02, 0x3b, 0x02, 0x00, 0x9b, 0xac, 0x01, 0x90, 0x68, 0x5b, 0x70, 0x3a, 0x1a, 0x00, 0x43, 0x5b, 0x64, 0x39, 0xff, 0x00, 0x00, 0xac, 0x01, 0x90, 0x31, 0x9e, 0xfe, 0x5b, 0x64, 0x39, 0xff, 0x00, 0x2d, 0x9e, 0x28, 0x71, 0x2b, 0x9e, 0x29, 0x71, 0x29, 0x9e, 0x02, 0x3b, 0xa0, 0x60, 
+0xc0, 0x0a, 0x02, 0x00, 0x19, 0x8a, 0x19, 0x13, 0x9b, 0xac, 0x01, 0x90, 0x68, 0x5b, 0xa0, 0xac, 0x02, 0x90, 0x1a, 0x72, 0x02, 0x9e, 0x70, 0x3a, 0x1a, 0x00, 0x43, 0x5b, 0x64, 0x39, 0xff, 0x00, 0x00, 0xac, 0x06, 0x92, 0xa0, 0xac, 0x03, 0x90, 0x1a, 0x72, 0x7b, 0x02, 0x1a, 0x7a, 0x11, 0x9e, 0xfe, 0x5b, 0x64, 0x39, 0xff, 0x00, 0x0d, 0x9e, 0x2a, 0x71, 0xa0, 0xac, 0x0a, 0x90, 0x2a, 0x72, 0x19, 0x02, 0x56, 0x3a, 0x3e, 0x00, 0x04, 0x8a, 0x48, 0x77, 0x19, 0x07, 0x48, 0x7f, 0x01, 0x9e, 0x48, 0x7e, 0xf9, 0xb1, 0x19, 0x00, 0x1b, 0x78, 0xe9, 0xab, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x5a, 0x38, 0xb2, 0xaa, 0x92, 0xa8, 0xa2, 0xaa, 0x00, 0x60, 0x1b, 0x78, 0x39, 0x60, 0x0c, 0x68, 0x19, 0x00, 0x09, 0x58, 0x27, 0xed, 
+0x00, 0x0b, 0xf9, 0xb0, 0xe9, 0xab, 0x95, 0xc6, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x5a, 0x38, 0x01, 0xb8, 0x00, 0xb8, 0x1e, 0x58, 0x1e, 0x59, 0x1e, 0x5a, 0x1e, 0x5b, 0x1e, 0x5c, 0x1e, 0x5d, 0x1e, 0x5e, 0x1e, 0x5f, 0x41, 0xab, 0xa2, 0xac, 0x03, 0x90, 0xff, 0x65, 0xff, 0x6d, 0x01, 0x9e, 0x00, 0x65, 0x1b, 0x70, 0x16, 0x39, 0x27, 0x00, 0x53, 0x8a, 0x1b, 0x70, 0x81, 0xac, 0x04, 0x92, 0x00, 0x3a, 0x28, 0x00, 0x43, 0x59, 0x4e, 0x9e, 0x06, 0x3a, 0x00, 0x00, 0x17, 0x8a, 0x06, 0x3a, 0x01, 0x00, 0x16, 0x8a, 0x3e, 0x72, 0x18, 0x32, 0x15, 0x88, 0x02, 0x3b, 0x02, 0x00, 0x9b, 0xac, 0x01, 0x90, 0x68, 0x5b, 0x70, 0x3a, 0x1a, 0x00, 0x43, 0x5b, 0x64, 0x39, 0xff, 0x00, 0x00, 0xac, 0x01, 0x90, 0x38, 0x9e, 0xb2, 0x07, 
+0x40, 0x0b, 0xfe, 0x5b, 0x64, 0x39, 0xff, 0x00, 0x34, 0x9e, 0x28, 0x71, 0x32, 0x9e, 0x29, 0x71, 0x30, 0x9e, 0x02, 0x3b, 0x02, 0x00, 0x1d, 0x8a, 0x19, 0x13, 0x9b, 0xac, 0x01, 0x90, 0x68, 0x5b, 0xa0, 0xac, 0x02, 0x90, 0x1a, 0x72, 0x05, 0x9e, 0x1a, 0x72, 0x61, 0x58, 0x1b, 0x61, 0x01, 0x40, 0x40, 0x02, 0x43, 0x5b, 0x64, 0x39, 0xff, 0x00, 0x1b, 0x70, 0x00, 0xac, 0x06, 0x92, 0xa0, 0xac, 0x03, 0x90, 0x1a, 0x72, 0x19, 0x02, 0x1a, 0x7a, 0x14, 0x9e, 0xfe, 0x5b, 0x64, 0x39, 0xff, 0x00, 0x10, 0x9e, 0x2a, 0x71, 0xa0, 0xac, 0x0a, 0x90, 0x2a, 0x72, 0x19, 0x02, 0x56, 0x3a, 0x3e, 0x00, 0x04, 0x8a, 0x48, 0x77, 0x19, 0x07, 0x48, 0x7f, 0x01, 0x9e, 0x48, 0x7e, 0x02, 0x9e, 0xff, 0x61, 0x19, 0x10, 0x25, 0x21, 0xd5, 0xb1, 0x19, 0x00, 0x1b, 0x78, 0x52, 0xb2, 0x3a, 0xaa, 0xd2, 0xb2, 0xf1, 0xab, 0xd2, 0xe1, 
+0x80, 0x0b, 0x52, 0xb2, 0x02, 0xac, 0xfd, 0x91, 0x52, 0xb2, 0x12, 0xac, 0x01, 0x90, 0x98, 0x9f, 0xb2, 0xaa, 0x92, 0xa8, 0x00, 0x60, 0x1b, 0x78, 0x52, 0xb2, 0x3a, 0xaa, 0xd2, 0xb2, 0xf1, 0xab, 0xa2, 0xaa, 0x95, 0xc6, 0x54, 0xb1, 0x39, 0xac, 0xfd, 0x93, 0x80, 0x64, 0xd5, 0xb4, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x5a, 0x38, 0x01, 0xb8, 0x00, 0xb8, 0x1e, 0x58, 0x1e, 0x59, 0x1e, 0x5a, 0x1e, 0x5b, 0x1e, 0x5c, 0x1e, 0x5d, 0x1e, 0x5e, 0x1e, 0x5f, 0x41, 0xab, 0x55, 0xb0, 0x9e, 0x59, 0xfb, 0x00, 0x26, 0x59, 0x01, 0x30, 0x0f, 0x88, 0x52, 0xb2, 0x3a, 0xaa, 0xd2, 0xb2, 0xf9, 0xab, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x7b, 0x92, 
+0xc0, 0x0b, 0x5a, 0x38, 0x52, 0xb2, 0x3a, 0xac, 0xfd, 0x91, 0x1b, 0x70, 0x00, 0x3a, 0x1c, 0x00, 0x55, 0xb1, 0x3b, 0x5a, 0x19, 0x00, 0x1b, 0x78, 0x06, 0x39, 0x01, 0x00, 0x4e, 0x8a, 0x06, 0x39, 0x02, 0x00, 0x08, 0x88, 0x1d, 0x71, 0x24, 0x39, 0xf0, 0x00, 0x26, 0x39, 0x90, 0x00, 0x02, 0x88, 0x06, 0x63, 0x3c, 0x7b, 0x16, 0x39, 0x3c, 0x00, 0x06, 0x8a, 0xaa, 0xa8, 0x52, 0xb2, 0x3a, 0xaa, 0xd2, 0xb2, 0xf9, 0xab, 0xdf, 0x9f, 0x52, 0xb2, 0x3a, 0xaa, 0xd2, 0xb2, 0xea, 0xf1, 0x9e, 0x5c, 0x1c, 0x00, 0x86, 0x3c, 0x53, 0x00, 0x98, 0x3a, 0x01, 0x3a, 0x9e, 0x5c, 0x1c, 0x00, 0x86, 0x3c, 0x96, 0x00, 0x98, 0x3a, 0x01, 0x3a, 0x9e, 0x5c, 0x1c, 0x00, 0x86, 0x3c, 0x98, 0x00, 0x98, 0x3a, 0x01, 0x3a, 0x9e, 0x58, 0x3c, 0x05, 0x18, 0x30, 0x0b, 0x8a, 0x9e, 0x5c, 0x1c, 0x00, 0x9e, 0x58, 0x1d, 0x00, 0x2c, 0xf3, 
+0x00, 0x0c, 0x86, 0x3c, 0x54, 0x00, 0x04, 0x88, 0x06, 0x38, 0xc0, 0x00, 0x98, 0x3a, 0x01, 0x3a, 0xa2, 0xaa, 0xaa, 0xaa, 0x00, 0x60, 0x1b, 0x78, 0x54, 0xb1, 0x39, 0xac, 0xfd, 0x93, 0xf9, 0xab, 0x80, 0x64, 0xd5, 0xb4, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x5a, 0x38, 0x04, 0x60, 0x1c, 0x71, 0x26, 0x3a, 0x96, 0x00, 0x02, 0x88, 0x06, 0x60, 0x0e, 0x9e, 0x26, 0x3a, 0x97, 0x00, 0x02, 0x88, 0x06, 0x60, 0x09, 0x9e, 0x26, 0x3a, 0x98, 0x00, 0x02, 0x88, 0x06, 0x60, 0x04, 0x9e, 0x26, 0x3a, 0x59, 0x00, 0x01, 0x88, 0x0b, 0x60, 0x3c, 0x78, 0xaa, 0xa8, 0x52, 0xb2, 0x3a, 0xaa, 0xd2, 0xb2, 0x8a, 0x9f, 0x5a, 0x38, 0x5a, 0x38, 0x51, 0x00, 0x5a, 0x00, 0x5b, 0x00, 0x5c, 0x00, 0x5d, 0x00, 0x5e, 0x00, 0x5f, 0x00, 0xda, 0x62, 
+0x40, 0x0c, 0x60, 0x00, 0x61, 0x00, 0x62, 0x00, 0xda, 0xcc, 0xe1, 0xdf, 0x2b, 0xdf, 0x9e, 0x58, 0x43, 0x01, 0x00, 0x61, 0x19, 0x48, 0x08, 0x8a, 0x9e, 0x58, 0x4f, 0x05, 0xbe, 0x58, 0x23, 0x01, 0x02, 0x38, 0x64, 0x00, 0xbe, 0x58, 0x25, 0x01, 0x98, 0xe1, 0x3c, 0xcf, 0x9e, 0x58, 0xc0, 0x00, 0x00, 0xac, 0x23, 0x90, 0x59, 0xdc, 0xc0, 0xdb, 0x9e, 0x58, 0xc0, 0x00, 0x00, 0xac, 0x1d, 0x90, 0x9e, 0x58, 0xb1, 0x00, 0x02, 0x61, 0x19, 0x48, 0x02, 0x9a, 0xbe, 0x59, 0xb1, 0x00, 0xf8, 0xce, 0x27, 0xe0, 0x9c, 0xda, 0x8d, 0xda, 0x85, 0xde, 0x9e, 0x58, 0xdc, 0x00, 0x00, 0xac, 0x3c, 0x92, 0x6d, 0xd5, 0x9e, 0x58, 0xb1, 0x00, 0x18, 0x10, 0x08, 0x8a, 0x86, 0xce, 0x06, 0xac, 0x31, 0x90, 0x9e, 0x58, 0xc0, 0x00, 0x10, 0xac, 0x2d, 0x92, 0x2f, 0x9e, 0x00, 0x60, 0xbe, 0x58, 0xb1, 0x00, 0xbe, 0x58, 0x39, 0xf1, 
+0x80, 0x0c, 0x7e, 0x00, 0xbe, 0x58, 0x9a, 0x00, 0xbe, 0x58, 0x8c, 0x00, 0xbe, 0x58, 0xa8, 0x00, 0xbe, 0x58, 0x79, 0x00, 0xbe, 0x58, 0x87, 0x00, 0xbe, 0x58, 0x95, 0x00, 0xbe, 0x58, 0xa3, 0x00, 0xbe, 0x58, 0xc3, 0x00, 0xbe, 0x58, 0xc4, 0x00, 0xbe, 0x58, 0xc5, 0x00, 0xbe, 0x58, 0xc6, 0x00, 0xbe, 0x58, 0xbc, 0x00, 0xbe, 0x58, 0xbd, 0x00, 0x9e, 0x58, 0xc8, 0x00, 0x10, 0x38, 0xca, 0x00, 0x10, 0x38, 0xcc, 0x00, 0x10, 0x38, 0xce, 0x00, 0x18, 0x10, 0x01, 0x88, 0xd2, 0xce, 0xf8, 0xce, 0xcb, 0xcc, 0x59, 0xd2, 0x1a, 0x38, 0x1a, 0x38, 0xe1, 0xce, 0x9e, 0x58, 0xac, 0x04, 0x18, 0x30, 0x1a, 0x8a, 0xba, 0xac, 0x18, 0x90, 0x9e, 0x58, 0xfa, 0x00, 0x19, 0x00, 0x9e, 0x59, 0xac, 0x04, 0x19, 0x48, 0x0f, 0x96, 0x78, 0x60, 0x28, 0x78, 0x29, 0x78, 0x2a, 0x78, 0x2b, 0x78, 0xff, 0x60, 0x2c, 0x78, 0x05, 0xb4, 
+0xc0, 0x0c, 0x2d, 0x78, 0x2e, 0x78, 0x2f, 0x78, 0x30, 0x78, 0xa2, 0xa8, 0x93, 0xc6, 0x60, 0xd1, 0x00, 0x60, 0xbe, 0x58, 0xfa, 0x00, 0x3a, 0x38, 0x9e, 0x58, 0x37, 0x01, 0x19, 0x10, 0x06, 0x39, 0x00, 0x00, 0x01, 0x98, 0x00, 0x60, 0xbe, 0x58, 0x37, 0x01, 0x3a, 0x38, 0x9e, 0x58, 0x29, 0x05, 0xbe, 0x58, 0x37, 0x01, 0x3a, 0x38, 0x9e, 0x58, 0x1b, 0x05, 0x06, 0x39, 0x00, 0x00, 0xe6, 0x88, 0x00, 0x60, 0xbe, 0x58, 0xc6, 0x03, 0x01, 0x67, 0x9e, 0x58, 0x02, 0x04, 0x18, 0x30, 0xb7, 0x8a, 0x9e, 0x58, 0x12, 0x04, 0x07, 0x38, 0x20, 0x0d, 0x9f, 0xcd, 0x9e, 0x58, 0xc5, 0x03, 0x9e, 0x59, 0xc0, 0x03, 0x19, 0x48, 0x11, 0x9c, 0x9e, 0x58, 0xc4, 0x03, 0x19, 0x00, 0xbe, 0x58, 0xc4, 0x03, 0x9e, 0x59, 0xc2, 0x03, 0x19, 0x48, 0x19, 0x96, 0xbe, 0x59, 0xc4, 0x03, 0x9e, 0x58, 0xd1, 0x00, 0x07, 0x28, 0x9c, 0x78, 
+0x00, 0x0d, 0xbe, 0x58, 0xd1, 0x00, 0x11, 0x9e, 0x9e, 0x58, 0xc5, 0x03, 0x9e, 0x59, 0xc1, 0x03, 0x19, 0x48, 0x0b, 0x82, 0x00, 0x61, 0xbe, 0x59, 0xc4, 0x03, 0x9e, 0x58, 0xd1, 0x00, 0xe0, 0x5f, 0x07, 0x20, 0xbe, 0x58, 0xd1, 0x00, 0xe0, 0x5f, 0x00, 0x9e, 0x9e, 0x58, 0xc6, 0x03, 0x00, 0x38, 0xd4, 0x00, 0x9e, 0x59, 0xc4, 0x03, 0x3b, 0x58, 0x9e, 0x58, 0xc6, 0x03, 0x19, 0x00, 0xbe, 0x58, 0xc6, 0x03, 0xe6, 0x5f, 0x9e, 0x58, 0xd1, 0x00, 0x9e, 0x59, 0x4a, 0x01, 0x19, 0x11, 0x12, 0x88, 0x06, 0x39, 0x00, 0x00, 0x0f, 0x8a, 0x06, 0x39, 0x01, 0x00, 0x0c, 0x8a, 0x06, 0x39, 0x02, 0x00, 0x09, 0x8a, 0x06, 0x39, 0x04, 0x00, 0x06, 0x8a, 0x06, 0x39, 0x08, 0x00, 0x03, 0x8a, 0x00, 0x60, 0xbe, 0x58, 0xd1, 0x00, 0x9e, 0x58, 0xd2, 0x00, 0x18, 0x30, 0x11, 0x8a, 0x9e, 0x58, 0xd1, 0x00, 0x9e, 0x59, 0x9a, 0x78, 
+0x40, 0x0d, 0xd2, 0x00, 0x01, 0xac, 0x03, 0x92, 0x08, 0x58, 0x28, 0x59, 0xfb, 0x9f, 0x00, 0xac, 0x01, 0x92, 0x05, 0x9e, 0x9e, 0x58, 0xd2, 0x00, 0xbe, 0x58, 0xd1, 0x00, 0x1e, 0x9e, 0x9e, 0x58, 0xd1, 0x00, 0x18, 0x30, 0x1a, 0x8a, 0x9e, 0x58, 0xd1, 0x00, 0x00, 0x61, 0x01, 0x62, 0x00, 0x63, 0x00, 0xac, 0x0b, 0x90, 0x25, 0x64, 0x02, 0x6c, 0x90, 0x3c, 0x06, 0x04, 0x81, 0x04, 0x83, 0x5c, 0x9b, 0x48, 0x03, 0x80, 0x81, 0x5b, 0xbe, 0x5a, 0xd1, 0x00, 0x46, 0x5a, 0x08, 0x58, 0x19, 0x01, 0x9e, 0x5c, 0x12, 0x04, 0x3c, 0x48, 0x01, 0x98, 0xeb, 0x9f, 0x9e, 0x5a, 0xc0, 0x00, 0x9e, 0x58, 0xd1, 0x00, 0x9e, 0x59, 0xd2, 0x00, 0x19, 0x48, 0x02, 0x88, 0x12, 0xaa, 0x01, 0x9e, 0x12, 0xa8, 0xbe, 0x5a, 0xc0, 0x00, 0x9e, 0x58, 0xd1, 0x00, 0xbe, 0x58, 0xd3, 0x00, 0x18, 0x30, 0x0a, 0x8a, 0x9e, 0x58, 0xe9, 0x0f, 
+0x80, 0x0d, 0x37, 0x01, 0x18, 0x30, 0x0f, 0x8a, 0x9e, 0x58, 0xc0, 0x00, 0x18, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x09, 0x9e, 0x9e, 0x58, 0x42, 0x01, 0x18, 0x10, 0x05, 0x88, 0x9e, 0x58, 0xc0, 0x00, 0x18, 0xaa, 0xbe, 0x58, 0xc0, 0x00, 0x9e, 0x58, 0xc0, 0x00, 0x18, 0xac, 0x08, 0x90, 0x10, 0xaa, 0xbe, 0x58, 0xc0, 0x00, 0x00, 0x60, 0xbe, 0x58, 0xd1, 0x00, 0xbe, 0x58, 0xd2, 0x00, 0x3a, 0x38, 0x9e, 0x58, 0xc6, 0x03, 0x00, 0x38, 0x25, 0x02, 0x10, 0x38, 0x06, 0x04, 0x03, 0x58, 0xbe, 0x58, 0xc5, 0x03, 0x9e, 0x58, 0xc6, 0x03, 0x00, 0x38, 0x58, 0x04, 0x03, 0x58, 0xbe, 0x58, 0xc0, 0x03, 0x9e, 0x58, 0xc6, 0x03, 0x00, 0x38, 0x5e, 0x04, 0x03, 0x58, 0xbe, 0x58, 0xc1, 0x03, 0x9e, 0x58, 0xc6, 0x03, 0x00, 0x38, 0x64, 0x04, 0x03, 0x58, 0xbe, 0x58, 0xc2, 0x03, 0x9e, 0x58, 0xc6, 0x03, 0x00, 0x38, 0x86, 0xf8, 
+0xc0, 0x0d, 0xd4, 0x00, 0x03, 0x58, 0xbe, 0x58, 0xc4, 0x03, 0x3a, 0x38, 0x01, 0x61, 0x19, 0x48, 0x01, 0x8a, 0x3a, 0x38, 0x25, 0x60, 0x02, 0x68, 0x10, 0x38, 0x06, 0x04, 0x05, 0x5d, 0x03, 0x5e, 0x64, 0x60, 0xc0, 0x40, 0xc5, 0x04, 0x1c, 0x5c, 0x00, 0x62, 0x9e, 0x59, 0x1c, 0x05, 0x19, 0x48, 0x0f, 0x9c, 0x19, 0x02, 0x9e, 0x59, 0x1d, 0x05, 0x19, 0x48, 0x0a, 0x9c, 0x19, 0x02, 0x9e, 0x59, 0x1e, 0x05, 0x19, 0x48, 0x05, 0x9c, 0x19, 0x02, 0x64, 0x61, 0x19, 0x48, 0x01, 0x9c, 0x40, 0x9e, 0x00, 0x60, 0x58, 0x48, 0x07, 0x8a, 0x01, 0x60, 0x58, 0x48, 0x10, 0x8a, 0x02, 0x60, 0x58, 0x48, 0x1b, 0x8a, 0x28, 0x9e, 0x9e, 0x5b, 0x58, 0x04, 0x9b, 0x48, 0x32, 0x80, 0xd4, 0x70, 0x19, 0x00, 0xd4, 0x78, 0x00, 0x60, 0xd5, 0x78, 0xd6, 0x78, 0xd7, 0x78, 0x2f, 0x9e, 0x9e, 0x5b, 0x59, 0x04, 0x9b, 0x48, 0xc1, 0x95, 
+0x00, 0x0e, 0x26, 0x80, 0x9e, 0x58, 0xd5, 0x00, 0x19, 0x00, 0xbe, 0x58, 0xd5, 0x00, 0x00, 0x60, 0xd4, 0x78, 0xd6, 0x78, 0xd7, 0x78, 0x21, 0x9e, 0x9e, 0x5b, 0x5a, 0x04, 0x9b, 0x48, 0x18, 0x80, 0x9e, 0x58, 0xd6, 0x00, 0x19, 0x00, 0xbe, 0x58, 0xd6, 0x00, 0x00, 0x60, 0xd4, 0x78, 0xd5, 0x78, 0xd7, 0x78, 0x13, 0x9e, 0x9e, 0x5b, 0x5b, 0x04, 0x9b, 0x48, 0x0a, 0x80, 0x9e, 0x58, 0xd7, 0x00, 0x19, 0x00, 0xbe, 0x58, 0xd7, 0x00, 0x00, 0x60, 0xd4, 0x78, 0xd5, 0x78, 0xd6, 0x78, 0x05, 0x9e, 0x00, 0x60, 0xd4, 0x78, 0xd5, 0x78, 0xd6, 0x78, 0xd7, 0x78, 0x00, 0x60, 0xbe, 0x58, 0xc6, 0x03, 0x01, 0x67, 0x6f, 0x38, 0x57, 0x0e, 0xb6, 0xcd, 0x00, 0x61, 0x19, 0x48, 0x0a, 0x98, 0xbe, 0x59, 0xc4, 0x03, 0x9e, 0x58, 0xd1, 0x00, 0xe0, 0x5f, 0x07, 0x20, 0xbe, 0x58, 0xd1, 0x00, 0xe0, 0x5f, 0x0b, 0x9e, 0x57, 0x7d, 
+0x40, 0x0e, 0x9e, 0x59, 0xc2, 0x03, 0x19, 0x48, 0x07, 0x96, 0xbe, 0x59, 0xc4, 0x03, 0x9e, 0x58, 0xd1, 0x00, 0x07, 0x28, 0xbe, 0x58, 0xd1, 0x00, 0x9e, 0x58, 0xc6, 0x03, 0x00, 0x38, 0xd4, 0x00, 0x9e, 0x59, 0xc4, 0x03, 0x3b, 0x58, 0x9e, 0x58, 0xc6, 0x03, 0x19, 0x00, 0xbe, 0x58, 0xc6, 0x03, 0xe6, 0x5f, 0x98, 0x3f, 0x21, 0x0d, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5b, 0x9a, 0x00, 0x9e, 0x5c, 0xa8, 0x00, 0x01, 0x02, 0x19, 0x12, 0x0e, 0x80, 0x32, 0x62, 0x1a, 0x48, 0x1c, 0x9c, 0xb6, 0x62, 0x03, 0x6a, 0x1a, 0x48, 0x18, 0x82, 0x2c, 0x62, 0x3a, 0x48, 0x15, 0x9c, 0xd0, 0x62, 0x07, 0x6a, 0x3a, 0x48, 0x11, 0x82, 0x64, 0x02, 0x19, 0x12, 0x0f, 0x80, 0x32, 0x62, 0x7a, 0x48, 0x0b, 0x9c, 0xb6, 0x62, 0x03, 0x6a, 0x7a, 0x48, 0x07, 0x82, 0x2c, 0x62, 0x9a, 0x48, 0x04, 0x9c, 0xdf, 0xa7, 
+0x80, 0x0e, 0xd0, 0x62, 0x07, 0x6a, 0x9a, 0x48, 0x00, 0x82, 0xa1, 0xaa, 0x3a, 0x38, 0x00, 0x66, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x5a, 0xc7, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5b, 0xcb, 0x00, 0xb3, 0xd6, 0x9e, 0x5d, 0x6a, 0x04, 0x9d, 0x48, 0x19, 0x80, 0xc6, 0xce, 0x9e, 0x58, 0x9a, 0x00, 0x9e, 0x5a, 0xc9, 0x00, 0x9e, 0x59, 0xa8, 0x00, 0x9e, 0x5b, 0xcd, 0x00, 0xb3, 0xd6, 0x9e, 0x5d, 0x6a, 0x04, 0x9d, 0x48, 0x02, 0x80, 0xcc, 0xce, 0x21, 0x9e, 0x9e, 0x58, 0xc9, 0x00, 0xbe, 0x58, 0x9a, 0x00, 0x9e, 0x59, 0xcd, 0x00, 0xbe, 0x59, 0xa8, 0x00, 0x18, 0x9e, 0x9e, 0x58, 0x9a, 0x00, 0x9e, 0x5a, 0xc9, 0x00, 0x9e, 0x59, 0xa8, 0x00, 0x9e, 0x5b, 0xcd, 0x00, 0xb3, 0xd6, 0x9e, 0x5d, 0x6a, 0x04, 0x9d, 0x48, 0x0a, 0x80, 0xcc, 0xce, 0x9e, 0x58, 0xc7, 0x00, 0xbe, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x13, 0x51, 
+0xc0, 0x0e, 0xcb, 0x00, 0xbe, 0x59, 0x8c, 0x00, 0x01, 0x9e, 0x06, 0xa8, 0x3a, 0x38, 0x9e, 0x58, 0xcf, 0x00, 0x19, 0x00, 0xbe, 0x58, 0xcf, 0x00, 0x3a, 0x38, 0x9e, 0x58, 0xd0, 0x00, 0x19, 0x00, 0xbe, 0x58, 0xd0, 0x00, 0x3a, 0x38, 0x7a, 0x60, 0xdb, 0xce, 0x88, 0x60, 0xdb, 0xce, 0x96, 0x60, 0xdb, 0xce, 0xa4, 0x60, 0xdb, 0xce, 0x3a, 0x38, 0x00, 0x61, 0x6f, 0x38, 0xdf, 0x0e, 0x3d, 0x58, 0x1a, 0x38, 0x3a, 0x38, 0x79, 0x60, 0xf0, 0xce, 0x87, 0x60, 0xf0, 0xce, 0x95, 0x60, 0xf0, 0xce, 0xa3, 0x60, 0xf0, 0xce, 0xb1, 0x60, 0xf0, 0xce, 0x9e, 0x58, 0xd1, 0x00, 0xbe, 0x58, 0xd2, 0x00, 0x3a, 0x38, 0x1c, 0x00, 0x6f, 0x38, 0xf6, 0x0e, 0x02, 0x39, 0x01, 0x00, 0x23, 0x5a, 0x5f, 0x58, 0x3a, 0x38, 0x9e, 0x58, 0xb1, 0x00, 0x9e, 0x59, 0xb2, 0x00, 0x00, 0x62, 0x00, 0x63, 0x1a, 0x48, 0x04, 0x88, 0x42, 0xb2, 
+0x00, 0x0f, 0x3b, 0x48, 0x02, 0x88, 0x00, 0x64, 0x35, 0x9e, 0x01, 0x62, 0x01, 0x63, 0x1a, 0x48, 0x04, 0x88, 0x3b, 0x48, 0x02, 0x88, 0x01, 0x64, 0x2d, 0x9e, 0x02, 0x62, 0x02, 0x63, 0x1a, 0x48, 0x04, 0x88, 0x3b, 0x48, 0x02, 0x88, 0x02, 0x64, 0x25, 0x9e, 0x01, 0x62, 0x00, 0x63, 0x1a, 0x48, 0x04, 0x80, 0x3b, 0x48, 0x02, 0x88, 0x03, 0x64, 0x1d, 0x9e, 0x00, 0x62, 0x01, 0x63, 0x1a, 0x48, 0x09, 0x88, 0x3b, 0x48, 0x02, 0x88, 0x04, 0x64, 0x15, 0x9e, 0x02, 0x63, 0x3b, 0x48, 0x02, 0x88, 0x04, 0x64, 0x10, 0x9e, 0x02, 0x62, 0x01, 0x63, 0x1a, 0x48, 0x04, 0x88, 0x3b, 0x48, 0x02, 0x88, 0x05, 0x64, 0x08, 0x9e, 0x01, 0x62, 0x02, 0x63, 0x1a, 0x48, 0x06, 0x88, 0x3b, 0x48, 0x04, 0x88, 0x06, 0x64, 0x00, 0x9e, 0xbe, 0x5c, 0xc1, 0x00, 0x3a, 0x38, 0x9e, 0x59, 0xc0, 0x00, 0x39, 0xac, 0x16, 0x92, 0x05, 0xaa, 
+0x40, 0x0f, 0x01, 0xac, 0x07, 0x92, 0x9e, 0x59, 0x23, 0x01, 0x9e, 0x58, 0x40, 0x01, 0x19, 0x48, 0x08, 0x98, 0x3d, 0x9e, 0x9e, 0x59, 0x25, 0x01, 0x9e, 0x58, 0x40, 0x01, 0x19, 0x48, 0x37, 0x98, 0x06, 0x9e, 0x9e, 0x58, 0xc0, 0x00, 0x00, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x30, 0x9e, 0x9e, 0x58, 0xc0, 0x00, 0x00, 0xaa, 0xbe, 0x58, 0xc0, 0x00, 0xff, 0x60, 0x7f, 0x68, 0xbe, 0x58, 0x38, 0x01, 0xbe, 0x58, 0x39, 0x01, 0x00, 0x60, 0xbe, 0x58, 0x43, 0x01, 0xbe, 0x58, 0x44, 0x01, 0x9e, 0x58, 0x40, 0x01, 0x9e, 0x59, 0x25, 0x01, 0x19, 0x48, 0x1a, 0x98, 0x9e, 0x58, 0xd3, 0x00, 0x18, 0x10, 0x16, 0x88, 0x9e, 0x58, 0x42, 0x01, 0x01, 0x61, 0x19, 0x48, 0x04, 0x8a, 0x02, 0x61, 0x19, 0x48, 0x01, 0x8a, 0x04, 0x9e, 0x9e, 0x58, 0x27, 0x05, 0xbe, 0x58, 0x37, 0x01, 0x00, 0x60, 0xbe, 0x58, 0x42, 0x01, 0xdd, 0xf0, 
+0x80, 0x0f, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xaa, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xaa, 0x3a, 0x38, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5e, 0x9a, 0x00, 0x9e, 0x5f, 0xa8, 0x00, 0x9e, 0x5a, 0x7e, 0x00, 0xbe, 0x5a, 0xc7, 0x00, 0x9e, 0x5a, 0x8c, 0x00, 0xbe, 0x5a, 0xcb, 0x00, 0x9e, 0x5a, 0x9a, 0x00, 0xbe, 0x5a, 0xc9, 0x00, 0x9e, 0x5a, 0xa8, 0x00, 0xbe, 0x5a, 0xcd, 0x00, 0xa0, 0xd0, 0x5e, 0xd0, 0x7a, 0xd1, 0x3a, 0x38, 0x9e, 0x58, 0xbd, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x0d, 0x80, 0x9e, 0x5e, 0x9a, 0x00, 0x9e, 0x5f, 0xa8, 0x00, 0x9e, 0x5a, 0x9a, 0x00, 0xbe, 0x5a, 0xc9, 0x00, 0x9e, 0x5a, 0xa8, 0x00, 0xbe, 0x5a, 0xcd, 0x00, 0x08, 0x9e, 0x00, 0x66, 0x00, 0x67, 0x00, 0x62, 0xbe, 0x5a, 0xc9, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xcd, 0x00, 0x00, 0x60, 0x00, 0x61, 0x3f, 0x9b, 
+0xc0, 0x0f, 0x00, 0x62, 0xbe, 0x5a, 0xc7, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xcb, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xcf, 0x00, 0xa0, 0xd0, 0x5e, 0xd0, 0x7a, 0xd1, 0x3a, 0x38, 0x9e, 0x58, 0xbc, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x0d, 0x80, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5a, 0x7e, 0x00, 0xbe, 0x5a, 0xc7, 0x00, 0x9e, 0x5a, 0x8c, 0x00, 0xbe, 0x5a, 0xcb, 0x00, 0x08, 0x9e, 0x00, 0x60, 0x00, 0x61, 0x00, 0x62, 0xbe, 0x5a, 0xc7, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xcb, 0x00, 0x00, 0x66, 0x00, 0x67, 0x00, 0x62, 0xbe, 0x5a, 0xc9, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xcd, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xd0, 0x00, 0xa0, 0xd0, 0x5e, 0xd0, 0x7a, 0xd1, 0x3a, 0x38, 0x00, 0x60, 0x00, 0x61, 0x00, 0x66, 0x00, 0x67, 0x00, 0x62, 0xbe, 0x5a, 0xc7, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xbb, 0x25, 
+0x00, 0x10, 0xcb, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xc9, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xcd, 0x00, 0xbe, 0x5a, 0xcf, 0x00, 0xbe, 0x5a, 0xd0, 0x00, 0xa0, 0xd0, 0x5e, 0xd0, 0x7a, 0xd1, 0x3a, 0x38, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5e, 0xa1, 0x00, 0x9e, 0x5f, 0xaf, 0x00, 0xbe, 0x58, 0xc7, 0x00, 0xbe, 0x59, 0xcb, 0x00, 0xbe, 0x5e, 0xc9, 0x00, 0xbe, 0x5f, 0xcd, 0x00, 0xa0, 0xd0, 0x5e, 0xd0, 0x7a, 0xd1, 0x3a, 0x38, 0x9e, 0x58, 0x85, 0x00, 0x9e, 0x59, 0x93, 0x00, 0xc9, 0x76, 0xcd, 0x77, 0x9e, 0x5a, 0x85, 0x00, 0xbe, 0x5a, 0xc7, 0x00, 0x9e, 0x5a, 0x93, 0x00, 0xbe, 0x5a, 0xcb, 0x00, 0xc9, 0x72, 0xbe, 0x5a, 0xc9, 0x00, 0xcd, 0x72, 0xbe, 0x5a, 0xcd, 0x00, 0xa0, 0xd0, 0x5e, 0xd0, 0x7a, 0xd1, 0x3a, 0x38, 0x9e, 0x58, 0xc7, 0x00, 0x9e, 0x59, 0xcb, 0x00, 0x9e, 0x5e, 0x60, 0xe8, 
+0x40, 0x10, 0xc9, 0x00, 0x9e, 0x5f, 0xcd, 0x00, 0x9e, 0x5a, 0x85, 0x00, 0xbe, 0x5a, 0xc7, 0x00, 0x9e, 0x5a, 0x93, 0x00, 0xbe, 0x5a, 0xcb, 0x00, 0x9e, 0x5a, 0xa1, 0x00, 0xbe, 0x5a, 0xc9, 0x00, 0x9e, 0x5a, 0xaf, 0x00, 0xbe, 0x5a, 0xcd, 0x00, 0xa0, 0xd0, 0x5e, 0xd0, 0x7a, 0xd1, 0x3a, 0x38, 0x00, 0x60, 0x00, 0x61, 0x00, 0x66, 0x00, 0x67, 0xa0, 0xd0, 0x7a, 0xd1, 0x3a, 0x38, 0x1e, 0x58, 0x1e, 0x59, 0x1e, 0x5e, 0x1e, 0x5f, 0x9e, 0x5a, 0x2f, 0x05, 0x18, 0x12, 0x2d, 0x8a, 0x43, 0xd2, 0x9e, 0x5a, 0xc0, 0x03, 0x18, 0x12, 0x28, 0x8a, 0x9e, 0x5b, 0x3b, 0x01, 0x18, 0x13, 0x24, 0x8a, 0x43, 0x34, 0x1b, 0x14, 0x21, 0x88, 0x19, 0x12, 0x0d, 0x88, 0x9e, 0x58, 0xc7, 0x00, 0x9e, 0x59, 0xcb, 0x00, 0x9e, 0x5e, 0xca, 0x00, 0x9e, 0x5f, 0xce, 0x00, 0xbe, 0x5e, 0xc9, 0x00, 0xbe, 0x5f, 0xcd, 0x00, 0x53, 0x2f, 
+0x80, 0x10, 0x0c, 0x9e, 0x9e, 0x58, 0xc8, 0x00, 0x9e, 0x59, 0xcc, 0x00, 0x9e, 0x5e, 0xc9, 0x00, 0x9e, 0x5f, 0xcd, 0x00, 0xbe, 0x58, 0xc7, 0x00, 0xbe, 0x59, 0xcb, 0x00, 0x7a, 0xd1, 0xf4, 0x60, 0x01, 0x68, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x59, 0x3e, 0x58, 0xbe, 0x58, 0xc7, 0x00, 0xbe, 0x59, 0xcb, 0x00, 0xbe, 0x5e, 0xc9, 0x00, 0xbe, 0x5f, 0xcd, 0x00, 0x3a, 0x38, 0x1e, 0x58, 0x1e, 0x59, 0x1e, 0x5e, 0x1e, 0x5f, 0x00, 0x65, 0x9e, 0x5a, 0x2e, 0x05, 0x18, 0x12, 0x75, 0x8a, 0x9e, 0x5a, 0xc0, 0x00, 0x2a, 0xaa, 0xbe, 0x5a, 0xc0, 0x00, 0x9e, 0x5a, 0xd1, 0x00, 0x18, 0x12, 0x01, 0x8a, 0x05, 0xa8, 0x1e, 0x5d, 0x43, 0xd2, 0x3e, 0x5d, 0x9e, 0x5a, 0xc0, 0x03, 0x18, 0x12, 0x01, 0x8a, 0x0d, 0xa8, 0xa2, 0x3c, 0x00, 0x00, 0x60, 0x8a, 0x9e, 0x5a, 0x2e, 0x05, 0x80, 0xe6, 
+0xc0, 0x10, 0x01, 0x63, 0x5b, 0x48, 0x04, 0x8a, 0x02, 0x63, 0x5b, 0x48, 0x05, 0x8a, 0x57, 0x9e, 0xa2, 0x3c, 0x02, 0x00, 0x0e, 0x8a, 0x2c, 0x9e, 0xa2, 0x3c, 0x01, 0x00, 0x29, 0x8a, 0x00, 0x9e, 0x9e, 0x5a, 0xc0, 0x00, 0x2a, 0xaa, 0xbe, 0x5a, 0xc0, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xd1, 0x00, 0x46, 0x9e, 0x9e, 0x5a, 0xc0, 0x00, 0x2a, 0xaa, 0xbe, 0x5a, 0xc0, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xd1, 0x00, 0x9e, 0x5a, 0xd2, 0x00, 0x18, 0x12, 0x3a, 0x8a, 0x00, 0x60, 0x00, 0x61, 0x00, 0x66, 0x00, 0x67, 0xbe, 0x58, 0xc7, 0x00, 0xbe, 0x59, 0xcb, 0x00, 0xbe, 0x5e, 0xc9, 0x00, 0xbe, 0x5f, 0xcd, 0x00, 0x7a, 0xd1, 0xf4, 0x60, 0x01, 0x68, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x27, 0x9e, 0x9e, 0x5a, 0xc0, 0x00, 0x2a, 0xa8, 0xbe, 0x5a, 0xc0, 0x00, 0x9e, 0x5a, 0x3b, 0x01, 0x18, 0x12, 0x2b, 0x8a, 0xbb, 0x7c, 
+0x00, 0x11, 0x9e, 0x5a, 0xd1, 0x00, 0xbe, 0x5a, 0xca, 0x03, 0x00, 0x62, 0xbe, 0x5a, 0xd1, 0x00, 0x00, 0x60, 0x00, 0x61, 0x00, 0x66, 0x00, 0x67, 0xbe, 0x58, 0xc7, 0x00, 0xbe, 0x59, 0xcb, 0x00, 0xbe, 0x5e, 0xc9, 0x00, 0xbe, 0x5f, 0xcd, 0x00, 0x7a, 0xd1, 0xf4, 0x60, 0x01, 0x68, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x9e, 0x5a, 0xca, 0x03, 0xbe, 0x5a, 0xd1, 0x00, 0x0d, 0x9e, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x59, 0x3e, 0x58, 0xbe, 0x58, 0xc7, 0x00, 0xbe, 0x59, 0xcb, 0x00, 0xbe, 0x5e, 0xc9, 0x00, 0xbe, 0x5f, 0xcd, 0x00, 0x10, 0x9e, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x59, 0x3e, 0x58, 0x00, 0x60, 0x00, 0x61, 0x00, 0x66, 0x00, 0x67, 0xbe, 0x58, 0xc7, 0x00, 0xbe, 0x59, 0xcb, 0x00, 0xbe, 0x5e, 0xc9, 0x00, 0xbe, 0x5f, 0xcd, 0x00, 0x3a, 0x38, 0x9e, 0x5f, 0x9e, 0x04, 0x1e, 0x58, 0x9e, 0x58, 0xb9, 0xf0, 
+0x40, 0x11, 0x3b, 0x05, 0x18, 0x30, 0x1b, 0x8a, 0x28, 0x70, 0x06, 0x38, 0x5a, 0x00, 0x17, 0x88, 0x29, 0x70, 0x18, 0x30, 0x14, 0x88, 0x2a, 0x70, 0x18, 0x30, 0x11, 0x88, 0x2b, 0x70, 0x18, 0x30, 0x0e, 0x88, 0x2c, 0x70, 0x18, 0x30, 0x0b, 0x88, 0x2d, 0x70, 0x18, 0x30, 0x08, 0x88, 0x2e, 0x70, 0x18, 0x30, 0x05, 0x88, 0x2f, 0x70, 0x18, 0x30, 0x02, 0x88, 0x9e, 0x5f, 0x3b, 0x05, 0x3e, 0x58, 0x3a, 0x38, 0x9e, 0x5d, 0x53, 0x05, 0x19, 0x05, 0x3c, 0xd1, 0xc4, 0x66, 0x09, 0x6e, 0xa2, 0xac, 0x10, 0x90, 0x19, 0x16, 0xfc, 0x89, 0x19, 0x17, 0xf8, 0x89, 0x19, 0x15, 0x09, 0x8a, 0x95, 0xc6, 0x88, 0x66, 0x13, 0x6e, 0xa2, 0xac, 0x05, 0x90, 0x19, 0x16, 0xfc, 0x89, 0x93, 0xc6, 0xec, 0x9f, 0xa2, 0xaa, 0x95, 0xc6, 0x3a, 0x38, 0xe9, 0xac, 0x01, 0x90, 0x3a, 0x38, 0x1e, 0x5e, 0x1e, 0x5f, 0x01, 0x66, 0x11, 0x5c, 
+0x80, 0x11, 0x9e, 0x5f, 0xfd, 0x00, 0xdf, 0x48, 0x03, 0x88, 0x3e, 0x5f, 0x3e, 0x5e, 0x3a, 0x38, 0x3e, 0x5f, 0x3e, 0x5e, 0xba, 0xac, 0x01, 0x92, 0x3a, 0x38, 0x1e, 0x58, 0x9e, 0x58, 0xc0, 0x00, 0x20, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x3e, 0x58, 0xa2, 0xa8, 0xbe, 0x58, 0xc0, 0x03, 0x21, 0xd2, 0x41, 0x58, 0xbe, 0x59, 0xc0, 0x03, 0x2b, 0xd2, 0x41, 0x59, 0xbe, 0x5e, 0xc0, 0x03, 0x21, 0xd2, 0x41, 0x5e, 0xbe, 0x5f, 0xc0, 0x03, 0x2b, 0xd2, 0x41, 0x5f, 0x9e, 0x5a, 0x03, 0x04, 0x19, 0x32, 0x26, 0x88, 0x01, 0x02, 0x0e, 0x8a, 0x9e, 0x5b, 0xdb, 0x04, 0x03, 0xac, 0x04, 0x92, 0x9e, 0x5a, 0xd9, 0x04, 0x19, 0x12, 0x40, 0x10, 0x0b, 0xac, 0x04, 0x90, 0x9e, 0x5a, 0xda, 0x04, 0x19, 0x12, 0x41, 0x11, 0xc7, 0x02, 0x0e, 0x8a, 0x9e, 0x5b, 0xdb, 0x04, 0x03, 0xac, 0x04, 0x92, 0x9e, 0x5a, 0xd9, 0x04, 0x9e, 0x67, 
+0xc0, 0x11, 0x19, 0x12, 0x46, 0x16, 0x0b, 0xac, 0x04, 0x90, 0x9e, 0x5a, 0xda, 0x04, 0x19, 0x12, 0x47, 0x17, 0x01, 0x5a, 0xc1, 0x5b, 0x21, 0x58, 0xe1, 0x5e, 0x41, 0x59, 0x61, 0x5f, 0x5a, 0x62, 0xbe, 0x5a, 0x28, 0x00, 0x20, 0xdc, 0xbe, 0x5a, 0x29, 0x00, 0xbe, 0x5b, 0x2a, 0x00, 0xbe, 0x5c, 0x2b, 0x00, 0xc1, 0x58, 0xe1, 0x59, 0x20, 0xdc, 0xbe, 0x5a, 0x2c, 0x00, 0xbe, 0x5b, 0x2d, 0x00, 0xbe, 0x5c, 0x2e, 0x00, 0x43, 0xd2, 0x9e, 0x5a, 0xc0, 0x03, 0x18, 0x12, 0x01, 0x8a, 0xd5, 0xcc, 0x9e, 0x58, 0xd1, 0x00, 0x9e, 0x5a, 0x2e, 0x05, 0x18, 0x12, 0x07, 0x8a, 0x9e, 0x5a, 0xc0, 0x00, 0x2a, 0xac, 0x03, 0x90, 0x12, 0xac, 0x01, 0x92, 0x3a, 0x38, 0x06, 0x58, 0x06, 0x58, 0x15, 0x38, 0xc0, 0x03, 0xbe, 0x58, 0x2f, 0x00, 0x08, 0x60, 0x27, 0x78, 0x82, 0xac, 0x03, 0x92, 0x52, 0xb0, 0x20, 0xaa, 0xbc, 0x26, 
+0x00, 0x12, 0xd2, 0xb0, 0x00, 0x60, 0x1b, 0x78, 0x93, 0xc6, 0x60, 0xd1, 0x00, 0x60, 0xbe, 0x58, 0xfa, 0x00, 0x9e, 0x58, 0xc7, 0x00, 0xbe, 0x58, 0xc8, 0x00, 0x9e, 0x58, 0xcb, 0x00, 0xbe, 0x58, 0xcc, 0x00, 0x9e, 0x58, 0xc9, 0x00, 0xbe, 0x58, 0xca, 0x00, 0x9e, 0x58, 0xcd, 0x00, 0xbe, 0x58, 0xce, 0x00, 0x9e, 0x58, 0xc0, 0x03, 0xbe, 0x58, 0x3b, 0x01, 0x9e, 0x58, 0xd1, 0x00, 0xbe, 0x58, 0xd2, 0x00, 0x3a, 0x38, 0x9e, 0x5a, 0x05, 0x04, 0xbe, 0x5a, 0xc1, 0x03, 0x9e, 0x5a, 0xd9, 0x04, 0xbe, 0x5a, 0xc2, 0x03, 0x35, 0xd2, 0x3a, 0x38, 0x9e, 0x5a, 0x04, 0x04, 0xbe, 0x5a, 0xc1, 0x03, 0x9e, 0x5a, 0xda, 0x04, 0xbe, 0x5a, 0xc2, 0x03, 0x35, 0xd2, 0x3a, 0x38, 0x1e, 0x58, 0x1e, 0x59, 0x9e, 0x58, 0xc0, 0x03, 0x9e, 0x59, 0xc2, 0x03, 0x19, 0x40, 0x9e, 0x5a, 0xc1, 0x03, 0x3c, 0x5a, 0x01, 0x5a, 0xab, 0x22, 
+0x40, 0x12, 0x3e, 0x59, 0x3e, 0x58, 0x3a, 0x38, 0x00, 0x62, 0x9e, 0x58, 0xb1, 0x00, 0x18, 0x30, 0x9e, 0x58, 0xc7, 0x00, 0x9e, 0x59, 0xcb, 0x00, 0x01, 0x28, 0x01, 0x8a, 0x02, 0xa8, 0x9e, 0x58, 0xc9, 0x00, 0x9e, 0x59, 0xcd, 0x00, 0x01, 0x28, 0x02, 0x8a, 0x0a, 0xa8, 0x00, 0x9e, 0xbe, 0x5a, 0xc0, 0x03, 0x3a, 0x38, 0x9e, 0x58, 0xc0, 0x00, 0x20, 0xaa, 0xbe, 0x58, 0xc0, 0x00, 0x9e, 0x58, 0xc1, 0x00, 0x04, 0x61, 0x19, 0x48, 0x23, 0x88, 0x2a, 0xd3, 0x00, 0x62, 0xbe, 0x5a, 0xbc, 0x00, 0xbe, 0x5a, 0xbd, 0x00, 0x7a, 0x64, 0x88, 0x65, 0x85, 0x58, 0xa5, 0x59, 0x01, 0x00, 0x00, 0x62, 0x2f, 0x38, 0x75, 0x12, 0x1a, 0x48, 0x04, 0x8a, 0x85, 0x58, 0xa5, 0x59, 0x01, 0x00, 0x0d, 0x9e, 0x96, 0x64, 0xa4, 0x65, 0x85, 0x58, 0xa5, 0x59, 0x01, 0x00, 0x00, 0x62, 0x2f, 0x38, 0x83, 0x12, 0x1a, 0x48, 0xd8, 0xc7, 
+0x80, 0x12, 0x04, 0x8a, 0x85, 0x58, 0xa5, 0x59, 0x01, 0x00, 0xf7, 0xcf, 0x9c, 0x9e, 0x9e, 0x58, 0xc1, 0x00, 0x06, 0x61, 0x19, 0x48, 0x2e, 0x88, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x00, 0x64, 0x01, 0x05, 0xbc, 0x48, 0x13, 0x8a, 0xbe, 0x5c, 0xbd, 0x00, 0xbe, 0x5c, 0x95, 0x00, 0xbe, 0x5c, 0xa3, 0x00, 0xbe, 0x5c, 0xc5, 0x00, 0xbe, 0x5c, 0xc6, 0x00, 0x9e, 0x58, 0xbc, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x7f, 0x80, 0xe0, 0xd3, 0xcd, 0xcf, 0x7c, 0x9e, 0xbe, 0x5c, 0xbc, 0x00, 0xbe, 0x5c, 0x79, 0x00, 0xbe, 0x5c, 0x87, 0x00, 0xbe, 0x5c, 0xc3, 0x00, 0xbe, 0x5c, 0xc4, 0x00, 0x9e, 0x58, 0xbd, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x6c, 0x80, 0xe0, 0xd3, 0xa3, 0xcf, 0x69, 0x9e, 0x9e, 0x58, 0xc1, 0x00, 0x01, 0x61, 0x19, 0x48, 0x22, 0x88, 0x9e, 0x58, 0x7e, 0x00, 0xa3, 0x44, 
+0xc0, 0x12, 0x9e, 0x59, 0x8c, 0x00, 0x00, 0x64, 0x01, 0x05, 0xbc, 0x48, 0x0e, 0x8a, 0x00, 0x60, 0xbe, 0x58, 0xd0, 0x00, 0x9e, 0x58, 0xbc, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x10, 0x80, 0x1a, 0x38, 0xe0, 0xd3, 0x1a, 0x38, 0x87, 0xcf, 0x4e, 0x9e, 0x00, 0x60, 0xbe, 0x58, 0xcf, 0x00, 0x9e, 0x58, 0xbd, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x02, 0x80, 0xe0, 0xd3, 0x87, 0xcf, 0x42, 0x9e, 0x9e, 0x58, 0xc1, 0x00, 0x02, 0x61, 0x19, 0x48, 0x1b, 0x88, 0x9e, 0x58, 0xbc, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x0c, 0x80, 0x9e, 0x58, 0xbd, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x03, 0x80, 0xe0, 0xd3, 0x87, 0xcf, 0x0b, 0x9e, 0xe0, 0xd3, 0xcd, 0xcf, 0x08, 0x9e, 0x9e, 0x58, 0xbd, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x02, 0x80, 0xe0, 0xd3, 0xa3, 0xcf, 0x22, 0x9e, 0xb5, 0xdb, 
+0x00, 0x13, 0x9e, 0x58, 0xc1, 0x00, 0x00, 0x61, 0x19, 0x48, 0x17, 0x88, 0x00, 0x60, 0xbe, 0x58, 0x7e, 0x00, 0xbe, 0x58, 0x8c, 0x00, 0xbe, 0x58, 0x9a, 0x00, 0xbe, 0x58, 0xa8, 0x00, 0xbe, 0x58, 0xc3, 0x00, 0xbe, 0x58, 0xc4, 0x00, 0xbe, 0x58, 0xc5, 0x00, 0xbe, 0x58, 0xc6, 0x00, 0x9e, 0x58, 0xc0, 0x00, 0x10, 0xac, 0x08, 0x90, 0x87, 0xcf, 0x06, 0x9e, 0x9e, 0x58, 0xc1, 0x00, 0x05, 0x61, 0x19, 0x48, 0x01, 0x88, 0xc3, 0x9f, 0x9e, 0x58, 0xc0, 0x00, 0x20, 0xac, 0x03, 0x92, 0x10, 0xac, 0x01, 0x90, 0x57, 0xd0, 0x3a, 0x38, 0x00, 0x62, 0x1e, 0x5a, 0x7a, 0x64, 0x88, 0x65, 0x85, 0x58, 0xa5, 0x59, 0x01, 0x00, 0x00, 0x62, 0x2f, 0x38, 0x38, 0x13, 0x1a, 0x48, 0x3f, 0x8a, 0x85, 0x58, 0xa5, 0x59, 0x01, 0x00, 0x7a, 0x64, 0x88, 0x65, 0x85, 0x58, 0x83, 0x5a, 0xa5, 0x59, 0xa3, 0x5b, 0xb3, 0xd6, 0x7f, 0x45, 
+0x40, 0x13, 0x81, 0x5f, 0xbe, 0x5c, 0x3c, 0x01, 0x9e, 0x59, 0x4e, 0x04, 0xf9, 0x48, 0x04, 0x82, 0x9e, 0x59, 0x4f, 0x04, 0xf9, 0x48, 0x2a, 0x80, 0x7a, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdb, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xdd, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xdf, 0x03, 0x88, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdc, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xde, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xe0, 0x03, 0x9e, 0x58, 0x4e, 0x04, 0x9e, 0x59, 0x4f, 0x04, 0x01, 0x00, 0x08, 0x58, 0xbe, 0x58, 0xe2, 0x03, 0x9e, 0x58, 0x31, 0x05, 0xbe, 0x58, 0xe3, 0x03, 0xf5, 0xd4, 0x9e, 0x58, 0xe1, 0x03, 0x01, 0x61, 0x19, 0x48, 0x04, 0x8a, 0x00, 0x9e, 0x3e, 0x5a, 0x19, 0x02, 0x1e, 0x5a, 0x96, 0x64, 0xa4, 0x65, 0x85, 0x58, 0xa5, 0x59, 0x01, 0x00, 0x00, 0x62, 0x2f, 0x38, 0x81, 0x13, 0x1a, 0x48, 0x3f, 0x8a, 0x85, 0x58, 0x61, 0x60, 
+0x80, 0x13, 0xa5, 0x59, 0x01, 0x00, 0x96, 0x64, 0xa4, 0x65, 0x85, 0x58, 0x83, 0x5a, 0xa5, 0x59, 0xa3, 0x5b, 0xb3, 0xd6, 0x81, 0x5f, 0xbe, 0x5c, 0x3c, 0x01, 0x9e, 0x59, 0x4e, 0x04, 0xf9, 0x48, 0x04, 0x82, 0x9e, 0x59, 0x4f, 0x04, 0xf9, 0x48, 0x2a, 0x80, 0x96, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdb, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xdd, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xdf, 0x03, 0xa4, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdc, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xde, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xe0, 0x03, 0x9e, 0x58, 0x4e, 0x04, 0x9e, 0x59, 0x4f, 0x04, 0x01, 0x00, 0x08, 0x58, 0xbe, 0x58, 0xe2, 0x03, 0x9e, 0x58, 0x31, 0x05, 0xbe, 0x58, 0xe3, 0x03, 0xf5, 0xd4, 0x9e, 0x58, 0xe1, 0x03, 0x01, 0x61, 0x19, 0x48, 0x04, 0x8a, 0x00, 0x9e, 0x3e, 0x5a, 0x58, 0x02, 0x1e, 0x5a, 0x3e, 0x5a, 0x46, 0x39, 0x8c, 0x02, 
+0xc0, 0x13, 0x00, 0x00, 0x1d, 0x8a, 0x46, 0x39, 0x01, 0x00, 0x06, 0x8a, 0x46, 0x39, 0x10, 0x00, 0x0a, 0x8a, 0x46, 0x39, 0x11, 0x00, 0x0e, 0x8a, 0x23, 0xd0, 0xf4, 0x60, 0x01, 0x68, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x0d, 0x9e, 0x0f, 0xd0, 0xf4, 0x60, 0x01, 0x68, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x06, 0x9e, 0x3b, 0xd0, 0xf4, 0x60, 0x01, 0x68, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x3a, 0x38, 0x9e, 0x58, 0x79, 0x00, 0x9e, 0x5a, 0xc7, 0x00, 0x9e, 0x59, 0x87, 0x00, 0x9e, 0x5b, 0xcb, 0x00, 0x01, 0x06, 0xb5, 0x8a, 0x9e, 0x58, 0xbc, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0xaf, 0x80, 0x79, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdb, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xdd, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xdf, 0x03, 0x87, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdc, 0x03, 0x85, 0x58, 0xbe, 0x58, 0x9d, 0x8e, 
+0x00, 0x14, 0xde, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xe0, 0x03, 0x9e, 0x58, 0x7b, 0x04, 0xbe, 0x58, 0xe2, 0x03, 0x9e, 0x58, 0x2d, 0x05, 0xbe, 0x58, 0xe3, 0x03, 0xf5, 0xd4, 0x9e, 0x58, 0xe1, 0x03, 0x01, 0x61, 0x19, 0x48, 0x01, 0x8a, 0x8c, 0x9e, 0x9e, 0x58, 0x95, 0x00, 0x9e, 0x5a, 0xc9, 0x00, 0x9e, 0x59, 0xa3, 0x00, 0x9e, 0x5b, 0xcd, 0x00, 0x01, 0x06, 0x60, 0x8a, 0x9e, 0x58, 0xbd, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x5a, 0x80, 0x95, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdb, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xdd, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xdf, 0x03, 0xa3, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdc, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xde, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xe0, 0x03, 0x9e, 0x58, 0x7b, 0x04, 0xbe, 0x58, 0xe2, 0x03, 0x9e, 0x58, 0x2d, 0x05, 0xbe, 0x58, 0xe3, 0x03, 0xf5, 0xd4, 0xae, 0x10, 
+0x40, 0x14, 0x9e, 0x58, 0xe1, 0x03, 0x01, 0x61, 0x19, 0x48, 0x01, 0x8a, 0x37, 0x9e, 0xf7, 0xcf, 0xf4, 0x60, 0x01, 0x68, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x9e, 0x58, 0x79, 0x00, 0x9e, 0x59, 0x87, 0x00, 0xbe, 0x58, 0x7e, 0x00, 0xbe, 0x58, 0x7f, 0x00, 0xbe, 0x58, 0x80, 0x00, 0xbe, 0x58, 0xc3, 0x00, 0x7a, 0x62, 0x1b, 0x5a, 0xbe, 0x59, 0x8c, 0x00, 0xbe, 0x59, 0x8d, 0x00, 0xbe, 0x59, 0x8e, 0x00, 0xbe, 0x59, 0xc4, 0x00, 0x88, 0x62, 0x3b, 0x5a, 0x9e, 0x58, 0x95, 0x00, 0x9e, 0x59, 0xa3, 0x00, 0xbe, 0x58, 0x9a, 0x00, 0xbe, 0x58, 0x9b, 0x00, 0xbe, 0x58, 0x9c, 0x00, 0xbe, 0x58, 0xc5, 0x00, 0x96, 0x62, 0x1b, 0x5a, 0xbe, 0x59, 0xa8, 0x00, 0xbe, 0x59, 0xa9, 0x00, 0xbe, 0x59, 0xaa, 0x00, 0xbe, 0x59, 0xc6, 0x00, 0xa4, 0x62, 0x3b, 0x5a, 0x76, 0x9e, 0xa3, 0xcf, 0xf4, 0x60, 0x01, 0x68, 0xb3, 0x3d, 
+0x80, 0x14, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x00, 0x62, 0xbe, 0x5a, 0xcf, 0x00, 0x9e, 0x58, 0x79, 0x00, 0x9e, 0x59, 0x87, 0x00, 0xbe, 0x58, 0x7e, 0x00, 0xbe, 0x58, 0x7f, 0x00, 0xbe, 0x58, 0x80, 0x00, 0xbe, 0x58, 0xc3, 0x00, 0x7a, 0x62, 0x1b, 0x5a, 0xbe, 0x59, 0x8c, 0x00, 0xbe, 0x59, 0x8d, 0x00, 0xbe, 0x59, 0x8e, 0x00, 0xbe, 0x59, 0xc4, 0x00, 0x88, 0x62, 0x3b, 0x5a, 0x54, 0x9e, 0x9e, 0x58, 0x95, 0x00, 0x9e, 0x5a, 0xc9, 0x00, 0x9e, 0x59, 0xa3, 0x00, 0x9e, 0x5b, 0xcd, 0x00, 0x01, 0x06, 0x4a, 0x8a, 0x9e, 0x58, 0xbd, 0x00, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x44, 0x80, 0x95, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdb, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xdd, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xdf, 0x03, 0xa3, 0x64, 0x85, 0x58, 0xbe, 0x58, 0xdc, 0x03, 0x85, 0x58, 0xbe, 0x58, 0xde, 0x03, 0xc6, 0x6d, 
+0xc0, 0x14, 0x83, 0x58, 0xbe, 0x58, 0xe0, 0x03, 0x9e, 0x58, 0x7b, 0x04, 0xbe, 0x58, 0xe2, 0x03, 0x9e, 0x58, 0x2d, 0x05, 0xbe, 0x58, 0xe3, 0x03, 0xf5, 0xd4, 0x9e, 0x58, 0xe1, 0x03, 0x01, 0x61, 0x19, 0x48, 0x01, 0x8a, 0x21, 0x9e, 0xcd, 0xcf, 0xf4, 0x60, 0x01, 0x68, 0x9e, 0x59, 0x32, 0x05, 0x5e, 0xd5, 0x00, 0x62, 0xbe, 0x5a, 0xd0, 0x00, 0x9e, 0x58, 0x95, 0x00, 0x9e, 0x59, 0xa3, 0x00, 0xbe, 0x58, 0x9a, 0x00, 0xbe, 0x58, 0x9b, 0x00, 0xbe, 0x58, 0x9c, 0x00, 0xbe, 0x58, 0xc5, 0x00, 0x96, 0x62, 0x1b, 0x5a, 0xbe, 0x59, 0xa8, 0x00, 0xbe, 0x59, 0xa9, 0x00, 0xbe, 0x59, 0xaa, 0x00, 0xbe, 0x59, 0xc6, 0x00, 0xa4, 0x62, 0x3b, 0x5a, 0x1a, 0x38, 0x3a, 0x38, 0x00, 0x60, 0xbe, 0x58, 0xe1, 0x03, 0x9e, 0x58, 0xdb, 0x03, 0x9e, 0x5a, 0xdd, 0x03, 0x9e, 0x59, 0xdc, 0x03, 0x9e, 0x5b, 0xde, 0x03, 0x5c, 0x6c, 
+0x00, 0x15, 0xb3, 0xd6, 0x81, 0x5f, 0xbe, 0x5c, 0x3c, 0x01, 0x9e, 0x59, 0xe2, 0x03, 0xf9, 0x48, 0x55, 0x80, 0x9e, 0x58, 0xdd, 0x03, 0x9e, 0x5a, 0xdf, 0x03, 0x9e, 0x59, 0xde, 0x03, 0x9e, 0x5b, 0xe0, 0x03, 0xb3, 0xd6, 0x81, 0x5e, 0xbe, 0x5c, 0x3d, 0x01, 0x18, 0x16, 0x01, 0x88, 0x01, 0x66, 0x0a, 0x62, 0xfa, 0x40, 0x3c, 0x5e, 0x9e, 0x59, 0xe3, 0x03, 0x19, 0x48, 0x38, 0x82, 0x00, 0x63, 0x9e, 0x58, 0xdb, 0x03, 0x9e, 0x59, 0xdd, 0x03, 0x9e, 0x5a, 0xdf, 0x03, 0x01, 0x16, 0x22, 0x17, 0xdf, 0x40, 0x79, 0xac, 0x01, 0x90, 0x03, 0xa8, 0x9e, 0x58, 0xdc, 0x03, 0x9e, 0x59, 0xde, 0x03, 0x9e, 0x5a, 0xe0, 0x03, 0x01, 0x16, 0x22, 0x17, 0xdf, 0x40, 0x79, 0xac, 0x01, 0x90, 0x0b, 0xa8, 0x62, 0x38, 0x03, 0x00, 0x1c, 0x8a, 0x62, 0x38, 0x00, 0x00, 0x1d, 0x8a, 0x9e, 0x5e, 0x3c, 0x01, 0x9e, 0x5f, 0xac, 0x85, 
+0x40, 0x15, 0x3d, 0x01, 0xdf, 0x48, 0x01, 0x80, 0xc1, 0x5f, 0x9e, 0x58, 0xdb, 0x03, 0x9e, 0x5a, 0xdf, 0x03, 0x9e, 0x59, 0xdc, 0x03, 0x9e, 0x5b, 0xe0, 0x03, 0xb3, 0xd6, 0x81, 0x58, 0x0a, 0x62, 0x1a, 0x40, 0x3c, 0x5f, 0x9e, 0x59, 0x30, 0x05, 0x19, 0x48, 0x01, 0x96, 0x04, 0x9e, 0x01, 0x60, 0xbe, 0x58, 0xe1, 0x03, 0x03, 0x9e, 0x02, 0x60, 0xbe, 0x58, 0xe1, 0x03, 0x3a, 0x38, 0x01, 0x5a, 0x41, 0x58, 0x19, 0x10, 0xfe, 0x89, 0x19, 0x11, 0xfb, 0x89, 0x3a, 0x38, 0xff, 0x60, 0x03, 0x61, 0x5e, 0xd5, 0x3a, 0x38, 0xff, 0x60, 0x03, 0x61, 0x5e, 0xd5, 0x3a, 0x38, 0x00, 0x61, 0xbe, 0x59, 0x7e, 0x00, 0xbe, 0x59, 0x8c, 0x00, 0xbe, 0x59, 0x9a, 0x00, 0xbe, 0x59, 0xa8, 0x00, 0xbe, 0x59, 0xc2, 0x00, 0x9e, 0x5e, 0x6e, 0x00, 0x9e, 0x5f, 0x72, 0x00, 0x80, 0x63, 0x00, 0x64, 0x41, 0xda, 0x01, 0x5d, 0x87, 0xb3, 
+0x80, 0x15, 0x38, 0x67, 0x03, 0x6f, 0xc7, 0x16, 0xc3, 0x40, 0x05, 0x05, 0x18, 0x15, 0x01, 0x98, 0x01, 0x65, 0xbe, 0x5d, 0x8c, 0x00, 0x75, 0x66, 0x76, 0x67, 0x9e, 0x5b, 0x05, 0x04, 0x00, 0x64, 0x41, 0xda, 0x01, 0x5d, 0x9e, 0x5e, 0x8c, 0x00, 0x1d, 0xd7, 0xbe, 0x5d, 0x7e, 0x00, 0x7e, 0x60, 0xbe, 0x58, 0xc0, 0x03, 0x8c, 0x60, 0xbe, 0x58, 0xc1, 0x03, 0x75, 0x60, 0xbe, 0x58, 0xc2, 0x03, 0x76, 0x60, 0xbe, 0x58, 0xc3, 0x03, 0xc8, 0xde, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5a, 0xc3, 0x00, 0x9e, 0x5b, 0xc4, 0x00, 0xb3, 0xd6, 0xbe, 0x5c, 0xc0, 0x03, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5a, 0xc5, 0x00, 0x9e, 0x5b, 0xc6, 0x00, 0x43, 0x05, 0x18, 0x35, 0x0b, 0x8a, 0xb3, 0xd6, 0xbe, 0x5c, 0xc1, 0x03, 0x9e, 0x58, 0xc0, 0x03, 0x1c, 0x48, 0x04, 0x9c, 0x19, 0x32, 
+0xc0, 0x15, 0x02, 0x60, 0xbe, 0x58, 0xc2, 0x00, 0x03, 0x9e, 0x01, 0x60, 0xbe, 0x58, 0xc2, 0x00, 0x9e, 0x58, 0xb1, 0x00, 0x02, 0x61, 0x19, 0x48, 0x01, 0x82, 0x53, 0x9e, 0x9e, 0x5e, 0x6f, 0x00, 0x9e, 0x5f, 0x73, 0x00, 0x80, 0x63, 0x00, 0x64, 0x41, 0xda, 0x01, 0x5d, 0x38, 0x67, 0x03, 0x6f, 0xc7, 0x16, 0xc3, 0x40, 0x05, 0x05, 0x18, 0x15, 0x01, 0x98, 0x01, 0x65, 0xbe, 0x5d, 0xa8, 0x00, 0x77, 0x66, 0x78, 0x67, 0x9e, 0x5b, 0x05, 0x04, 0x00, 0x64, 0x41, 0xda, 0x01, 0x5d, 0x9e, 0x5e, 0xa8, 0x00, 0x1d, 0xd7, 0xbe, 0x5d, 0x9a, 0x00, 0x9a, 0x60, 0xbe, 0x58, 0xc0, 0x03, 0xa8, 0x60, 0xbe, 0x58, 0xc1, 0x03, 0x77, 0x60, 0xbe, 0x58, 0xc2, 0x03, 0x78, 0x60, 0xbe, 0x58, 0xc3, 0x03, 0xc8, 0xde, 0x9e, 0x58, 0x9a, 0x00, 0x9e, 0x59, 0xa8, 0x00, 0x9e, 0x5a, 0xc3, 0x00, 0x9e, 0x5b, 0xc4, 0x00, 0x75, 0x46, 
+0x00, 0x16, 0xb3, 0xd6, 0xbe, 0x5c, 0xc2, 0x03, 0x9e, 0x58, 0x9a, 0x00, 0x9e, 0x59, 0xa8, 0x00, 0x9e, 0x5a, 0xc5, 0x00, 0x9e, 0x5b, 0xc6, 0x00, 0xb3, 0xd6, 0xbe, 0x5c, 0xc3, 0x03, 0x9e, 0x58, 0xc2, 0x03, 0x98, 0x48, 0x07, 0x9c, 0x20, 0x60, 0x9e, 0x59, 0xc2, 0x00, 0x01, 0x00, 0xbe, 0x58, 0xc2, 0x00, 0x07, 0x9e, 0x10, 0x60, 0x9e, 0x59, 0xc2, 0x00, 0x01, 0x00, 0xbe, 0x58, 0xc2, 0x00, 0x1a, 0x38, 0x9e, 0x58, 0xc2, 0x00, 0x02, 0x61, 0x19, 0x48, 0x02, 0x88, 0xa2, 0xd6, 0x1a, 0x9e, 0x12, 0x61, 0x19, 0x48, 0x08, 0x88, 0x9e, 0x58, 0xc1, 0x03, 0x9e, 0x59, 0xc3, 0x03, 0x38, 0x48, 0x11, 0x9c, 0xa2, 0xd6, 0x0f, 0x9e, 0x21, 0x61, 0x19, 0x48, 0x08, 0x88, 0x9e, 0x58, 0xc0, 0x03, 0x9e, 0x59, 0xc2, 0x03, 0x19, 0x48, 0x06, 0x9c, 0xa2, 0xd6, 0x04, 0x9e, 0x22, 0x61, 0x19, 0x48, 0x01, 0x88, 0xe5, 0xe6, 
+0x40, 0x16, 0xa2, 0xd6, 0x9e, 0x58, 0xe1, 0x04, 0x18, 0x00, 0x12, 0x8a, 0x9e, 0x5e, 0x7e, 0x00, 0x9e, 0x5f, 0x8c, 0x00, 0xc7, 0x00, 0x03, 0x8a, 0xc5, 0xdc, 0xbe, 0x5e, 0x7e, 0x00, 0x9e, 0x5e, 0x9a, 0x00, 0x9e, 0x5f, 0xa8, 0x00, 0xc7, 0x00, 0x03, 0x8a, 0xc5, 0xdc, 0xbe, 0x5e, 0x9a, 0x00, 0x9e, 0x5c, 0x7e, 0x00, 0x9e, 0x5d, 0x8c, 0x00, 0x85, 0x00, 0x07, 0x8a, 0x38, 0x61, 0x01, 0x69, 0x92, 0xd7, 0xbe, 0x5c, 0x7e, 0x00, 0xbe, 0x5d, 0x8c, 0x00, 0x9e, 0x5c, 0x9a, 0x00, 0x9e, 0x5d, 0xa8, 0x00, 0x85, 0x00, 0x07, 0x8a, 0x39, 0x61, 0x01, 0x69, 0x92, 0xd7, 0xbe, 0x5c, 0x9a, 0x00, 0xbe, 0x5d, 0xa8, 0x00, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5a, 0x9a, 0x00, 0x9e, 0x5b, 0xa8, 0x00, 0xbe, 0x58, 0xc3, 0x00, 0xbe, 0x59, 0xc4, 0x00, 0xbe, 0x5a, 0xc5, 0x00, 0xbe, 0x5b, 0xc0, 0xfd, 
+0x80, 0x16, 0xc6, 0x00, 0xbe, 0x58, 0x79, 0x00, 0xbe, 0x59, 0x87, 0x00, 0xbe, 0x5a, 0x95, 0x00, 0xbe, 0x5b, 0xa3, 0x00, 0x9e, 0x5c, 0xb1, 0x00, 0x18, 0x34, 0x14, 0x8a, 0x01, 0x00, 0x04, 0x88, 0x00, 0x60, 0xbe, 0x58, 0xbc, 0x00, 0x02, 0x9e, 0xbf, 0xd6, 0x03, 0xd8, 0x9e, 0x5a, 0x9a, 0x00, 0x9e, 0x5b, 0xa8, 0x00, 0x43, 0x02, 0x04, 0x88, 0x00, 0x60, 0xbe, 0x58, 0xbd, 0x00, 0x02, 0x9e, 0xee, 0xd6, 0x03, 0xd8, 0x3a, 0x38, 0x9e, 0x58, 0x7e, 0x00, 0x9e, 0x59, 0x8c, 0x00, 0x9e, 0x5a, 0x9a, 0x00, 0x9e, 0x5b, 0xa8, 0x00, 0xbe, 0x58, 0x9a, 0x00, 0xbe, 0x59, 0xa8, 0x00, 0xbe, 0x5a, 0x7e, 0x00, 0xbe, 0x5b, 0x8c, 0x00, 0x3a, 0x38, 0x1a, 0x48, 0x02, 0x82, 0x40, 0x12, 0x01, 0x9e, 0x02, 0x12, 0x3b, 0x48, 0x02, 0x82, 0x61, 0x13, 0x01, 0x9e, 0x23, 0x13, 0x43, 0x04, 0x3a, 0x38, 0x9e, 0x58, 0x1f, 0x6b, 
+0xc0, 0x16, 0xbc, 0x00, 0xbe, 0x58, 0xc0, 0x03, 0x7e, 0x60, 0xbe, 0x58, 0xc1, 0x03, 0x8c, 0x60, 0xbe, 0x58, 0xc2, 0x03, 0x79, 0x60, 0xbe, 0x58, 0xc3, 0x03, 0x87, 0x60, 0xbe, 0x58, 0xc4, 0x03, 0x83, 0x60, 0xbe, 0x58, 0xc5, 0x03, 0x91, 0x60, 0xbe, 0x58, 0xc6, 0x03, 0x84, 0x60, 0xbe, 0x58, 0xc7, 0x03, 0x92, 0x60, 0xbe, 0x58, 0xc8, 0x03, 0x85, 0x60, 0xbe, 0x58, 0xc9, 0x03, 0x93, 0x60, 0xbe, 0x58, 0xca, 0x03, 0xbc, 0x60, 0xbe, 0x58, 0xcb, 0x03, 0xbe, 0x60, 0xbe, 0x58, 0xcc, 0x03, 0x86, 0x60, 0xbe, 0x58, 0xcd, 0x03, 0x94, 0x60, 0xbe, 0x58, 0xce, 0x03, 0x3a, 0x38, 0x9e, 0x58, 0xbd, 0x00, 0xbe, 0x58, 0xc0, 0x03, 0x9a, 0x60, 0xbe, 0x58, 0xc1, 0x03, 0xa8, 0x60, 0xbe, 0x58, 0xc2, 0x03, 0x95, 0x60, 0xbe, 0x58, 0xc3, 0x03, 0xa3, 0x60, 0xbe, 0x58, 0xc4, 0x03, 0x9f, 0x60, 0xbe, 0x58, 0x13, 0x67, 
+0x00, 0x17, 0xc5, 0x03, 0xad, 0x60, 0xbe, 0x58, 0xc6, 0x03, 0xa0, 0x60, 0xbe, 0x58, 0xc7, 0x03, 0xae, 0x60, 0xbe, 0x58, 0xc8, 0x03, 0xa1, 0x60, 0xbe, 0x58, 0xc9, 0x03, 0xaf, 0x60, 0xbe, 0x58, 0xca, 0x03, 0xbd, 0x60, 0xbe, 0x58, 0xcb, 0x03, 0xbf, 0x60, 0xbe, 0x58, 0xcc, 0x03, 0xa2, 0x60, 0xbe, 0x58, 0xcd, 0x03, 0xb0, 0x60, 0xbe, 0x58, 0xce, 0x03, 0x3a, 0x38, 0xd2, 0x3e, 0x3c, 0x04, 0x12, 0x3d, 0x40, 0x04, 0x3c, 0x80, 0x9e, 0x59, 0x44, 0x04, 0x32, 0x39, 0x43, 0x04, 0x00, 0x60, 0x9e, 0x5a, 0x3d, 0x04, 0x52, 0x3a, 0x3c, 0x04, 0x3c, 0x5a, 0x1e, 0x40, 0x9e, 0x5a, 0x43, 0x04, 0x52, 0x3a, 0x40, 0x04, 0x22, 0x04, 0x9e, 0x5a, 0x3f, 0x04, 0x52, 0x3a, 0x10, 0x04, 0xba, 0x40, 0x3c, 0x5c, 0x10, 0x3d, 0x10, 0x04, 0x9e, 0x59, 0x05, 0x04, 0x19, 0x11, 0x3d, 0x48, 0x02, 0x82, 0x21, 0x5d, 0x9c, 0xe4, 
+0x40, 0x17, 0x50, 0x9e, 0x9e, 0x5a, 0x05, 0x04, 0x9e, 0x59, 0xb4, 0x04, 0x41, 0x12, 0xba, 0x48, 0x49, 0x9a, 0xb2, 0x3d, 0x10, 0x04, 0x32, 0x3e, 0x10, 0x04, 0xa6, 0x05, 0x9e, 0x5a, 0xb5, 0x04, 0x40, 0x3a, 0x64, 0x00, 0xba, 0x40, 0x64, 0x63, 0x3c, 0x5b, 0x10, 0x3d, 0x10, 0x04, 0xa6, 0x15, 0x9e, 0x5a, 0x05, 0x04, 0x19, 0x12, 0xba, 0x48, 0x35, 0x9a, 0x41, 0x5d, 0x33, 0x9e, 0x9e, 0x59, 0x41, 0x04, 0x32, 0x39, 0x42, 0x04, 0x00, 0x60, 0x9e, 0x5a, 0x3d, 0x04, 0x52, 0x3a, 0x3c, 0x04, 0x3c, 0x5a, 0x1e, 0x40, 0x9e, 0x5a, 0x40, 0x04, 0x52, 0x3a, 0x41, 0x04, 0x22, 0x04, 0x9e, 0x5a, 0x10, 0x04, 0x52, 0x3a, 0x3e, 0x04, 0xba, 0x40, 0x3c, 0x5c, 0x10, 0x3d, 0x10, 0x04, 0x02, 0x82, 0x00, 0x65, 0x18, 0x9e, 0x9e, 0x59, 0xb2, 0x04, 0xb9, 0x48, 0x14, 0x98, 0x9e, 0x5a, 0xb3, 0x04, 0xb2, 0x3d, 0xe0, 0xe1, 
+0x80, 0x17, 0x10, 0x04, 0x32, 0x3e, 0x10, 0x04, 0xa6, 0x15, 0x40, 0x3a, 0x64, 0x00, 0xba, 0x40, 0x64, 0x63, 0x3c, 0x5b, 0x10, 0x3d, 0x10, 0x04, 0xa6, 0x05, 0x00, 0x61, 0xb9, 0x48, 0x02, 0x98, 0x21, 0x5d, 0x00, 0x9e, 0x3a, 0x38, 0x9e, 0x5e, 0x45, 0x04, 0xdd, 0x48, 0x2a, 0x98, 0x9e, 0x5e, 0x04, 0x04, 0xd2, 0x3e, 0x46, 0x04, 0xdd, 0x48, 0x24, 0x96, 0x9e, 0x58, 0x27, 0x01, 0x00, 0xac, 0x20, 0x92, 0xb2, 0x3d, 0x49, 0x04, 0x9e, 0x5e, 0x11, 0x04, 0xbe, 0x48, 0x03, 0x94, 0x9e, 0x5f, 0x47, 0x04, 0x02, 0x9e, 0x9e, 0x5f, 0x48, 0x04, 0xc1, 0x5b, 0xda, 0xd7, 0x9e, 0x5b, 0x04, 0x04, 0x72, 0x3b, 0xa1, 0x04, 0xbb, 0x48, 0x08, 0x98, 0x9e, 0x5b, 0x9f, 0x04, 0xbb, 0x48, 0x01, 0x96, 0x17, 0x9e, 0x9e, 0x5f, 0xa0, 0x04, 0x02, 0x9e, 0x9e, 0x5f, 0xa2, 0x04, 0x64, 0x66, 0xda, 0xd7, 0x0f, 0x9e, 0x04, 0x85, 
+0xc0, 0x17, 0x23, 0x5a, 0xff, 0x64, 0x7f, 0x6c, 0x44, 0x12, 0x01, 0x88, 0xbb, 0x59, 0x9e, 0x5a, 0xb1, 0x00, 0x19, 0x12, 0xbe, 0x5a, 0xb1, 0x00, 0xf8, 0xce, 0x00, 0x64, 0x00, 0x65, 0x0a, 0x9e, 0x01, 0x60, 0xb8, 0x48, 0x01, 0x94, 0x01, 0x5d, 0x9e, 0x58, 0x04, 0x04, 0x19, 0x10, 0xb8, 0x48, 0x01, 0x9a, 0x01, 0x5d, 0x3a, 0x38, 0xa3, 0x13, 0x7f, 0x40, 0x3c, 0x5e, 0x05, 0x05, 0x3a, 0x38, 0x9e, 0x59, 0xcb, 0x03, 0xde, 0x59, 0x00, 0x00, 0x9e, 0x59, 0xcc, 0x03, 0xde, 0x59, 0x00, 0x00, 0x9e, 0x58, 0xc1, 0x03, 0x00, 0x39, 0x01, 0x00, 0x03, 0x5a, 0x7f, 0x38, 0x5d, 0x59, 0x9e, 0x58, 0xc9, 0x03, 0x5b, 0x58, 0x9e, 0x58, 0xc2, 0x03, 0x00, 0x39, 0x01, 0x00, 0x03, 0x5a, 0x7f, 0x38, 0x5d, 0x59, 0x9e, 0x58, 0xca, 0x03, 0x5b, 0x58, 0x00, 0x61, 0x9e, 0x58, 0xcd, 0x03, 0x3b, 0x58, 0x9e, 0x58, 0x18, 0xed, 
+0x00, 0x18, 0xce, 0x03, 0x3b, 0x58, 0x3a, 0x38, 0x00, 0x60, 0x9e, 0x59, 0xc0, 0x03, 0x19, 0x48, 0x01, 0x8a, 0x01, 0x9e, 0xdf, 0xd7, 0x9e, 0x58, 0xc1, 0x03, 0x03, 0x58, 0x9e, 0x59, 0xc3, 0x03, 0x1b, 0x59, 0x9e, 0x58, 0xc2, 0x03, 0x03, 0x58, 0x9e, 0x59, 0xc4, 0x03, 0x1b, 0x59, 0x9e, 0x58, 0xcb, 0x03, 0x03, 0x58, 0x9e, 0x59, 0x4b, 0x04, 0x1b, 0x11, 0x19, 0x48, 0x0c, 0x9c, 0x9e, 0x59, 0x4b, 0x04, 0x1a, 0x11, 0x19, 0x48, 0x98, 0x3a, 0x34, 0x19, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x11, 0x19, 0x48, 0x04, 0x8a, 0x80, 0x9e, 0x21, 0xda, 0x98, 0x3f, 0x45, 0x19, 0x9e, 0x58, 0xc1, 0x03, 0x03, 0x58, 0x9e, 0x59, 0xc9, 0x03, 0x1b, 0x59, 0x9e, 0x58, 0xc2, 0x03, 0x03, 0x58, 0x9e, 0x59, 0xca, 0x03, 0x1b, 0x59, 0x72, 0xd9, 0x9e, 0x58, 0xc1, 0x03, 0x9e, 0x59, 0xc2, 0x03, 0x7b, 0x58, 0x9b, 0x59, 0x84, 0xc7, 
+0x40, 0x18, 0x9e, 0x5c, 0xc1, 0x03, 0x9e, 0x5d, 0xc2, 0x03, 0x19, 0x04, 0x19, 0x05, 0x85, 0x58, 0x83, 0x5a, 0xa5, 0x59, 0xa3, 0x5b, 0xb3, 0xd6, 0x81, 0x5f, 0xbe, 0x5c, 0x3c, 0x01, 0x9e, 0x59, 0xa3, 0x04, 0xf9, 0x48, 0x04, 0x82, 0x9e, 0x59, 0xa4, 0x04, 0xf9, 0x48, 0x2b, 0x80, 0x9e, 0x5c, 0xc1, 0x03, 0x1b, 0x14, 0x87, 0x58, 0xbe, 0x58, 0xdb, 0x03, 0x87, 0x58, 0xbe, 0x58, 0xdd, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xdf, 0x03, 0x9e, 0x5c, 0xc2, 0x03, 0x1b, 0x14, 0x87, 0x58, 0xbe, 0x58, 0xdc, 0x03, 0x87, 0x58, 0xbe, 0x58, 0xde, 0x03, 0x83, 0x58, 0xbe, 0x58, 0xe0, 0x03, 0x9e, 0x58, 0xa3, 0x04, 0x9e, 0x59, 0xa4, 0x04, 0x01, 0x00, 0x08, 0x58, 0xbe, 0x58, 0xe2, 0x03, 0x9e, 0x58, 0x34, 0x05, 0xbe, 0x58, 0xe3, 0x03, 0xf5, 0xd4, 0x9e, 0x58, 0xe1, 0x03, 0x01, 0x61, 0x19, 0x48, 0x01, 0x8a, 0x3d, 0xe7, 
+0x80, 0x18, 0x02, 0x9e, 0x21, 0xda, 0xc2, 0x9e, 0x9e, 0x5e, 0xc1, 0x03, 0x9e, 0x5f, 0xc2, 0x03, 0xc5, 0x5a, 0xe5, 0x5b, 0xc5, 0x5c, 0xe5, 0x5d, 0xc3, 0x58, 0xe3, 0x59, 0x56, 0xd9, 0x01, 0x5f, 0x9e, 0x59, 0xc2, 0x03, 0x1a, 0x01, 0x23, 0x5e, 0x21, 0xda, 0x8c, 0x60, 0x9e, 0x59, 0xc2, 0x03, 0x19, 0x48, 0x03, 0x8a, 0x9e, 0x58, 0x39, 0x01, 0x02, 0x9e, 0x9e, 0x58, 0x38, 0x01, 0xff, 0x61, 0x7f, 0x69, 0x19, 0x48, 0x01, 0x8a, 0x01, 0x5e, 0x9e, 0x5d, 0xc2, 0x03, 0xdb, 0x5d, 0x9e, 0x5e, 0xc1, 0x03, 0xfb, 0x5e, 0x9b, 0x9e, 0x72, 0xd9, 0x9e, 0x58, 0xc1, 0x03, 0x9e, 0x59, 0xc2, 0x03, 0x7b, 0x58, 0x9b, 0x59, 0x9e, 0x5a, 0xc3, 0x03, 0x9e, 0x5b, 0xc1, 0x03, 0x43, 0x58, 0x63, 0x59, 0x53, 0xdc, 0x9e, 0x59, 0x4e, 0x04, 0x19, 0x48, 0x18, 0x82, 0x9e, 0x5a, 0xc4, 0x03, 0x9e, 0x5b, 0xc2, 0x03, 0x92, 0x5b, 
+0xc0, 0x18, 0x43, 0x58, 0x63, 0x59, 0x53, 0xdc, 0x9e, 0x59, 0x4f, 0x04, 0x19, 0x48, 0x0d, 0x82, 0x9e, 0x58, 0xc1, 0x03, 0x03, 0x58, 0x9e, 0x59, 0xc9, 0x03, 0x1b, 0x59, 0x9e, 0x58, 0xc2, 0x03, 0x03, 0x58, 0x9e, 0x59, 0xca, 0x03, 0x1b, 0x59, 0x19, 0x9e, 0x9e, 0x5e, 0xc1, 0x03, 0x9e, 0x5f, 0xc2, 0x03, 0xc5, 0x5a, 0xe5, 0x5b, 0xc5, 0x5c, 0xe5, 0x5d, 0x9e, 0x5e, 0xc3, 0x03, 0x9e, 0x5f, 0xc4, 0x03, 0xc3, 0x58, 0xe3, 0x59, 0x56, 0xd9, 0x9e, 0x5e, 0xc9, 0x03, 0x1b, 0x5e, 0x9e, 0x58, 0xc4, 0x03, 0x03, 0x58, 0x9e, 0x59, 0xca, 0x03, 0x1b, 0x59, 0x00, 0x9e, 0x9e, 0x5a, 0xc3, 0x03, 0x45, 0x58, 0x43, 0x59, 0x53, 0xdc, 0x00, 0x61, 0x19, 0x48, 0x17, 0x82, 0x9e, 0x5a, 0xc4, 0x03, 0x45, 0x58, 0x43, 0x59, 0x53, 0xdc, 0x00, 0x61, 0x19, 0x48, 0x0f, 0x82, 0x9e, 0x59, 0xcc, 0x03, 0x23, 0x58, 0x49, 0x79, 
+0x00, 0x19, 0x19, 0x00, 0x1b, 0x59, 0xfe, 0x61, 0xff, 0x69, 0x19, 0x48, 0x0b, 0x80, 0x9e, 0x59, 0xcc, 0x03, 0xfe, 0x60, 0xff, 0x68, 0x1b, 0x59, 0x05, 0x9e, 0x9e, 0x59, 0xcc, 0x03, 0x00, 0x60, 0x1b, 0x59, 0x00, 0x9e, 0x9e, 0x58, 0xcc, 0x03, 0x03, 0x58, 0xfe, 0x61, 0xff, 0x69, 0x19, 0x48, 0x01, 0x8a, 0x03, 0x9e, 0x03, 0x62, 0x03, 0x63, 0x05, 0x9e, 0x9e, 0x5a, 0x4c, 0x04, 0x9e, 0x5b, 0x4d, 0x04, 0x00, 0x9e, 0x9e, 0x5c, 0xc1, 0x03, 0x83, 0x58, 0x9e, 0x5c, 0xc3, 0x03, 0x83, 0x59, 0x53, 0xdc, 0x1a, 0x48, 0x0a, 0x82, 0x9e, 0x5c, 0xc2, 0x03, 0x83, 0x58, 0x9e, 0x5c, 0xc4, 0x03, 0x83, 0x59, 0x53, 0xdc, 0x1b, 0x48, 0x01, 0x82, 0x02, 0x9e, 0x21, 0xda, 0x0f, 0x9e, 0x9e, 0x59, 0xc1, 0x03, 0x19, 0x01, 0x23, 0x58, 0x9e, 0x59, 0xc1, 0x03, 0x1b, 0x59, 0x9e, 0x59, 0xc2, 0x03, 0x19, 0x01, 0xfc, 0x9d, 
+0x40, 0x19, 0x23, 0x58, 0x9e, 0x59, 0xc2, 0x03, 0x1b, 0x59, 0x00, 0x9e, 0x9e, 0x5a, 0xcb, 0x03, 0x43, 0x58, 0x19, 0x00, 0x1b, 0x5a, 0x9e, 0x59, 0x4b, 0x04, 0x19, 0x48, 0x07, 0x80, 0x3b, 0x5a, 0xff, 0x60, 0x7f, 0x68, 0xbe, 0x58, 0x38, 0x01, 0xbe, 0x58, 0x39, 0x01, 0x3a, 0x38, 0x01, 0x5e, 0x21, 0x5f, 0x61, 0x58, 0xa1, 0x59, 0x53, 0xdc, 0x03, 0x61, 0x19, 0x48, 0x11, 0x9a, 0xc1, 0x58, 0xe1, 0x59, 0x23, 0x10, 0x82, 0x11, 0xa3, 0x13, 0x19, 0x40, 0x3c, 0x5b, 0x02, 0x00, 0x01, 0x94, 0x00, 0x60, 0x9e, 0x59, 0x05, 0x04, 0x19, 0x11, 0x38, 0x48, 0x01, 0x94, 0x21, 0x58, 0x3a, 0x38, 0xc1, 0x58, 0xe1, 0x59, 0x3a, 0x38, 0x9e, 0x5a, 0xc1, 0x03, 0x45, 0x58, 0x43, 0x59, 0x53, 0xdc, 0x01, 0x5e, 0x9e, 0x5a, 0xc2, 0x03, 0x45, 0x58, 0x43, 0x59, 0x53, 0xdc, 0x01, 0x5f, 0xc7, 0x07, 0x9e, 0x58, 0x95, 0xce, 
+0x80, 0x19, 0x12, 0x05, 0x9e, 0x59, 0xc2, 0x03, 0x23, 0x59, 0x38, 0x48, 0x11, 0x96, 0x9e, 0x5b, 0x04, 0x04, 0x60, 0x10, 0x38, 0x48, 0x0c, 0x98, 0x9e, 0x58, 0x12, 0x05, 0x9e, 0x59, 0xc1, 0x03, 0x23, 0x59, 0x38, 0x48, 0x05, 0x96, 0x9e, 0x5b, 0x05, 0x04, 0x60, 0x10, 0x38, 0x48, 0x09, 0x9a, 0x9e, 0x5a, 0x13, 0x05, 0xbe, 0x5a, 0xd3, 0x03, 0x9e, 0x5a, 0x14, 0x05, 0xbe, 0x5a, 0xd4, 0x03, 0x08, 0x9e, 0x9e, 0x5a, 0x52, 0x04, 0xbe, 0x5a, 0xd3, 0x03, 0x9e, 0x5a, 0x53, 0x04, 0xbe, 0x5a, 0xd4, 0x03, 0x9e, 0x58, 0x50, 0x04, 0xf8, 0x48, 0x16, 0x82, 0x9e, 0x58, 0x51, 0x04, 0xf8, 0x48, 0x15, 0x9c, 0x9e, 0x5e, 0x51, 0x04, 0xe6, 0x17, 0x9e, 0x58, 0xd3, 0x03, 0x9e, 0x59, 0xd4, 0x03, 0x01, 0x10, 0xe0, 0x40, 0x9e, 0x5a, 0x50, 0x04, 0x52, 0x3a, 0x51, 0x04, 0x1c, 0x5a, 0x9e, 0x59, 0xd4, 0x03, 0x99, 0x22, 
+0xc0, 0x19, 0x01, 0x00, 0x06, 0x9e, 0x9e, 0x58, 0xd3, 0x03, 0x03, 0x9e, 0x9e, 0x58, 0xd4, 0x03, 0x00, 0x9e, 0xbe, 0x58, 0xcf, 0x03, 0x01, 0x62, 0x9e, 0x5b, 0x54, 0x04, 0x19, 0x13, 0x77, 0x38, 0x46, 0x5a, 0x40, 0x12, 0xbe, 0x5a, 0xd0, 0x03, 0x9e, 0x5f, 0xc1, 0x03, 0x9e, 0x5e, 0xcd, 0x03, 0xe0, 0xd9, 0x01, 0x5b, 0x9e, 0x5f, 0xc2, 0x03, 0x9e, 0x5e, 0xce, 0x03, 0xe0, 0xd9, 0x01, 0x5c, 0x3a, 0x38, 0x9e, 0x5a, 0xcf, 0x03, 0xe5, 0x5d, 0xa2, 0x40, 0xbe, 0x59, 0xd1, 0x03, 0xbe, 0x58, 0xd2, 0x03, 0x9e, 0x5a, 0xd0, 0x03, 0xe3, 0x5d, 0xa2, 0x40, 0x9e, 0x5a, 0xd2, 0x03, 0x40, 0x00, 0x01, 0x80, 0x19, 0x01, 0xc3, 0x5f, 0xe0, 0x00, 0x01, 0x80, 0x19, 0x01, 0x9e, 0x5a, 0xd1, 0x03, 0x41, 0x01, 0x00, 0x62, 0x9e, 0x5d, 0x54, 0x04, 0x19, 0x15, 0xa7, 0x38, 0x00, 0x1a, 0x28, 0x59, 0x0c, 0x58, 0x86, 0xc2, 
+0x00, 0x1a, 0x4c, 0x5a, 0x0f, 0x65, 0xb2, 0x3d, 0x54, 0x04, 0xb7, 0x38, 0x48, 0x5a, 0xe2, 0x07, 0x01, 0x62, 0x9e, 0x5d, 0x54, 0x04, 0x19, 0x15, 0xb7, 0x38, 0x46, 0x5a, 0xfa, 0x48, 0x01, 0x80, 0xe2, 0x17, 0xfb, 0x5e, 0x3a, 0x38, 0x9e, 0x5b, 0xc1, 0x03, 0x65, 0x5a, 0x65, 0x59, 0x63, 0x58, 0x28, 0xda, 0x01, 0x5b, 0x9e, 0x5c, 0xc2, 0x03, 0x85, 0x5a, 0x85, 0x59, 0x83, 0x58, 0x28, 0xda, 0x01, 0x5c, 0x3a, 0x38, 0x9e, 0x58, 0xc1, 0x03, 0xf0, 0xce, 0x9e, 0x58, 0xc2, 0x03, 0xf0, 0xce, 0x3a, 0x38, 0x01, 0x00, 0x06, 0x61, 0x01, 0x40, 0x3f, 0x38, 0x46, 0x5a, 0x02, 0x00, 0x01, 0x80, 0x19, 0x01, 0x6f, 0x38, 0x33, 0x1a, 0x28, 0x59, 0x0c, 0x58, 0x3a, 0x38, 0x00, 0x60, 0x00, 0x61, 0xc3, 0x5a, 0xe3, 0x58, 0x02, 0x10, 0x1b, 0x40, 0xc3, 0x5a, 0xf2, 0x02, 0x3c, 0x5a, 0x03, 0x00, 0x08, 0x58, 0xb3, 0x6a, 
+0x40, 0x1a, 0x3a, 0x38, 0x62, 0x38, 0x80, 0x00, 0x13, 0x88, 0x9e, 0x58, 0xf9, 0x00, 0x19, 0x30, 0x0f, 0x88, 0x9e, 0x5d, 0x72, 0x00, 0x9e, 0x59, 0x0b, 0x04, 0x20, 0x39, 0x38, 0x03, 0xb9, 0x48, 0x07, 0x88, 0xe8, 0x61, 0x03, 0x69, 0x2d, 0x41, 0x9e, 0x5a, 0xc3, 0x04, 0x1c, 0x5a, 0x1b, 0x5d, 0x00, 0x60, 0x00, 0x61, 0x00, 0x62, 0xe3, 0x5d, 0xa4, 0x15, 0x01, 0x82, 0x00, 0x65, 0x45, 0x02, 0x02, 0x00, 0x01, 0x80, 0x19, 0x01, 0x19, 0x17, 0xfe, 0x48, 0xf5, 0x83, 0x01, 0x5c, 0x23, 0x40, 0x01, 0x5f, 0x83, 0x40, 0xe1, 0x01, 0x62, 0x3f, 0x80, 0x00, 0x1d, 0x88, 0x9e, 0x5f, 0xf9, 0x00, 0x19, 0x37, 0x19, 0x88, 0x9e, 0x5f, 0x72, 0x00, 0x9e, 0x5d, 0x0b, 0x04, 0xa0, 0x3d, 0x38, 0x03, 0xfd, 0x48, 0x11, 0x96, 0x21, 0x5d, 0x01, 0x5c, 0xe8, 0x67, 0x03, 0x6f, 0x9e, 0x58, 0xc3, 0x04, 0xe0, 0x10, 0xe2, 0xfa, 
+0x80, 0x1a, 0x9e, 0x59, 0x72, 0x00, 0x09, 0x41, 0x1c, 0x5f, 0xa1, 0x59, 0x80, 0x65, 0xa8, 0x5d, 0x01, 0x5f, 0x81, 0x58, 0xaf, 0x48, 0x1c, 0x5a, 0x03, 0x10, 0x3a, 0x38, 0x38, 0x66, 0x03, 0x6e, 0x9e, 0x5f, 0x72, 0x00, 0x3f, 0xdc, 0xbe, 0x5b, 0xb6, 0x00, 0x9e, 0x5e, 0x72, 0x00, 0x9e, 0x5f, 0x73, 0x00, 0x3f, 0xdc, 0xbe, 0x5b, 0xb7, 0x00, 0x3a, 0x38, 0x9e, 0x5e, 0x6e, 0x00, 0x9e, 0x5f, 0x72, 0x00, 0xb5, 0xda, 0xbe, 0x59, 0x75, 0x00, 0xbe, 0x5a, 0x76, 0x00, 0x9e, 0x5e, 0xb1, 0x00, 0x01, 0x67, 0xdf, 0x48, 0x98, 0x3a, 0xdb, 0x1b, 0x9e, 0x5e, 0x6f, 0x00, 0x9e, 0x5f, 0x73, 0x00, 0xb5, 0xda, 0xbe, 0x59, 0x77, 0x00, 0xbe, 0x5a, 0x78, 0x00, 0x3a, 0x38, 0x00, 0x61, 0x00, 0x62, 0xc0, 0x3e, 0xed, 0xfe, 0xe0, 0x3f, 0xed, 0xfe, 0xc3, 0x58, 0x20, 0x01, 0x7b, 0x06, 0xc3, 0x58, 0x40, 0x02, 0x42, 0xa8, 
+0xc0, 0x1a, 0x7b, 0x16, 0x19, 0x06, 0xfe, 0x48, 0xf7, 0x83, 0x1e, 0x5b, 0x1e, 0x5c, 0x9e, 0x5b, 0x89, 0x04, 0x00, 0x64, 0x7c, 0x48, 0x2e, 0x8a, 0xc2, 0x3b, 0x26, 0x02, 0x9e, 0x5c, 0x0a, 0x04, 0x88, 0x5c, 0x7c, 0x48, 0x11, 0x98, 0xc3, 0x58, 0x1e, 0x59, 0x9e, 0x5c, 0x8a, 0x04, 0x03, 0x40, 0x1c, 0x5c, 0x3e, 0x59, 0x20, 0x11, 0xc0, 0x38, 0x1b, 0x00, 0x03, 0x58, 0x1e, 0x59, 0x03, 0x40, 0x1c, 0x5c, 0x3e, 0x59, 0x40, 0x12, 0x16, 0x9e, 0xc2, 0x38, 0x04, 0x00, 0x03, 0x58, 0x1e, 0x59, 0x9e, 0x5c, 0x0a, 0x04, 0x19, 0x04, 0x83, 0x13, 0x9e, 0x5c, 0x8a, 0x04, 0x03, 0x40, 0x1c, 0x5c, 0x3e, 0x59, 0x20, 0x11, 0xc0, 0x38, 0x17, 0x00, 0x03, 0x58, 0x1e, 0x59, 0x03, 0x40, 0x1c, 0x5c, 0x3e, 0x59, 0x40, 0x12, 0x3e, 0x5c, 0x3e, 0x5b, 0x3a, 0x38, 0x00, 0x60, 0xbe, 0x58, 0xb1, 0x00, 0x38, 0x66, 0xf2, 0xa1, 
+0x00, 0x1b, 0x03, 0x6e, 0x9e, 0x5f, 0x0b, 0x04, 0xe0, 0x3f, 0x38, 0x03, 0x6e, 0x63, 0xdd, 0x5b, 0xdd, 0x5b, 0x72, 0x64, 0xfd, 0x5c, 0xfd, 0x5c, 0xfb, 0x5c, 0x72, 0x64, 0xc3, 0x59, 0xc3, 0x5b, 0xc3, 0x58, 0x19, 0x06, 0xc3, 0x5a, 0x59, 0x48, 0x19, 0x80, 0x5c, 0x12, 0x21, 0x80, 0x59, 0x48, 0x1f, 0x80, 0x79, 0x48, 0x16, 0x8a, 0x10, 0x38, 0x26, 0x01, 0x78, 0x48, 0x03, 0x82, 0x12, 0x38, 0x26, 0x01, 0x0f, 0x9e, 0x74, 0x65, 0xbc, 0x48, 0x13, 0x80, 0x9e, 0x5d, 0xb1, 0x00, 0x19, 0x05, 0xbe, 0x5d, 0xb1, 0x00, 0xc3, 0x5b, 0x21, 0x58, 0x19, 0x04, 0x03, 0x9e, 0x5c, 0x02, 0x3a, 0x48, 0x07, 0x80, 0xc3, 0x59, 0x7e, 0x49, 0x01, 0x82, 0xc3, 0x5b, 0x1e, 0x49, 0x01, 0x80, 0xc3, 0x58, 0xdb, 0x5c, 0x19, 0x06, 0xfe, 0x48, 0xd6, 0x83, 0x10, 0x38, 0x26, 0x01, 0x78, 0x48, 0x54, 0x80, 0x9e, 0x5d, 0xde, 0xad, 
+0x40, 0x1b, 0xb1, 0x00, 0x19, 0x05, 0xbe, 0x5d, 0xb1, 0x00, 0x03, 0x60, 0x9e, 0x5d, 0xb1, 0x00, 0xb8, 0x48, 0x44, 0x96, 0x00, 0x60, 0x9e, 0x59, 0xb2, 0x00, 0x38, 0x48, 0x0f, 0x98, 0x38, 0x60, 0x03, 0x68, 0xbe, 0x58, 0x28, 0x01, 0x9e, 0x58, 0x72, 0x00, 0xbe, 0x58, 0x29, 0x01, 0xbe, 0x58, 0x2a, 0x01, 0x9e, 0x58, 0x73, 0x00, 0xbe, 0x58, 0x2b, 0x01, 0x2c, 0x9e, 0x01, 0x60, 0x38, 0x48, 0x1b, 0x98, 0x9e, 0x58, 0x70, 0x00, 0x9b, 0xdb, 0xbe, 0x5e, 0x28, 0x01, 0xbe, 0x5f, 0x29, 0x01, 0x38, 0x60, 0x03, 0x68, 0xd8, 0x48, 0x05, 0x8a, 0xbe, 0x58, 0x2a, 0x01, 0xbe, 0x5e, 0x2b, 0x01, 0x19, 0x9e, 0x9e, 0x58, 0x72, 0x00, 0xbe, 0x58, 0x2a, 0x01, 0x9e, 0x58, 0x0b, 0x04, 0x00, 0x38, 0x38, 0x03, 0xbe, 0x58, 0x2b, 0x01, 0x0e, 0x9e, 0x9e, 0x58, 0x70, 0x00, 0x9b, 0xdb, 0xbe, 0x5e, 0x28, 0x01, 0xaf, 0x37, 
+0x80, 0x1b, 0xbe, 0x5f, 0x29, 0x01, 0x9e, 0x58, 0x71, 0x00, 0x9b, 0xdb, 0xbe, 0x5e, 0x2a, 0x01, 0xbe, 0x5f, 0x2b, 0x01, 0x02, 0x60, 0xbe, 0x58, 0xb1, 0x00, 0x3a, 0x38, 0x72, 0x61, 0x6f, 0x62, 0x23, 0x58, 0x1b, 0x5a, 0xaf, 0xdb, 0x3a, 0x38, 0x72, 0x65, 0x9d, 0x48, 0x03, 0x8a, 0x19, 0x14, 0xfb, 0x5c, 0xab, 0x9f, 0xaf, 0xdb, 0x3a, 0x38, 0x72, 0x61, 0x25, 0x5b, 0x1b, 0x48, 0x04, 0x94, 0x38, 0x66, 0x03, 0x6e, 0x61, 0x5f, 0x0b, 0x9e, 0x23, 0x5b, 0x1b, 0x48, 0x03, 0x94, 0x27, 0x5f, 0x23, 0x5e, 0x05, 0x9e, 0x61, 0x5e, 0x9e, 0x5f, 0x0b, 0x04, 0xe0, 0x3f, 0x38, 0x03, 0x3a, 0x38, 0x38, 0x60, 0x03, 0x68, 0xbe, 0x58, 0x28, 0x01, 0x9e, 0x58, 0x72, 0x00, 0xbe, 0x58, 0x29, 0x01, 0xbe, 0x58, 0x2a, 0x01, 0x9e, 0x58, 0x0b, 0x04, 0x00, 0x38, 0x38, 0x03, 0xbe, 0x58, 0x2b, 0x01, 0x3a, 0x38, 0x9c, 0xdd, 
+0xc0, 0x1b, 0x9e, 0x58, 0x70, 0x00, 0x9e, 0x5e, 0x28, 0x01, 0x9e, 0x5f, 0x29, 0x01, 0xdc, 0xdb, 0xbe, 0x5e, 0x6e, 0x00, 0xbe, 0x5f, 0x72, 0x00, 0x9e, 0x5e, 0xb1, 0x00, 0x01, 0x67, 0xdf, 0x48, 0x0b, 0x8a, 0x9e, 0x58, 0x71, 0x00, 0x9e, 0x5e, 0x2a, 0x01, 0x9e, 0x5f, 0x2b, 0x01, 0xdc, 0xdb, 0xbe, 0x5e, 0x6f, 0x00, 0xbe, 0x5f, 0x73, 0x00, 0x3a, 0x38, 0x1e, 0x59, 0x1e, 0x5a, 0x1e, 0x5b, 0x9e, 0x59, 0x89, 0x04, 0x18, 0x31, 0x05, 0x8a, 0x02, 0x39, 0x01, 0x00, 0x00, 0x3a, 0x01, 0x00, 0x08, 0x9e, 0x9e, 0x5b, 0x43, 0x05, 0x66, 0x39, 0x00, 0x00, 0x01, 0x88, 0x02, 0x63, 0x03, 0x11, 0x03, 0x02, 0x3e, 0x48, 0x01, 0x80, 0x21, 0x5e, 0x41, 0x59, 0xf9, 0x48, 0x01, 0x80, 0x21, 0x5f, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3a, 0x38, 0x25, 0x63, 0x02, 0x6b, 0x40, 0x64, 0x02, 0x6c, 0x38, 0x65, 0x2c, 0x1a, 
+0x00, 0x1c, 0x03, 0x6d, 0x9e, 0x5e, 0x26, 0x05, 0x18, 0x30, 0x01, 0x8a, 0x00, 0x66, 0x9e, 0x59, 0x0b, 0x04, 0x27, 0x38, 0x14, 0x1c, 0x00, 0x67, 0x63, 0x59, 0x3e, 0x48, 0x08, 0x80, 0x83, 0x5a, 0x5e, 0x48, 0x07, 0x80, 0x22, 0x00, 0x3d, 0x5b, 0x5d, 0x5c, 0x1d, 0x5d, 0x3a, 0x38, 0x19, 0x07, 0xf6, 0x9f, 0x19, 0x07, 0x02, 0x60, 0xf8, 0x48, 0x01, 0x8a, 0xf4, 0x9f, 0x00, 0x61, 0x00, 0x62, 0xf1, 0x9f, 0x04, 0x38, 0xff, 0x0f, 0x24, 0x39, 0xff, 0x0f, 0x04, 0x3a, 0x00, 0x0f, 0x7f, 0x38, 0x46, 0x5a, 0x41, 0x2a, 0xff, 0x38, 0x48, 0x5a, 0x04, 0x3b, 0xff, 0x00, 0x24, 0x3c, 0xff, 0x00, 0x3a, 0x38, 0x64, 0x3b, 0xff, 0x00, 0x84, 0x3c, 0xff, 0x00, 0x44, 0x38, 0xf0, 0x00, 0x7f, 0x38, 0x06, 0x58, 0x03, 0x28, 0x44, 0x39, 0x0f, 0x00, 0xff, 0x38, 0x26, 0x59, 0x24, 0x29, 0x3a, 0x38, 0xc3, 0x5b, 0x82, 0x6b, 
+0x40, 0x1c, 0xc3, 0x5a, 0x7a, 0x48, 0x01, 0x80, 0x41, 0x5b, 0x19, 0x06, 0xfe, 0x48, 0xf9, 0x83, 0x3a, 0x38, 0xc3, 0x5b, 0xc1, 0x58, 0xc3, 0x5a, 0x7a, 0x48, 0x02, 0x82, 0x41, 0x5b, 0xc1, 0x58, 0x19, 0x06, 0xfe, 0x48, 0xf8, 0x83, 0x3a, 0x38, 0x19, 0x48, 0x02, 0x82, 0x20, 0x10, 0x3a, 0x38, 0x01, 0x10, 0x3a, 0x38, 0x9e, 0x5e, 0x28, 0x01, 0x9e, 0x5f, 0x29, 0x01, 0x48, 0xdc, 0xbe, 0x58, 0x70, 0x00, 0x9e, 0x5e, 0x2a, 0x01, 0x9e, 0x5f, 0x2b, 0x01, 0x48, 0xdc, 0xbe, 0x58, 0x71, 0x00, 0x3a, 0x38, 0x00, 0x61, 0x9e, 0x58, 0x04, 0x04, 0x9e, 0x5d, 0x0a, 0x04, 0x3c, 0x5d, 0x01, 0x5d, 0xfd, 0x48, 0x07, 0x96, 0x9e, 0x58, 0x04, 0x04, 0x05, 0x10, 0xf8, 0x48, 0x15, 0x98, 0x98, 0x3f, 0x84, 0x1e, 0x9e, 0x58, 0x05, 0x04, 0x08, 0x58, 0x1e, 0x48, 0x07, 0x98, 0x1e, 0x5d, 0x9e, 0x5a, 0x3e, 0x04, 0x31, 0x73, 
+0x80, 0x1c, 0x01, 0x5b, 0x00, 0x64, 0xfa, 0x65, 0x1a, 0x9e, 0x1e, 0x5d, 0x01, 0x5a, 0x9e, 0x5b, 0x3f, 0x04, 0xfa, 0x64, 0x00, 0x65, 0x13, 0x9e, 0x9e, 0x58, 0x05, 0x04, 0x08, 0x58, 0x1e, 0x48, 0x07, 0x98, 0x1e, 0x5d, 0x9e, 0x5a, 0x3e, 0x04, 0x01, 0x5b, 0x00, 0x64, 0x00, 0x65, 0x12, 0x9e, 0x1e, 0x5d, 0x01, 0x5a, 0x9e, 0x5b, 0x3f, 0x04, 0x00, 0x64, 0x00, 0x65, 0x0b, 0x9e, 0x44, 0x12, 0x65, 0x13, 0x62, 0x13, 0xa4, 0x11, 0xc2, 0x10, 0x38, 0x40, 0x3c, 0x5b, 0x04, 0x00, 0x3e, 0x5d, 0xa7, 0x11, 0x0d, 0x9e, 0x44, 0x12, 0x65, 0x13, 0x62, 0x13, 0xa4, 0x11, 0xc2, 0x10, 0x38, 0x40, 0x3c, 0x5b, 0x04, 0x00, 0x3e, 0x5d, 0x9e, 0x59, 0x04, 0x04, 0x27, 0x11, 0xa1, 0x11, 0x01, 0x5a, 0x0a, 0x60, 0x38, 0x40, 0x3c, 0x5d, 0x01, 0x5b, 0x1b, 0x40, 0x1b, 0x40, 0x1b, 0x40, 0x1a, 0x40, 0x10, 0x63, 0xe9, 0xdd, 
+0xc0, 0x1c, 0x27, 0x6b, 0x3c, 0x5b, 0xc0, 0x06, 0x98, 0x3f, 0x7a, 0x1e, 0x00, 0x61, 0x9e, 0x58, 0x05, 0x04, 0x07, 0x65, 0x3c, 0x5d, 0x01, 0x5a, 0x9e, 0x5c, 0xf2, 0x04, 0xfc, 0x48, 0x2b, 0x96, 0x9e, 0x5c, 0xe2, 0x04, 0xfc, 0x48, 0x10, 0x96, 0x9e, 0x58, 0x04, 0x04, 0x9e, 0x5c, 0xf3, 0x04, 0x04, 0x10, 0xf8, 0x48, 0x4b, 0x98, 0x9e, 0x58, 0x04, 0x04, 0x9e, 0x5c, 0xe3, 0x04, 0x04, 0x10, 0xf8, 0x48, 0x2d, 0x98, 0x98, 0x3f, 0x84, 0x1e, 0x87, 0x13, 0x9e, 0x5d, 0xf2, 0x04, 0x85, 0x14, 0x41, 0x5d, 0xdd, 0x48, 0x58, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x58, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x58, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x58, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x58, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x58, 0x96, 0x5a, 0x9e, 0x87, 0x13, 0x41, 0x5d, 0xdd, 0x48, 0x6e, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x32, 0xdc, 
+0x00, 0x1d, 0x7e, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x8e, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x9e, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0xae, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0xbe, 0x96, 0xd0, 0x9e, 0xe0, 0x13, 0x9e, 0x5d, 0xf3, 0x04, 0x85, 0x14, 0x41, 0x5d, 0xdd, 0x48, 0x42, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x42, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x42, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x42, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x42, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x42, 0x96, 0x44, 0x9e, 0xe0, 0x13, 0x41, 0x5d, 0xdd, 0x48, 0xc8, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0xd8, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0xe8, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0xf8, 0x96, 0xa2, 0x05, 0xdd, 0x48, 0x98, 0x3d, 0x3e, 0x1e, 0xa2, 0x05, 0xdd, 0x48, 0x98, 0x3d, 0x52, 0x1e, 0x98, 0x3f, 0x66, 0x1e, 0xbb, 0x40, 0x64, 0x64, 0x3c, 0x5c, 0xc0, 0x06, 0x13, 0x80, 
+0x40, 0x1d, 0x98, 0x3f, 0x7a, 0x1e, 0x9e, 0x5d, 0xe4, 0x04, 0xf7, 0x9f, 0x9e, 0x5d, 0xe5, 0x04, 0xf4, 0x9f, 0x9e, 0x5d, 0xe6, 0x04, 0xf1, 0x9f, 0x9e, 0x5d, 0xe7, 0x04, 0xee, 0x9f, 0x9e, 0x5d, 0xe8, 0x04, 0xeb, 0x9f, 0x9e, 0x5d, 0xe9, 0x04, 0xe8, 0x9f, 0x9e, 0x5d, 0xea, 0x04, 0xe5, 0x9f, 0x9e, 0x5d, 0xeb, 0x04, 0xe2, 0x9f, 0x9e, 0x5d, 0xec, 0x04, 0xdf, 0x9f, 0x9e, 0x5d, 0xed, 0x04, 0xdc, 0x9f, 0x9e, 0x5d, 0xee, 0x04, 0xd9, 0x9f, 0x9e, 0x5d, 0xef, 0x04, 0xd6, 0x9f, 0x9e, 0x5d, 0xf0, 0x04, 0xd3, 0x9f, 0x9e, 0x5d, 0xf1, 0x04, 0xd0, 0x9f, 0x9e, 0x5d, 0xe2, 0x04, 0x9e, 0x5c, 0xf2, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xe4, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xf4, 0x04, 0xbd, 0x9f, 0x9e, 0x5d, 0xd9, 0x00, 
+0x80, 0x1d, 0xe2, 0x04, 0x9e, 0x5c, 0xf2, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xe5, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xf5, 0x04, 0xaa, 0x9f, 0x9e, 0x5d, 0xe2, 0x04, 0x9e, 0x5c, 0xf2, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xe6, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xf6, 0x04, 0x97, 0x9f, 0x9e, 0x5d, 0xe2, 0x04, 0x9e, 0x5c, 0xf2, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xe7, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xf7, 0x04, 0x84, 0x9f, 0x9e, 0x5d, 0xe2, 0x04, 0x9e, 0x5c, 0xf2, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xe8, 0x04, 0x1e, 0x58, 0xd7, 0x64, 
+0xc0, 0x1d, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xf8, 0x04, 0x71, 0x9f, 0x9e, 0x5d, 0xe2, 0x04, 0x9e, 0x5c, 0xf2, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xe9, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xf9, 0x04, 0x5e, 0x9f, 0x9e, 0x5d, 0xe2, 0x04, 0x9e, 0x5c, 0xf2, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xea, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xfa, 0x04, 0x4b, 0x9f, 0x9e, 0x5d, 0xe3, 0x04, 0x9e, 0x5c, 0xf3, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xeb, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0xa1, 0x98, 
+0x00, 0x1e, 0x86, 0x06, 0x9e, 0x5d, 0xfb, 0x04, 0x38, 0x9f, 0x9e, 0x5d, 0xe3, 0x04, 0x9e, 0x5c, 0xf3, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xec, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xfc, 0x04, 0x25, 0x9f, 0x9e, 0x5d, 0xe3, 0x04, 0x9e, 0x5c, 0xf3, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xed, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xfd, 0x04, 0x12, 0x9f, 0x9e, 0x5d, 0xe3, 0x04, 0x9e, 0x5c, 0xf3, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xee, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xfe, 0x04, 0x98, 0x3f, 0x3c, 0x1d, 0x9e, 0x5d, 0xe3, 0x04, 0xeb, 0x56, 
+0x40, 0x1e, 0x9e, 0x5c, 0xf3, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xef, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0xff, 0x04, 0x98, 0x3f, 0x3c, 0x1d, 0x9e, 0x5d, 0xe3, 0x04, 0x9e, 0x5c, 0xf3, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xf0, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0x00, 0x05, 0x98, 0x3f, 0x3c, 0x1d, 0x9e, 0x5d, 0xe3, 0x04, 0x9e, 0x5c, 0xf3, 0x04, 0xa4, 0x14, 0x9e, 0x5d, 0xf1, 0x04, 0x1e, 0x58, 0x1e, 0x59, 0x9d, 0x40, 0x64, 0x65, 0x3c, 0x5d, 0x01, 0x5c, 0x3e, 0x59, 0x3e, 0x58, 0x86, 0x06, 0x9e, 0x5d, 0x01, 0x05, 0x98, 0x3f, 0x3c, 0x1d, 0x00, 0x65, 0xdd, 0x48, 0x06, 0x96, 0x9e, 0x5d, 0x05, 0x04, 0x19, 0x15, 0xf4, 0xbf, 
+0x80, 0x1e, 0xdd, 0x48, 0x01, 0x98, 0x01, 0x9e, 0xa1, 0x5e, 0x3a, 0x38, 0x9e, 0x59, 0xdc, 0x00, 0x9e, 0x5e, 0x8b, 0x04, 0x00, 0x67, 0xdf, 0x48, 0x39, 0x8a, 0x9e, 0x59, 0x0b, 0x04, 0x38, 0x66, 0x03, 0x6e, 0xc1, 0x07, 0x48, 0xdc, 0x38, 0x66, 0x03, 0x6e, 0x28, 0x59, 0x20, 0x39, 0x38, 0x03, 0x19, 0x48, 0x03, 0x98, 0x10, 0x38, 0x8f, 0x04, 0x02, 0x9e, 0x12, 0x38, 0x8f, 0x04, 0x03, 0x5e, 0x9e, 0x59, 0xdc, 0x00, 0x01, 0xac, 0x09, 0x92, 0x9e, 0x58, 0x8c, 0x04, 0xd8, 0x48, 0x1e, 0x96, 0x01, 0xa8, 0x01, 0x60, 0xbe, 0x58, 0xdb, 0x00, 0x19, 0x9e, 0x9e, 0x58, 0x8d, 0x04, 0xd8, 0x48, 0x0b, 0x9a, 0x9e, 0x58, 0xdb, 0x00, 0x19, 0x00, 0x9e, 0x5f, 0x8e, 0x04, 0x1f, 0x48, 0x01, 0x9a, 0xe1, 0x58, 0xbe, 0x58, 0xdb, 0x00, 0x0a, 0x9e, 0x9e, 0x58, 0xdb, 0x00, 0x00, 0x67, 0x1f, 0x48, 0x04, 0x8a, 0x62, 0x98, 
+0xc0, 0x1e, 0x19, 0x10, 0xbe, 0x58, 0xdb, 0x00, 0x01, 0x9e, 0x01, 0xaa, 0xbe, 0x59, 0xdc, 0x00, 0x3a, 0x38, 0x9e, 0x5c, 0xc1, 0x03, 0x83, 0x5c, 0x9e, 0x5e, 0x04, 0x04, 0xd2, 0x3e, 0xbb, 0x04, 0x9e, 0x48, 0x12, 0x96, 0x9e, 0x58, 0xba, 0x04, 0x18, 0x30, 0x0e, 0x8a, 0x9e, 0x58, 0xbc, 0x04, 0xbe, 0x58, 0xc4, 0x03, 0x9e, 0x58, 0xbd, 0x04, 0xbe, 0x58, 0xc5, 0x03, 0x9e, 0x58, 0xbe, 0x04, 0xbe, 0x58, 0xc6, 0x03, 0xfa, 0xde, 0x16, 0x9e, 0x9e, 0x5d, 0xc0, 0x04, 0x9d, 0x48, 0x12, 0x98, 0x9e, 0x58, 0xbf, 0x04, 0x18, 0x30, 0x0e, 0x8a, 0x9e, 0x58, 0xc1, 0x04, 0xbe, 0x58, 0xc4, 0x03, 0x9e, 0x58, 0xdc, 0x04, 0xbe, 0x58, 0xc5, 0x03, 0x9e, 0x58, 0xdd, 0x04, 0xbe, 0x58, 0xc6, 0x03, 0xfa, 0xde, 0x00, 0x9e, 0x3a, 0x38, 0x9e, 0x5d, 0x05, 0x04, 0x9e, 0x5c, 0xc0, 0x03, 0x83, 0x5c, 0x9e, 0x5f, 0xf4, 0x22, 
+0x00, 0x1f, 0xc3, 0x03, 0x9e, 0x58, 0xc4, 0x03, 0x19, 0x30, 0x03, 0x8a, 0x9e, 0x5f, 0xc2, 0x03, 0xa4, 0x14, 0xe3, 0x5b, 0x25, 0x62, 0x02, 0x6a, 0x50, 0x3a, 0x03, 0x01, 0x43, 0x5a, 0x5f, 0x38, 0x48, 0x5a, 0x9e, 0x5e, 0xc5, 0x03, 0x5e, 0x40, 0x1c, 0x40, 0x3c, 0x5d, 0x60, 0x03, 0x9e, 0x5e, 0xc6, 0x03, 0x5e, 0x40, 0x60, 0x03, 0x7b, 0x5f, 0x9e, 0x5e, 0xc2, 0x03, 0x9e, 0x5f, 0xc3, 0x03, 0x9e, 0x5b, 0x05, 0x04, 0x00, 0x64, 0x41, 0xda, 0x9e, 0x5e, 0xc1, 0x03, 0xc3, 0x5e, 0x1d, 0xd7, 0x9e, 0x58, 0xc0, 0x03, 0xbb, 0x58, 0x3a, 0x38, 0x9e, 0x58, 0xd5, 0x04, 0x00, 0x61, 0x19, 0x48, 0x5e, 0x8a, 0xce, 0xdf, 0x9e, 0x58, 0xc0, 0x03, 0x9e, 0x59, 0xd6, 0x04, 0x19, 0x48, 0x57, 0x96, 0x9e, 0x58, 0xd6, 0x04, 0xbe, 0x58, 0x26, 0x01, 0x9e, 0x58, 0xd5, 0x04, 0x00, 0xac, 0x0c, 0x90, 0x9e, 0x58, 0x48, 0xe7, 
+0x40, 0x1f, 0x45, 0x01, 0x9e, 0x59, 0xd7, 0x04, 0x19, 0x48, 0x06, 0x96, 0x9e, 0x59, 0xd8, 0x04, 0x19, 0x48, 0x02, 0x98, 0x00, 0x60, 0x33, 0x9e, 0x9e, 0x58, 0xd5, 0x04, 0x08, 0xac, 0x0e, 0x90, 0xe8, 0x60, 0x03, 0x68, 0x12, 0x38, 0x45, 0x01, 0x9e, 0x59, 0x02, 0x05, 0x19, 0x48, 0x06, 0x96, 0x9e, 0x59, 0x03, 0x05, 0x19, 0x48, 0x02, 0x98, 0x01, 0x60, 0x21, 0x9e, 0x9e, 0x58, 0xd5, 0x04, 0x10, 0xac, 0x0c, 0x90, 0x9e, 0x58, 0x46, 0x01, 0x9e, 0x59, 0x04, 0x05, 0x19, 0x48, 0x06, 0x96, 0x9e, 0x59, 0x05, 0x05, 0x19, 0x48, 0x02, 0x98, 0x02, 0x60, 0x11, 0x9e, 0x9e, 0x58, 0xd5, 0x04, 0x18, 0xac, 0x1d, 0x90, 0xe8, 0x60, 0x03, 0x68, 0x12, 0x38, 0x46, 0x01, 0x9e, 0x59, 0x06, 0x05, 0x19, 0x48, 0x15, 0x96, 0x9e, 0x59, 0x07, 0x05, 0x19, 0x48, 0x11, 0x98, 0x03, 0x60, 0x0c, 0x61, 0x05, 0x69, 0xea, 0x5d, 
+0x80, 0x1f, 0x20, 0x01, 0x23, 0x59, 0xbe, 0x59, 0x26, 0x01, 0x08, 0x61, 0x05, 0x69, 0x20, 0x01, 0x23, 0x59, 0xbe, 0x59, 0x23, 0x01, 0x5c, 0x11, 0xbe, 0x59, 0x25, 0x01, 0x0c, 0x9e, 0x9e, 0x58, 0xb0, 0x04, 0xbe, 0x58, 0x26, 0x01, 0x9e, 0x58, 0x55, 0x04, 0xbe, 0x58, 0x23, 0x01, 0x9e, 0x58, 0x56, 0x04, 0xbe, 0x58, 0x25, 0x01, 0x00, 0x66, 0x9e, 0x58, 0x15, 0x05, 0x00, 0xac, 0x2c, 0x90, 0x9e, 0x58, 0x46, 0x01, 0x9e, 0x59, 0x16, 0x05, 0x19, 0x48, 0x08, 0x96, 0xe8, 0x60, 0x03, 0x68, 0x12, 0x38, 0x46, 0x01, 0x9e, 0x59, 0x17, 0x05, 0x19, 0x48, 0x1e, 0x98, 0x25, 0x61, 0x02, 0x69, 0x9e, 0x5a, 0x18, 0x05, 0x9e, 0x5b, 0x0b, 0x04, 0x00, 0x67, 0x67, 0x38, 0xba, 0x1f, 0x25, 0x5d, 0xba, 0x48, 0x01, 0x9a, 0x19, 0x07, 0x1a, 0x38, 0x40, 0x61, 0x02, 0x69, 0x9e, 0x5b, 0x0b, 0x04, 0x67, 0x38, 0xd3, 0x84, 
+0xc0, 0x1f, 0xc5, 0x1f, 0x25, 0x5d, 0xba, 0x48, 0x01, 0x9a, 0x19, 0x07, 0x1a, 0x38, 0x9e, 0x58, 0x19, 0x05, 0xf8, 0x48, 0x01, 0x98, 0x01, 0x66, 0xbe, 0x5e, 0x27, 0x01, 0x3a, 0x38, 0x9e, 0x58, 0x0b, 0x04, 0x25, 0x61, 0x02, 0x69, 0x40, 0x62, 0x02, 0x6a, 0x00, 0x63, 0x07, 0x38, 0xdd, 0x1f, 0x25, 0x5d, 0x45, 0x5e, 0xa6, 0x05, 0xbb, 0x48, 0x01, 0x96, 0xa1, 0x5b, 0x1a, 0x38, 0xbe, 0x5b, 0xc0, 0x03, 0x3a, 0x38, 0x00, 0x60, 0xfb, 0xdb, 0xfc, 0xda, 0x59, 0xdc, 0xc0, 0xdb, 0x9c, 0xda, 0x8d, 0xda, 0x75, 0x66, 0x76, 0x67, 0x9e, 0x5b, 0x05, 0x04, 0x00, 0x64, 0x41, 0xda, 0xe8, 0x61, 0x03, 0x69, 0x19, 0x40, 0x9e, 0x5a, 0x05, 0x04, 0x3c, 0x5a, 0xbe, 0x58, 0x45, 0x01, 0x9e, 0x5e, 0x6e, 0x00, 0x9e, 0x5f, 0x72, 0x00, 0x80, 0x63, 0x00, 0x64, 0x41, 0xda, 0x01, 0x5d, 0x38, 0x67, 0x03, 0x6f, 0xa4, 0x16, 
+0x00, 0x20, 0xc7, 0x16, 0xdb, 0x40, 0x05, 0x00, 0xe8, 0x61, 0x03, 0x69, 0x19, 0x40, 0x9e, 0x5a, 0x04, 0x04, 0x3c, 0x5a, 0xbe, 0x58, 0x46, 0x01, 0x9e, 0x58, 0x40, 0x01, 0x64, 0x61, 0x19, 0x48, 0x05, 0x98, 0x00, 0x60, 0xbe, 0x58, 0x45, 0x01, 0xbe, 0x58, 0x46, 0x01, 0x9e, 0x58, 0xab, 0x04, 0x08, 0x58, 0x08, 0x58, 0x09, 0x61, 0x19, 0x48, 0x0a, 0x88, 0xb3, 0x61, 0x02, 0x69, 0x30, 0x39, 0x0a, 0x04, 0x9e, 0x5a, 0x45, 0x01, 0x5d, 0x59, 0x9e, 0x5a, 0x46, 0x01, 0x5d, 0x59, 0x3a, 0x38, 0x9e, 0x58, 0x47, 0x05, 0x19, 0x10, 0x18, 0x3a, 0x2c, 0x21, 0xd8, 0xac, 0xfe, 0x92, 0x9e, 0x58, 0xb1, 0x00, 0x01, 0x61, 0x19, 0x48, 0xf9, 0x88, 0x9e, 0x58, 0x70, 0x00, 0x02, 0x38, 0x38, 0x03, 0x9e, 0x5f, 0x43, 0x01, 0x01, 0x61, 0xf9, 0x48, 0x3c, 0x8a, 0x02, 0x61, 0xf9, 0x48, 0xae, 0x8a, 0x00, 0x3b, 0xa5, 0x5b, 
+0x40, 0x20, 0x25, 0x02, 0x00, 0x3c, 0x40, 0x02, 0x63, 0x5d, 0x83, 0x5e, 0xd0, 0x3e, 0x48, 0x05, 0xbe, 0x48, 0x6f, 0x96, 0x06, 0x62, 0x1b, 0x13, 0x1b, 0x14, 0x00, 0x67, 0x47, 0x38, 0x66, 0x20, 0x25, 0x61, 0x02, 0x69, 0x79, 0x48, 0x11, 0x96, 0x30, 0x39, 0x0b, 0x04, 0x79, 0x48, 0x0d, 0x98, 0x63, 0x5d, 0x83, 0x5e, 0xb0, 0x3d, 0x4a, 0x05, 0xbe, 0x48, 0x08, 0x98, 0x01, 0x61, 0xbe, 0x59, 0x43, 0x01, 0xc5, 0x11, 0xe1, 0x07, 0x5c, 0x07, 0x01, 0x9e, 0x19, 0x02, 0x19, 0x03, 0x19, 0x04, 0x9e, 0x59, 0x43, 0x01, 0x19, 0x11, 0xc1, 0x88, 0x1e, 0x12, 0x08, 0x8a, 0x0f, 0x61, 0x1e, 0x58, 0xf9, 0x40, 0x07, 0x66, 0xc2, 0x12, 0x3c, 0x5a, 0x01, 0x5f, 0x3e, 0x58, 0xbe, 0x5f, 0x44, 0x01, 0x01, 0x9e, 0xb4, 0x9e, 0x9e, 0x5f, 0x44, 0x01, 0x1e, 0x58, 0x00, 0x3b, 0x25, 0x02, 0x00, 0x3c, 0x40, 0x02, 0x88, 0x9a, 
+0x80, 0x20, 0x63, 0x5d, 0x83, 0x5e, 0xa6, 0x15, 0xe8, 0x66, 0x03, 0x6e, 0xbe, 0x48, 0x07, 0x9a, 0x9e, 0x5e, 0x4e, 0x05, 0xdf, 0x40, 0x0a, 0x66, 0x3c, 0x5e, 0x01, 0x5f, 0x12, 0x9e, 0xda, 0x15, 0x9e, 0x5e, 0x4e, 0x05, 0xbe, 0x40, 0x1f, 0x40, 0xb6, 0x65, 0x03, 0x6d, 0x3c, 0x5d, 0x00, 0x61, 0x14, 0x65, 0x3c, 0x5d, 0x01, 0x5e, 0x9e, 0x5c, 0x4e, 0x05, 0x9f, 0x40, 0x14, 0x65, 0x3c, 0x5d, 0x06, 0x07, 0x3e, 0x58, 0xf0, 0x3f, 0x4c, 0x05, 0x00, 0x3c, 0x40, 0x02, 0x1b, 0x14, 0x06, 0x62, 0x47, 0x38, 0xb6, 0x20, 0x40, 0x61, 0x02, 0x69, 0x99, 0x48, 0x09, 0x96, 0x30, 0x39, 0x0b, 0x04, 0x99, 0x48, 0x05, 0x98, 0x83, 0x5d, 0xa7, 0x15, 0x01, 0x8c, 0x00, 0x65, 0xbb, 0x5c, 0x19, 0x04, 0x74, 0x9e, 0x63, 0x5d, 0x83, 0x5e, 0xb0, 0x3d, 0x48, 0x05, 0xdd, 0x48, 0x6e, 0x96, 0x06, 0x62, 0x1b, 0x13, 0xfc, 0x4f, 
+0xc0, 0x20, 0x1b, 0x14, 0x00, 0x67, 0x47, 0x38, 0xdb, 0x20, 0x25, 0x61, 0x02, 0x69, 0x79, 0x48, 0x11, 0x96, 0x30, 0x39, 0x0b, 0x04, 0x79, 0x48, 0x0d, 0x98, 0x63, 0x5d, 0x83, 0x5e, 0xd0, 0x3e, 0x4b, 0x05, 0xdd, 0x48, 0x08, 0x98, 0x02, 0x61, 0xbe, 0x59, 0x43, 0x01, 0xa6, 0x11, 0xe1, 0x07, 0x5c, 0x07, 0x01, 0x9e, 0x19, 0x02, 0x19, 0x03, 0x19, 0x04, 0x9e, 0x59, 0x43, 0x01, 0x1a, 0x11, 0x4c, 0x88, 0x1e, 0x12, 0x08, 0x8a, 0x0f, 0x61, 0x1e, 0x58, 0xf9, 0x40, 0x07, 0x66, 0xc2, 0x12, 0x3c, 0x5a, 0x01, 0x5f, 0x3e, 0x58, 0xbe, 0x5f, 0x44, 0x01, 0x01, 0x9e, 0x74, 0x9e, 0x9e, 0x5f, 0x44, 0x01, 0x1e, 0x58, 0x00, 0x3b, 0x25, 0x02, 0x00, 0x3c, 0x40, 0x02, 0x63, 0x5d, 0x83, 0x5e, 0xc5, 0x15, 0xe8, 0x66, 0x03, 0x6e, 0xbe, 0x48, 0x07, 0x9a, 0x9e, 0x5e, 0x4e, 0x05, 0xdf, 0x40, 0x0a, 0x66, 0x6a, 0x9b, 
+0x00, 0x21, 0x3c, 0x5e, 0x01, 0x5f, 0x12, 0x9e, 0xda, 0x15, 0x9e, 0x5e, 0x4e, 0x05, 0xbe, 0x40, 0x1f, 0x40, 0xb6, 0x65, 0x03, 0x6d, 0x3c, 0x5d, 0x00, 0x61, 0x14, 0x65, 0x3c, 0x5d, 0x01, 0x5e, 0x9e, 0x5c, 0x4e, 0x05, 0x9f, 0x40, 0x14, 0x65, 0x3c, 0x5d, 0x06, 0x07, 0x3e, 0x58, 0xf0, 0x3f, 0x4d, 0x05, 0x00, 0x3c, 0x25, 0x02, 0x1b, 0x14, 0x06, 0x62, 0x47, 0x38, 0x2b, 0x21, 0x25, 0x61, 0x02, 0x69, 0x99, 0x48, 0x09, 0x96, 0x30, 0x39, 0x0b, 0x04, 0x99, 0x48, 0x05, 0x98, 0x83, 0x5d, 0xa7, 0x15, 0x01, 0x8c, 0x00, 0x65, 0xbb, 0x5c, 0x19, 0x04, 0x3a, 0x38, 0x00, 0x61, 0xbe, 0x59, 0x43, 0x01, 0x00, 0x3b, 0x25, 0x02, 0x00, 0x3c, 0x40, 0x02, 0x63, 0x5d, 0x83, 0x5e, 0xd0, 0x3e, 0x49, 0x05, 0xbe, 0x48, 0x7e, 0x97, 0x01, 0x61, 0xbe, 0x59, 0x43, 0x01, 0x06, 0x62, 0x1b, 0x13, 0x1b, 0x14, 0x06, 0x60, 
+0x40, 0x21, 0x00, 0x67, 0x47, 0x38, 0x54, 0x21, 0x25, 0x61, 0x02, 0x69, 0x79, 0x48, 0x0b, 0x96, 0x30, 0x39, 0x0b, 0x04, 0x79, 0x48, 0x07, 0x98, 0x63, 0x5d, 0x83, 0x5e, 0xbe, 0x48, 0x04, 0x98, 0xc5, 0x11, 0xe1, 0x07, 0x01, 0x9e, 0x19, 0x02, 0x19, 0x03, 0x19, 0x04, 0x1e, 0x12, 0x08, 0x8a, 0x0f, 0x61, 0x1e, 0x58, 0xf9, 0x40, 0x07, 0x66, 0xc2, 0x12, 0x3c, 0x5a, 0x01, 0x5f, 0x3e, 0x58, 0xbe, 0x5f, 0x44, 0x01, 0x17, 0x9f, 0x00, 0x61, 0xbe, 0x59, 0x43, 0x01, 0x00, 0x3b, 0x25, 0x02, 0x00, 0x3c, 0x40, 0x02, 0x63, 0x5d, 0x83, 0x5e, 0xb0, 0x3d, 0x49, 0x05, 0xdd, 0x48, 0x98, 0x3d, 0x3f, 0x20, 0x02, 0x61, 0xbe, 0x59, 0x43, 0x01, 0x06, 0x62, 0x1b, 0x13, 0x1b, 0x14, 0x00, 0x67, 0x47, 0x38, 0x8a, 0x21, 0x25, 0x61, 0x02, 0x69, 0x79, 0x48, 0x0b, 0x96, 0x30, 0x39, 0x0b, 0x04, 0x79, 0x48, 0xec, 0x37, 
+0x80, 0x21, 0x07, 0x98, 0x63, 0x5d, 0x83, 0x5e, 0xdd, 0x48, 0x04, 0x98, 0xa6, 0x11, 0xe1, 0x07, 0x01, 0x9e, 0x19, 0x02, 0x19, 0x03, 0x19, 0x04, 0x1e, 0x12, 0x08, 0x8a, 0x0f, 0x61, 0x1e, 0x58, 0xf9, 0x40, 0x07, 0x66, 0xc2, 0x12, 0x3c, 0x5a, 0x01, 0x5f, 0x3e, 0x58, 0xbe, 0x5f, 0x44, 0x01, 0x56, 0x9f, 0x9d, 0xaa, 0x9e, 0x58, 0xa8, 0x04, 0x01, 0x62, 0x1a, 0x48, 0x29, 0x96, 0x9e, 0x58, 0x40, 0x01, 0x9e, 0x5a, 0x56, 0x04, 0x1a, 0x48, 0x23, 0x96, 0x9e, 0x58, 0xa8, 0x04, 0xe8, 0x62, 0x03, 0x6a, 0x52, 0x3a, 0x45, 0x01, 0x58, 0x48, 0x1b, 0x98, 0x25, 0x62, 0x02, 0x6a, 0x50, 0x3a, 0x03, 0x01, 0x50, 0x3a, 0x52, 0x05, 0x43, 0x5b, 0x9e, 0x5c, 0xa9, 0x04, 0x7c, 0x48, 0x10, 0x96, 0x9d, 0xa8, 0x9e, 0x5a, 0xaa, 0x04, 0x5b, 0x40, 0x0a, 0x64, 0x3c, 0x5c, 0x9e, 0x59, 0x23, 0x01, 0x20, 0x01, 0x13, 0xa4, 
+0xc0, 0x21, 0xbe, 0x59, 0x23, 0x01, 0x9e, 0x59, 0x25, 0x01, 0x20, 0x01, 0xbe, 0x59, 0x25, 0x01, 0x3a, 0x38, 0x9e, 0x58, 0x11, 0x01, 0x78, 0xa8, 0xbe, 0x58, 0x11, 0x01, 0x00, 0xac, 0x03, 0x92, 0x00, 0x60, 0x08, 0x68, 0x02, 0x9e, 0xc0, 0x60, 0x08, 0x68, 0xbe, 0x58, 0x10, 0x01, 0x01, 0x60, 0xc6, 0xb0, 0x3a, 0x38, 0x01, 0xb8, 0x41, 0xab, 0x13, 0xb8, 0x14, 0xb8, 0x15, 0xb8, 0x9e, 0x58, 0x32, 0x04, 0x18, 0x30, 0x3f, 0x88, 0x41, 0xa9, 0x45, 0xb0, 0x03, 0x61, 0x01, 0x20, 0x19, 0x48, 0x2d, 0x88, 0x9e, 0x58, 0x12, 0x01, 0x00, 0xac, 0x03, 0x92, 0x00, 0x60, 0x08, 0x68, 0x02, 0x9e, 0xc0, 0x60, 0x08, 0x68, 0xbe, 0x58, 0x15, 0x01, 0x9e, 0x59, 0x13, 0x01, 0x22, 0x38, 0x02, 0x00, 0x1d, 0x96, 0x22, 0x38, 0x40, 0x00, 0x1a, 0x98, 0x00, 0x60, 0xbe, 0x58, 0x14, 0x01, 0xbe, 0x58, 0x16, 0x01, 0x1c, 0x50, 
+0x00, 0x22, 0x9e, 0x5d, 0x13, 0x01, 0x9e, 0x5e, 0x15, 0x01, 0x9e, 0x5f, 0x16, 0x01, 0xe5, 0x40, 0xc0, 0x06, 0x0e, 0x60, 0xe0, 0x07, 0x9e, 0x5c, 0xd2, 0x04, 0x2e, 0xe3, 0x9e, 0x58, 0x16, 0x01, 0x19, 0x00, 0xbe, 0x58, 0x16, 0x01, 0x02, 0x61, 0x19, 0x48, 0xeb, 0x81, 0x9e, 0x58, 0x12, 0x01, 0x19, 0x00, 0xbe, 0x58, 0x12, 0x01, 0xed, 0xed, 0x41, 0xab, 0x95, 0xb8, 0x94, 0xb8, 0x93, 0xb8, 0x81, 0xb8, 0x3a, 0x38, 0x15, 0x60, 0x56, 0x61, 0x2f, 0x38, 0x2b, 0x22, 0x05, 0x5a, 0xfe, 0x5a, 0xff, 0x22, 0x40, 0x3a, 0xb7, 0x01, 0x43, 0x5b, 0x7d, 0x59, 0x9e, 0x58, 0x52, 0x00, 0xc1, 0xb0, 0xc8, 0xe1, 0xd9, 0xe1, 0x0e, 0x60, 0x59, 0x61, 0x2f, 0x38, 0x36, 0x22, 0x05, 0x5a, 0x5d, 0x59, 0x9e, 0x58, 0x53, 0x00, 0xc1, 0xb0, 0xc8, 0xe1, 0xd9, 0xe1, 0x0e, 0x60, 0x5c, 0x61, 0x2f, 0x38, 0x41, 0x22, 0x59, 0xe5, 
+0x40, 0x22, 0x05, 0x5a, 0x5d, 0x59, 0x00, 0x60, 0x59, 0x61, 0x5c, 0x62, 0x15, 0x63, 0x2f, 0x38, 0x54, 0x22, 0x25, 0x5c, 0x45, 0x5d, 0x65, 0x5e, 0x76, 0xac, 0x07, 0x92, 0xa4, 0x16, 0x01, 0x82, 0x85, 0x16, 0x9e, 0x5f, 0x33, 0x04, 0xdf, 0x48, 0x02, 0x82, 0x19, 0x00, 0x5b, 0x9e, 0x1e, 0x58, 0x9e, 0x58, 0x54, 0x00, 0xc1, 0xb0, 0xc8, 0xe1, 0xd9, 0xe1, 0x0e, 0x60, 0x5f, 0x61, 0x2f, 0x38, 0x61, 0x22, 0x05, 0x5a, 0x5d, 0x59, 0x3e, 0x58, 0x00, 0x3f, 0x59, 0x00, 0xe3, 0x59, 0x00, 0x3f, 0x5c, 0x00, 0xe3, 0x5a, 0x00, 0x3f, 0x5f, 0x00, 0xe3, 0x5b, 0x41, 0x14, 0x01, 0x82, 0x22, 0x14, 0x61, 0x15, 0x01, 0x82, 0x23, 0x15, 0x62, 0x16, 0x01, 0x82, 0x43, 0x16, 0xdd, 0x48, 0x05, 0x82, 0x9d, 0x48, 0x25, 0x82, 0x9e, 0x48, 0x23, 0x82, 0x04, 0x9e, 0x9e, 0x48, 0x0c, 0x82, 0x9d, 0x48, 0x0a, 0x82, 0xa0, 0x3e, 
+0x80, 0x22, 0x9e, 0x5a, 0x54, 0x00, 0x9e, 0x5b, 0x55, 0x00, 0xbe, 0x5a, 0x55, 0x00, 0xbe, 0x5b, 0x54, 0x00, 0x0c, 0x60, 0x27, 0x9e, 0x9e, 0x5b, 0x55, 0x00, 0x9e, 0x58, 0x53, 0x00, 0xbe, 0x58, 0x55, 0x00, 0x9e, 0x58, 0x54, 0x00, 0xbe, 0x58, 0x53, 0x00, 0xbe, 0x5b, 0x54, 0x00, 0x5c, 0x62, 0x5f, 0x63, 0x2f, 0x38, 0x9b, 0x22, 0x65, 0x5c, 0x9d, 0x5a, 0x1f, 0x60, 0x13, 0x9e, 0x9e, 0x5b, 0x55, 0x00, 0x9e, 0x58, 0x52, 0x00, 0xbe, 0x58, 0x55, 0x00, 0x9e, 0x58, 0x54, 0x00, 0xbe, 0x58, 0x52, 0x00, 0xbe, 0x5b, 0x54, 0x00, 0x59, 0x61, 0x5f, 0x63, 0x2f, 0x38, 0xaf, 0x22, 0x65, 0x5c, 0x9d, 0x59, 0x17, 0x60, 0x56, 0x60, 0x59, 0x61, 0x5c, 0x62, 0x2f, 0x38, 0xe6, 0x22, 0x05, 0x5b, 0x25, 0x5c, 0x45, 0x5d, 0xa4, 0x16, 0x01, 0x82, 0x85, 0x16, 0x9e, 0x5f, 0x34, 0x04, 0xfe, 0x48, 0x22, 0x82, 0xe6, 0x43, 
+0xc0, 0x22, 0x9b, 0x48, 0x02, 0x82, 0x64, 0x16, 0x01, 0x9e, 0x83, 0x16, 0xbb, 0x48, 0x02, 0x82, 0x65, 0x17, 0x01, 0x9e, 0xa3, 0x17, 0xdf, 0x48, 0x0b, 0x82, 0x9e, 0x5b, 0x36, 0x04, 0xdb, 0x48, 0x12, 0x82, 0x9e, 0x5b, 0x35, 0x04, 0x7f, 0x48, 0x0e, 0x82, 0x1e, 0x5c, 0x01, 0x63, 0x0f, 0x9e, 0x9e, 0x5b, 0x36, 0x04, 0xfb, 0x48, 0x07, 0x82, 0x9e, 0x5b, 0x35, 0x04, 0x7e, 0x48, 0x03, 0x82, 0x1e, 0x5d, 0x01, 0x63, 0x04, 0x9e, 0xa4, 0x05, 0xa8, 0x5d, 0x1e, 0x5d, 0x00, 0x63, 0x1e, 0x5b, 0x01, 0x60, 0x00, 0x39, 0x0e, 0x00, 0x00, 0x3a, 0x4f, 0x00, 0x07, 0x38, 0xf1, 0x22, 0x3e, 0x5b, 0x7f, 0x5a, 0x3e, 0x5b, 0x7f, 0x59, 0x27, 0x9f, 0x01, 0xb8, 0x41, 0xab, 0x13, 0xb8, 0x14, 0xb8, 0x15, 0xb8, 0x00, 0x60, 0xbe, 0x58, 0x18, 0x01, 0x9e, 0x5d, 0xd3, 0x04, 0x80, 0x66, 0x09, 0x6e, 0x9e, 0x5f, 0xfc, 0x12, 
+0x00, 0x23, 0x18, 0x01, 0xe5, 0x40, 0xc0, 0x06, 0x00, 0x64, 0x19, 0x61, 0x01, 0x69, 0x25, 0x02, 0xc3, 0x58, 0x1b, 0x59, 0x80, 0x04, 0x19, 0x06, 0x19, 0x01, 0x3a, 0x48, 0xf9, 0x81, 0x18, 0x04, 0x10, 0x8a, 0x18, 0x00, 0x0e, 0x8a, 0x19, 0x66, 0x01, 0x6e, 0xb7, 0x60, 0x01, 0x68, 0xe0, 0x07, 0x9e, 0x5c, 0xd4, 0x04, 0x2e, 0xe3, 0xe3, 0x58, 0x00, 0x61, 0x9e, 0x5c, 0xd3, 0x04, 0x1c, 0x5c, 0x1b, 0x5f, 0x9e, 0x5f, 0x18, 0x01, 0x19, 0x07, 0xbe, 0x5f, 0x18, 0x01, 0x36, 0x61, 0xf9, 0x48, 0xd3, 0x81, 0x41, 0xab, 0x95, 0xb8, 0x94, 0xb8, 0x93, 0xb8, 0x81, 0xb8, 0x3a, 0x38, 0xff, 0x60, 0x80, 0x24, 0x01, 0x60, 0x98, 0x48, 0x3f, 0x8a, 0x02, 0x60, 0x98, 0x48, 0x44, 0x8a, 0x03, 0x60, 0x98, 0x48, 0x52, 0x8a, 0x04, 0x60, 0x98, 0x48, 0x54, 0x8a, 0x05, 0x60, 0x98, 0x48, 0x56, 0x8a, 0x06, 0x60, 0x54, 0x9a, 
+0x40, 0x23, 0x98, 0x48, 0x78, 0x8a, 0x07, 0x60, 0x98, 0x48, 0x81, 0x8a, 0x08, 0x60, 0x98, 0x48, 0x8e, 0x8a, 0x09, 0x60, 0x98, 0x48, 0x97, 0x8a, 0x0a, 0x60, 0x98, 0x48, 0xa6, 0x8a, 0x0b, 0x60, 0x98, 0x48, 0x98, 0x3a, 0x93, 0x24, 0x0c, 0x60, 0x98, 0x48, 0x98, 0x3a, 0x97, 0x24, 0x1b, 0x9e, 0x3a, 0x38, 0xc1, 0x59, 0xc3, 0x5a, 0xc1, 0x5b, 0xc3, 0x5c, 0x1e, 0x5e, 0xa2, 0x38, 0x01, 0x00, 0x07, 0x38, 0x6c, 0x23, 0xc3, 0x58, 0x1c, 0x48, 0x06, 0x80, 0x58, 0x48, 0x01, 0x80, 0x05, 0x9e, 0xc1, 0x59, 0x01, 0x5a, 0x02, 0x9e, 0xc1, 0x5b, 0x01, 0x5c, 0x19, 0x06, 0x3b, 0x48, 0x01, 0x88, 0x19, 0x01, 0x3e, 0x5e, 0x3a, 0x38, 0x00, 0x61, 0x00, 0x60, 0x01, 0x63, 0x19, 0x15, 0xb7, 0x38, 0x66, 0x4a, 0x1b, 0x5f, 0xdd, 0x9f, 0x02, 0x60, 0xb8, 0x48, 0xf5, 0x8b, 0x58, 0xe3, 0x00, 0x60, 0x1b, 0x59, 0x50, 0x93, 
+0x80, 0x23, 0x1b, 0x5b, 0x00, 0x61, 0x00, 0x60, 0xa1, 0x5b, 0x19, 0x15, 0xb7, 0x38, 0x66, 0x4a, 0x19, 0x15, 0x1c, 0x5d, 0x1b, 0x5f, 0xcc, 0x9f, 0x58, 0xe3, 0x23, 0x58, 0x05, 0x40, 0x1b, 0x5f, 0xc7, 0x9f, 0x58, 0xe3, 0x63, 0x58, 0x05, 0x40, 0x1b, 0x5f, 0xc2, 0x9f, 0x02, 0x60, 0xb8, 0x48, 0xda, 0x8b, 0x02, 0x9e, 0x00, 0x60, 0x1b, 0x5b, 0xa5, 0xe3, 0xa2, 0x38, 0x01, 0x00, 0x08, 0x58, 0x58, 0x48, 0xf8, 0x81, 0x63, 0x58, 0x05, 0x40, 0x1b, 0x5f, 0xb2, 0x9f, 0xc1, 0x59, 0x00, 0x62, 0xc1, 0x5b, 0xff, 0x64, 0xff, 0x6c, 0xa2, 0x38, 0x01, 0x00, 0x07, 0x38, 0xb8, 0x23, 0x23, 0x58, 0x18, 0x00, 0x06, 0x8a, 0x1c, 0x48, 0x01, 0x80, 0x04, 0x9e, 0x21, 0x5b, 0x01, 0x5c, 0x01, 0x9e, 0x19, 0x02, 0x19, 0x01, 0x3a, 0x38, 0x58, 0xe3, 0x00, 0x62, 0x5b, 0x59, 0x00, 0x61, 0x00, 0x60, 0xa1, 0x5b, 0x3a, 0x0f, 
+0xc0, 0x23, 0x19, 0x15, 0xb7, 0x38, 0x66, 0x4a, 0x1c, 0x5d, 0x1b, 0x5f, 0x91, 0x9f, 0x58, 0xe3, 0x00, 0x62, 0x5b, 0x59, 0x58, 0xe3, 0x00, 0x62, 0x5b, 0x59, 0x00, 0x61, 0x00, 0x60, 0xa1, 0x5b, 0x19, 0x15, 0xb7, 0x38, 0x66, 0x4a, 0x19, 0x15, 0x1c, 0x5d, 0x1b, 0x5f, 0x81, 0x9f, 0x58, 0xe3, 0x00, 0x64, 0x9b, 0x5b, 0x00, 0x61, 0x00, 0x60, 0xa1, 0x5b, 0x19, 0x15, 0xb7, 0x38, 0x66, 0x4a, 0x1c, 0x5d, 0x1b, 0x5f, 0x75, 0x9f, 0x58, 0xe3, 0xff, 0x64, 0xff, 0x6c, 0x9b, 0x5b, 0x58, 0xe3, 0x00, 0x64, 0x9b, 0x59, 0x9b, 0x5b, 0x00, 0x61, 0x00, 0x60, 0xa1, 0x5b, 0x19, 0x15, 0xb7, 0x38, 0x66, 0x4a, 0x19, 0x15, 0x1c, 0x5d, 0x1b, 0x5f, 0x63, 0x9f, 0x01, 0x60, 0xbe, 0x58, 0xc9, 0x03, 0xbe, 0x5d, 0xc1, 0x03, 0xa1, 0x5c, 0x19, 0x14, 0xc1, 0x5b, 0x00, 0x60, 0x00, 0x61, 0xbe, 0x58, 0xc8, 0x03, 0x53, 0x69, 
+0x00, 0x24, 0x87, 0x38, 0x0c, 0x24, 0x70, 0x00, 0x18, 0x09, 0x63, 0x5a, 0x18, 0x02, 0x05, 0x88, 0x9e, 0x5a, 0xc8, 0x03, 0x19, 0x02, 0xbe, 0x5a, 0xc8, 0x03, 0x19, 0x03, 0xbe, 0x58, 0xc2, 0x03, 0xbe, 0x59, 0xc3, 0x03, 0x00, 0x60, 0x9e, 0x59, 0xc8, 0x03, 0x9e, 0x5a, 0xc1, 0x03, 0x3a, 0x48, 0x43, 0x8a, 0x52, 0x3a, 0xc8, 0x03, 0xbe, 0x5a, 0xc1, 0x03, 0x9e, 0x58, 0xc2, 0x03, 0x9e, 0x59, 0xc3, 0x03, 0x9e, 0x5a, 0xc1, 0x03, 0x1c, 0x5a, 0xbe, 0x58, 0xc4, 0x03, 0x63, 0xe4, 0x9e, 0x58, 0xc5, 0x03, 0x9e, 0x59, 0xdf, 0x04, 0x19, 0x48, 0x21, 0x80, 0xc1, 0x5a, 0x50, 0x3a, 0xc6, 0x03, 0x43, 0x5b, 0x9e, 0x58, 0xc2, 0x03, 0x9e, 0x59, 0xc3, 0x03, 0x03, 0x10, 0x18, 0x19, 0xbe, 0x58, 0xc2, 0x03, 0xbe, 0x59, 0xc3, 0x03, 0xff, 0x61, 0xff, 0x69, 0x3b, 0x5a, 0x9e, 0x58, 0xc1, 0x03, 0x19, 0x10, 0x78, 0xcf, 
+0x40, 0x24, 0xbe, 0x58, 0xc1, 0x03, 0x9e, 0x59, 0xe0, 0x04, 0x19, 0x48, 0xd6, 0x95, 0xbe, 0x59, 0xc1, 0x03, 0x9e, 0x58, 0xc9, 0x03, 0x00, 0xac, 0x01, 0x90, 0xe3, 0xa8, 0x9e, 0x58, 0xc2, 0x03, 0x9e, 0x59, 0xc3, 0x03, 0x9e, 0x5a, 0xc1, 0x03, 0x26, 0x3b, 0x00, 0x00, 0x03, 0x8a, 0x1c, 0x5a, 0x05, 0x40, 0x02, 0x9e, 0x05, 0x40, 0x1c, 0x5a, 0xbe, 0x58, 0xc2, 0x03, 0x1b, 0x5f, 0x00, 0x60, 0xbe, 0x58, 0xc3, 0x03, 0x98, 0x3f, 0x57, 0x23, 0x00, 0x60, 0xbe, 0x58, 0xc5, 0x03, 0xbe, 0x58, 0xc0, 0x03, 0xff, 0x60, 0xbe, 0x58, 0xc6, 0x03, 0xff, 0x64, 0xff, 0x6c, 0xc1, 0x5a, 0xa1, 0x58, 0x19, 0x10, 0x07, 0x38, 0x91, 0x24, 0x45, 0x59, 0x26, 0x3c, 0xff, 0xff, 0x16, 0x8a, 0x26, 0x3c, 0x00, 0x00, 0x13, 0x8a, 0x9e, 0x58, 0xc4, 0x03, 0x38, 0x48, 0x02, 0x82, 0x01, 0x10, 0x01, 0x9e, 0x20, 0x10, 0x9a, 0x79, 
+0x80, 0x24, 0xbe, 0x58, 0xc7, 0x03, 0x9e, 0x59, 0xc5, 0x03, 0x19, 0x48, 0x06, 0x9c, 0xbe, 0x58, 0xc5, 0x03, 0x9e, 0x58, 0xc0, 0x03, 0xbe, 0x58, 0xc6, 0x03, 0x9e, 0x58, 0xc0, 0x03, 0x19, 0x00, 0xbe, 0x58, 0xc0, 0x03, 0x1a, 0x38, 0x3a, 0x38, 0x00, 0x60, 0xbe, 0x58, 0xc9, 0x03, 0x60, 0x9f, 0xc5, 0x5a, 0x41, 0x58, 0x00, 0x64, 0x1a, 0x15, 0xa7, 0x38, 0xa9, 0x24, 0xc5, 0x5b, 0x03, 0x00, 0x02, 0x80, 0xff, 0x60, 0xff, 0x68, 0x43, 0x12, 0x01, 0x8c, 0x42, 0x5a, 0x82, 0x04, 0x02, 0x80, 0xff, 0x64, 0xff, 0x6c, 0x61, 0x5a, 0x1a, 0x05, 0x1b, 0x5f, 0x9e, 0x58, 0xdf, 0x04, 0x05, 0x40, 0x98, 0x48, 0x01, 0x80, 0xe3, 0xa8, 0x98, 0x3f, 0x57, 0x23, 0x9e, 0x59, 0xb1, 0x04, 0x22, 0x38, 0x01, 0x00, 0xbb, 0x88, 0xee, 0x60, 0x01, 0x68, 0xb7, 0x61, 0x01, 0x69, 0x93, 0x62, 0x02, 0x6a, 0x80, 0x63, 0xc8, 0xee, 
+0xc0, 0x24, 0x01, 0x6b, 0x00, 0x64, 0xaf, 0x3e, 0xc7, 0x24, 0x9d, 0x58, 0x9d, 0x59, 0x9d, 0x5a, 0x9d, 0x5b, 0x11, 0xc4, 0x73, 0xe8, 0x00, 0x60, 0x70, 0x68, 0x00, 0x61, 0x19, 0x10, 0x19, 0x48, 0xfd, 0x89, 0x73, 0xe8, 0x00, 0x60, 0x0a, 0x78, 0x40, 0x60, 0x3d, 0x68, 0xbe, 0x58, 0xc0, 0x03, 0xee, 0x60, 0x01, 0x68, 0xbe, 0x58, 0xc1, 0x03, 0x11, 0xc4, 0x0a, 0x70, 0x9e, 0x5f, 0xc0, 0x03, 0x07, 0x00, 0x15, 0x63, 0x2f, 0x38, 0xe8, 0x24, 0x0b, 0x59, 0x06, 0x3a, 0xc0, 0x3c, 0x01, 0x88, 0x19, 0x00, 0x3d, 0x5b, 0x07, 0x10, 0x0a, 0x78, 0xff, 0x60, 0x03, 0x68, 0xc3, 0xb0, 0x45, 0xb0, 0x28, 0xa8, 0xc5, 0xb0, 0x15, 0x70, 0xff, 0x20, 0x05, 0x38, 0x00, 0xff, 0x16, 0x71, 0xff, 0x21, 0x25, 0x39, 0x00, 0xff, 0xca, 0xb0, 0xc9, 0xb1, 0x2b, 0xe8, 0x00, 0x60, 0x20, 0x68, 0x0b, 0x78, 0x00, 0x60, 0xcc, 0x16, 
+0x00, 0x25, 0x40, 0x68, 0x11, 0x78, 0x9e, 0x58, 0x91, 0x04, 0x0d, 0x78, 0x0c, 0x78, 0x15, 0x60, 0x16, 0x61, 0x03, 0x58, 0x23, 0x59, 0xfe, 0x58, 0xfe, 0x59, 0xff, 0x20, 0xff, 0x21, 0x01, 0x5e, 0x21, 0x5f, 0x53, 0xdc, 0x02, 0x39, 0x1b, 0x00, 0x08, 0x88, 0xde, 0x16, 0x06, 0x94, 0xde, 0x17, 0x04, 0x94, 0x9e, 0x58, 0x54, 0x05, 0x0d, 0x78, 0x0c, 0x78, 0xaf, 0x39, 0x34, 0x25, 0x5a, 0xe8, 0xc8, 0xe1, 0x9e, 0x58, 0x11, 0x01, 0x78, 0xac, 0xfc, 0x93, 0xd9, 0xe1, 0x0b, 0x73, 0x0c, 0x74, 0x0d, 0x75, 0x11, 0x76, 0x0e, 0x77, 0xfc, 0x48, 0x03, 0x82, 0xc3, 0x16, 0x11, 0x7e, 0x04, 0x9e, 0xfd, 0x48, 0x02, 0x80, 0xc3, 0x06, 0x11, 0x7e, 0x68, 0x5b, 0x0b, 0x7b, 0x15, 0x60, 0x11, 0x61, 0x0e, 0x62, 0x03, 0x5b, 0x73, 0xac, 0x06, 0x92, 0xfe, 0x5b, 0xff, 0x23, 0x70, 0x3c, 0xc1, 0x03, 0x23, 0x5e, 0xb1, 0xa5, 
+0x40, 0x25, 0xdb, 0x5c, 0x15, 0x70, 0x78, 0xac, 0x97, 0x91, 0x9e, 0x58, 0xc0, 0x03, 0x40, 0x61, 0x3d, 0x69, 0x19, 0x48, 0x0b, 0x88, 0x00, 0x61, 0x0a, 0x79, 0x80, 0x61, 0x3c, 0x69, 0xbe, 0x59, 0xc0, 0x03, 0xb7, 0x61, 0x01, 0x69, 0xbe, 0x59, 0xc1, 0x03, 0x86, 0x9f, 0x80, 0x61, 0x3c, 0x69, 0x19, 0x48, 0x0b, 0x88, 0x00, 0x61, 0x0a, 0x79, 0x40, 0x61, 0x3c, 0x69, 0xbe, 0x59, 0xc0, 0x03, 0x93, 0x61, 0x02, 0x69, 0xbe, 0x59, 0xc1, 0x03, 0x77, 0x9f, 0x40, 0x61, 0x3c, 0x69, 0x19, 0x48, 0x0b, 0x88, 0x00, 0x61, 0x0a, 0x79, 0x00, 0x61, 0x3c, 0x69, 0xbe, 0x59, 0xc0, 0x03, 0x80, 0x61, 0x01, 0x69, 0xbe, 0x59, 0xc1, 0x03, 0x68, 0x9f, 0xda, 0x9e, 0x11, 0xc4, 0xed, 0xaa, 0x73, 0xe8, 0x00, 0x60, 0x70, 0x68, 0x00, 0x61, 0x19, 0x10, 0x19, 0x48, 0xfd, 0x89, 0x73, 0xe8, 0x9e, 0x5f, 0x91, 0x04, 0x06, 0x08, 
+0x80, 0x25, 0x0c, 0x7f, 0x9e, 0x5f, 0x91, 0x04, 0x0d, 0x7f, 0x00, 0x60, 0x0a, 0x78, 0xcf, 0xea, 0x2b, 0xe8, 0x00, 0x60, 0x20, 0x68, 0x0b, 0x78, 0x00, 0x60, 0x40, 0x68, 0x11, 0x78, 0x00, 0x60, 0x40, 0x68, 0x12, 0x78, 0x00, 0x60, 0x40, 0x68, 0x13, 0x78, 0xaf, 0x39, 0xf9, 0x25, 0x5a, 0xe8, 0xc8, 0xe1, 0x9e, 0x58, 0x11, 0x01, 0x78, 0xac, 0xfc, 0x93, 0xd9, 0xe1, 0x0b, 0x73, 0x0c, 0x74, 0x0d, 0x75, 0x9e, 0x5e, 0x01, 0x04, 0x18, 0x36, 0x0d, 0x8a, 0x9e, 0x5e, 0x03, 0x01, 0x9e, 0x5f, 0x04, 0x01, 0xdf, 0x48, 0x03, 0x8a, 0x7b, 0x06, 0xfe, 0x48, 0x04, 0x96, 0x9e, 0x5c, 0xc4, 0x04, 0x9e, 0x5d, 0xc4, 0x04, 0x11, 0x76, 0x0e, 0x77, 0xfc, 0x48, 0x03, 0x82, 0xc3, 0x16, 0x11, 0x7e, 0x04, 0x9e, 0xfd, 0x48, 0x02, 0x80, 0xc3, 0x06, 0x11, 0x7e, 0x0c, 0x74, 0x0d, 0x75, 0x9e, 0x5e, 0x01, 0x04, 0x82, 0x19, 
+0xc0, 0x25, 0x18, 0x36, 0x0d, 0x8a, 0x9e, 0x5e, 0x03, 0x01, 0x9e, 0x5f, 0x05, 0x01, 0xdf, 0x48, 0x03, 0x8a, 0x7b, 0x06, 0xfe, 0x48, 0x04, 0x96, 0x9e, 0x5c, 0xc4, 0x04, 0x9e, 0x5d, 0xc4, 0x04, 0x12, 0x76, 0x0f, 0x77, 0xfc, 0x48, 0x03, 0x82, 0xc3, 0x16, 0x12, 0x7e, 0x04, 0x9e, 0xfd, 0x48, 0x02, 0x80, 0xc3, 0x06, 0x12, 0x7e, 0x0c, 0x74, 0x0d, 0x75, 0x9e, 0x5e, 0x01, 0x04, 0x18, 0x36, 0x0d, 0x8a, 0x9e, 0x5e, 0x03, 0x01, 0x9e, 0x5f, 0x06, 0x01, 0xdf, 0x48, 0x03, 0x8a, 0x7b, 0x06, 0xfe, 0x48, 0x04, 0x96, 0x9e, 0x5c, 0xc4, 0x04, 0x9e, 0x5d, 0xc4, 0x04, 0x13, 0x76, 0x10, 0x77, 0xfc, 0x48, 0x03, 0x82, 0xc3, 0x16, 0x13, 0x7e, 0x04, 0x9e, 0xfd, 0x48, 0x02, 0x80, 0xc3, 0x06, 0x13, 0x7e, 0x68, 0x5b, 0x0b, 0x7b, 0x15, 0x60, 0x11, 0x61, 0x0e, 0x62, 0x2f, 0x38, 0x10, 0x26, 0x05, 0x5b, 0x1a, 0x8f, 
+0x00, 0x26, 0x73, 0xac, 0x0d, 0x92, 0xfe, 0x5b, 0xff, 0x23, 0x60, 0x3c, 0x80, 0x01, 0x60, 0x3d, 0xb7, 0x01, 0x23, 0x5e, 0x43, 0x5f, 0xdb, 0x5c, 0xfb, 0x5d, 0x60, 0x3d, 0xee, 0x01, 0xfb, 0x5d, 0x19, 0x01, 0x19, 0x02, 0x15, 0x70, 0x78, 0xac, 0x72, 0x91, 0xa1, 0xaa, 0x9e, 0x58, 0x38, 0x05, 0x18, 0x30, 0x35, 0x8a, 0x62, 0xe6, 0xb7, 0x61, 0x01, 0x69, 0x9e, 0x5b, 0x0b, 0x04, 0x9e, 0x5c, 0x02, 0x04, 0x64, 0x03, 0x9e, 0x5c, 0x01, 0x04, 0x64, 0x03, 0x9e, 0x5a, 0x39, 0x05, 0x9e, 0x5e, 0x3a, 0x05, 0x9e, 0x5f, 0x03, 0x01, 0x9e, 0x58, 0x01, 0x04, 0x18, 0x30, 0x01, 0x88, 0xff, 0x67, 0x00, 0x60, 0x67, 0x38, 0x3c, 0x26, 0x1f, 0x48, 0x07, 0x8a, 0x23, 0x5d, 0xba, 0x48, 0x01, 0x98, 0x15, 0x9e, 0xbe, 0x48, 0x01, 0x96, 0x12, 0x9e, 0x19, 0x00, 0x19, 0x01, 0xb7, 0x61, 0x01, 0x69, 0x7b, 0x01, 0xb1, 0x1b, 
+0x40, 0x26, 0x9e, 0x5b, 0x0b, 0x04, 0x67, 0x38, 0x4b, 0x26, 0x25, 0x5d, 0xba, 0x48, 0x01, 0x98, 0x05, 0x9e, 0xbe, 0x48, 0x01, 0x96, 0x02, 0x9e, 0x1a, 0x38, 0x01, 0x9e, 0xa1, 0xa8, 0x31, 0xb0, 0x04, 0x38, 0x00, 0x60, 0x05, 0x38, 0x43, 0x00, 0x9e, 0x59, 0x9d, 0x04, 0x1b, 0x21, 0x7f, 0x38, 0x26, 0x59, 0x01, 0x28, 0xb1, 0xb0, 0x00, 0x60, 0xc0, 0xb0, 0x41, 0xab, 0x94, 0xab, 0x9c, 0xab, 0xa4, 0xab, 0xe4, 0xaa, 0x3a, 0x38, 0x00, 0x60, 0x0a, 0x78, 0xcf, 0xea, 0x2b, 0xe8, 0xad, 0xe8, 0x5a, 0xe8, 0xc8, 0xe1, 0x9e, 0x58, 0x11, 0x01, 0x78, 0xac, 0xfc, 0x93, 0xd9, 0xe1, 0x15, 0x60, 0x0e, 0x61, 0x2f, 0x38, 0x7b, 0x26, 0x05, 0x5a, 0x72, 0xac, 0x06, 0x92, 0xfe, 0x5a, 0xff, 0x22, 0x40, 0x3a, 0xb7, 0x01, 0x23, 0x5b, 0x7b, 0x5a, 0x19, 0x01, 0x15, 0x70, 0x78, 0xac, 0xe5, 0x91, 0x3a, 0x38, 0x8a, 0xb1, 
+0x80, 0x26, 0x11, 0xc4, 0x73, 0xe8, 0x00, 0x60, 0x70, 0x68, 0x00, 0x61, 0x19, 0x10, 0x19, 0x48, 0xfd, 0x89, 0x73, 0xe8, 0x9e, 0x5f, 0x91, 0x04, 0x0c, 0x7f, 0x9e, 0x5f, 0x91, 0x04, 0x0d, 0x7f, 0x00, 0x60, 0x0a, 0x78, 0xcf, 0xea, 0x9e, 0x59, 0x15, 0x00, 0x9e, 0x5a, 0x16, 0x00, 0x9e, 0x5b, 0x17, 0x00, 0x9e, 0x5d, 0xe2, 0x00, 0x19, 0x15, 0x6f, 0x64, 0x03, 0x6c, 0x00, 0x67, 0xa7, 0x38, 0xdd, 0x26, 0x85, 0x5e, 0x07, 0xac, 0x12, 0x92, 0x24, 0x39, 0x00, 0x3f, 0xff, 0x38, 0x28, 0x59, 0xd9, 0x48, 0x06, 0x8a, 0x9e, 0x59, 0x15, 0x00, 0x71, 0xa8, 0xbe, 0x59, 0x15, 0x00, 0x06, 0x9e, 0x9e, 0x59, 0x15, 0x00, 0x71, 0xaa, 0xbe, 0x59, 0x15, 0x00, 0x07, 0xa8, 0x0f, 0xac, 0x12, 0x92, 0x44, 0x3a, 0x00, 0x3f, 0xff, 0x38, 0x48, 0x5a, 0xda, 0x48, 0x06, 0x8a, 0x9e, 0x5a, 0x16, 0x00, 0x72, 0xa8, 0x86, 0x05, 
+0xc0, 0x26, 0xbe, 0x5a, 0x16, 0x00, 0x06, 0x9e, 0x9e, 0x5a, 0x16, 0x00, 0x72, 0xaa, 0xbe, 0x5a, 0x16, 0x00, 0x0f, 0xa8, 0x17, 0xac, 0x12, 0x92, 0x64, 0x3b, 0x00, 0x3f, 0xff, 0x38, 0x68, 0x5b, 0xdb, 0x48, 0x06, 0x8a, 0x9e, 0x5b, 0x17, 0x00, 0x73, 0xa8, 0xbe, 0x5b, 0x17, 0x00, 0x06, 0x9e, 0x9e, 0x5b, 0x17, 0x00, 0x73, 0xaa, 0xbe, 0x5b, 0x17, 0x00, 0x17, 0xa8, 0x1a, 0x38, 0x00, 0x60, 0xf8, 0x48, 0x53, 0x8a, 0x2b, 0xe8, 0x00, 0x60, 0x20, 0x68, 0x0b, 0x78, 0x00, 0x60, 0x40, 0x68, 0x11, 0x78, 0x00, 0x60, 0x40, 0x68, 0x12, 0x78, 0x00, 0x60, 0x40, 0x68, 0x13, 0x78, 0xaf, 0x39, 0x1d, 0x27, 0x5a, 0xe8, 0xd9, 0xe1, 0x0b, 0x73, 0x0c, 0x74, 0x0d, 0x75, 0x9e, 0x58, 0x15, 0x00, 0x9e, 0x59, 0x16, 0x00, 0x9e, 0x5a, 0x17, 0x00, 0x11, 0x76, 0x0e, 0x77, 0xfc, 0x48, 0x03, 0x82, 0xc3, 0x16, 0x60, 0x07, 
+0x00, 0x27, 0x11, 0x7e, 0x04, 0x9e, 0xfd, 0x48, 0x02, 0x80, 0xc3, 0x06, 0x11, 0x7e, 0x12, 0x76, 0x0f, 0x77, 0xfc, 0x48, 0x03, 0x82, 0xc3, 0x16, 0x12, 0x7e, 0x04, 0x9e, 0xfd, 0x48, 0x02, 0x80, 0xc3, 0x06, 0x12, 0x7e, 0x13, 0x76, 0x10, 0x77, 0xfc, 0x48, 0x03, 0x82, 0xc3, 0x16, 0x13, 0x7e, 0x04, 0x9e, 0xfd, 0x48, 0x02, 0x80, 0xc3, 0x06, 0x13, 0x7e, 0x68, 0x5b, 0x0b, 0x7b, 0x15, 0x60, 0x11, 0x61, 0x0e, 0x62, 0x2f, 0x38, 0x33, 0x27, 0x05, 0x5b, 0x73, 0xac, 0x0b, 0x92, 0xfe, 0x5b, 0xff, 0x23, 0x60, 0x3c, 0x80, 0x01, 0x60, 0x3d, 0xb7, 0x01, 0x23, 0x5e, 0x43, 0x5f, 0xc8, 0x3c, 0x00, 0x00, 0xfb, 0x5d, 0x19, 0x01, 0x19, 0x02, 0x1a, 0x38, 0x15, 0x70, 0x78, 0xac, 0x5a, 0x91, 0x31, 0xb0, 0x04, 0x38, 0x00, 0x60, 0x05, 0x38, 0x43, 0x00, 0x9e, 0x59, 0x9d, 0x04, 0x1b, 0x21, 0x7f, 0x38, 0xb4, 0x6b, 
+0x40, 0x27, 0x26, 0x59, 0x01, 0x28, 0xb1, 0xb0, 0x00, 0x60, 0xc0, 0xb0, 0x41, 0xab, 0x94, 0xab, 0x9c, 0xab, 0xa4, 0xab, 0x3a, 0x38, 0xcc, 0xaa, 0x41, 0xa9, 0x73, 0xe8, 0x00, 0x60, 0x0a, 0x78, 0xc4, 0xaa, 0x08, 0x70, 0x3a, 0x10, 0x01, 0x80, 0xc4, 0xa8, 0xc4, 0xac, 0x0a, 0x90, 0x09, 0x70, 0x19, 0x00, 0x09, 0x78, 0x12, 0x38, 0xf6, 0x00, 0x03, 0x80, 0x00, 0x60, 0x09, 0x78, 0x01, 0x9e, 0xc4, 0xaa, 0x1d, 0xe9, 0x00, 0x64, 0x9e, 0x5d, 0xfd, 0x00, 0x9d, 0x48, 0x14, 0x8a, 0x6f, 0x67, 0x03, 0x6f, 0x9e, 0x5a, 0xde, 0x04, 0x47, 0x38, 0x70, 0x27, 0xe3, 0x5b, 0x9e, 0x59, 0xcb, 0x04, 0x79, 0x40, 0x1d, 0x5f, 0x8a, 0x67, 0x03, 0x6f, 0x47, 0x38, 0x79, 0x27, 0xe3, 0x5b, 0x9e, 0x59, 0xcb, 0x04, 0x79, 0x40, 0x1d, 0x5f, 0xe5, 0xeb, 0x0a, 0xee, 0x17, 0xe8, 0xed, 0xa8, 0xe4, 0xa8, 0xcc, 0xac, 0x10, 0x76, 
+0x80, 0x27, 0x01, 0x90, 0xe4, 0xaa, 0x3a, 0x38, 0xa6, 0xe8, 0xc4, 0xac, 0x35, 0x90, 0x85, 0xac, 0x33, 0x92, 0x8d, 0xac, 0x31, 0x92, 0x95, 0xac, 0x2f, 0x92, 0x9d, 0xac, 0x2d, 0x92, 0xec, 0xac, 0x2b, 0x92, 0xdc, 0xe7, 0x02, 0x60, 0x10, 0x38, 0x6c, 0x00, 0x12, 0x38, 0x4b, 0x00, 0x1b, 0x80, 0x9e, 0x58, 0x6c, 0x00, 0x1a, 0x10, 0x12, 0x38, 0x4b, 0x00, 0x1e, 0x80, 0x9e, 0x59, 0xb6, 0x04, 0x00, 0x62, 0x3a, 0x48, 0x02, 0x88, 0x4c, 0x70, 0x06, 0x9e, 0x1a, 0x00, 0x08, 0x58, 0x01, 0x61, 0x19, 0x48, 0x01, 0x94, 0x01, 0x60, 0x9e, 0x59, 0x6c, 0x00, 0x20, 0x11, 0x01, 0x82, 0x00, 0x61, 0xbe, 0x59, 0x6c, 0x00, 0x09, 0x9e, 0x9e, 0x58, 0x6c, 0x00, 0x10, 0x38, 0x4c, 0x00, 0x02, 0x88, 0x12, 0x38, 0x4c, 0x00, 0xbe, 0x58, 0x6c, 0x00, 0x9e, 0x58, 0x4b, 0x00, 0x9e, 0x59, 0x6c, 0x00, 0x18, 0x01, 0x43, 0x8e, 
+0xc0, 0x27, 0x1a, 0x38, 0x01, 0x10, 0x01, 0x82, 0x00, 0x60, 0x9e, 0x5a, 0xd1, 0x00, 0x55, 0x3a, 0xb1, 0x00, 0x18, 0x32, 0x03, 0x8a, 0x00, 0x62, 0xbe, 0x5a, 0x08, 0x00, 0xbe, 0x58, 0x6d, 0x00, 0x12, 0x39, 0xc0, 0x03, 0x02, 0x82, 0xbe, 0x58, 0xc0, 0x03, 0x12, 0x39, 0xc1, 0x03, 0x02, 0x80, 0xbe, 0x58, 0xc1, 0x03, 0xe1, 0xe8, 0xe8, 0xe8, 0x3a, 0x38, 0x9e, 0x58, 0x95, 0x04, 0xbe, 0x58, 0x4c, 0x00, 0x9e, 0x58, 0x94, 0x04, 0xbe, 0x58, 0xf6, 0x00, 0x9e, 0x58, 0x96, 0x04, 0x18, 0x10, 0x2e, 0x8a, 0xd8, 0xac, 0x2c, 0x92, 0x9e, 0x58, 0x2a, 0x05, 0x18, 0x10, 0x28, 0x88, 0x9e, 0x58, 0x4b, 0x00, 0x9e, 0x59, 0x6c, 0x00, 0x01, 0x12, 0x19, 0x48, 0x01, 0x98, 0x20, 0x12, 0x9e, 0x58, 0x99, 0x04, 0x58, 0x48, 0x02, 0x9a, 0x9e, 0x5a, 0x99, 0x04, 0x9e, 0x58, 0x98, 0x04, 0x58, 0x48, 0x02, 0x94, 0x35, 0x22, 
+0x00, 0x28, 0x9e, 0x5a, 0x98, 0x04, 0x52, 0x38, 0x98, 0x04, 0x9e, 0x59, 0x97, 0x04, 0x32, 0x39, 0x96, 0x04, 0x19, 0x40, 0x9e, 0x5a, 0x99, 0x04, 0x52, 0x3a, 0x98, 0x04, 0x3c, 0x5a, 0x10, 0x38, 0x96, 0x04, 0xbe, 0x58, 0x4c, 0x00, 0x9e, 0x58, 0x9a, 0x04, 0xbe, 0x58, 0xf6, 0x00, 0x3a, 0x38, 0x41, 0xa9, 0x31, 0xb0, 0x04, 0x38, 0x00, 0x60, 0x05, 0x38, 0x43, 0x00, 0x9e, 0x59, 0x9d, 0x04, 0x1b, 0x21, 0x7f, 0x38, 0x26, 0x59, 0x01, 0x28, 0xb1, 0xb0, 0x00, 0x60, 0xc0, 0xb0, 0x41, 0xab, 0x94, 0xab, 0x9c, 0xab, 0xa4, 0xab, 0x3a, 0x38, 0x9e, 0x58, 0x69, 0x00, 0xc1, 0xb0, 0x15, 0x70, 0xfe, 0x58, 0xff, 0x20, 0x00, 0x38, 0x00, 0x3d, 0x09, 0x59, 0x21, 0x58, 0xfe, 0x58, 0x24, 0x39, 0xff, 0x00, 0x04, 0x38, 0xff, 0x00, 0x18, 0x10, 0x08, 0x8a, 0x20, 0x62, 0x80, 0x6a, 0x08, 0x58, 0x19, 0x10, 0xec, 0xdc, 
+0x40, 0x28, 0xff, 0x38, 0x06, 0x58, 0x40, 0x28, 0xc1, 0xb0, 0x16, 0x70, 0xfe, 0x58, 0xff, 0x20, 0x00, 0x38, 0x00, 0x3d, 0x09, 0x5a, 0x17, 0x70, 0xfe, 0x58, 0xff, 0x20, 0x00, 0x38, 0x00, 0x3d, 0x09, 0x5b, 0x9f, 0x38, 0x46, 0x5a, 0x41, 0x2b, 0xbf, 0x38, 0x66, 0x5b, 0x45, 0xb0, 0xff, 0x20, 0x03, 0x28, 0xc5, 0xb0, 0x3a, 0x38, 0x11, 0x70, 0x04, 0x39, 0xff, 0x07, 0x5f, 0x39, 0x08, 0x58, 0x3f, 0x20, 0xda, 0x62, 0x31, 0x6a, 0x40, 0x00, 0x09, 0x58, 0x20, 0x28, 0xc3, 0xb0, 0x12, 0x70, 0x04, 0x39, 0xff, 0x07, 0x5f, 0x39, 0x08, 0x58, 0x3f, 0x20, 0xda, 0x62, 0x31, 0x6a, 0x40, 0x00, 0x09, 0x58, 0x20, 0x28, 0xc4, 0xb0, 0x3a, 0x38, 0x41, 0xa9, 0x31, 0xb0, 0x04, 0x38, 0x00, 0x60, 0x15, 0x38, 0x67, 0x00, 0x9e, 0x59, 0x9d, 0x04, 0x1b, 0x21, 0x7f, 0x38, 0x26, 0x59, 0x01, 0x28, 0xb1, 0xb0, 0xcd, 0x47, 
+0x80, 0x28, 0x9e, 0x58, 0x68, 0x00, 0xc0, 0xb0, 0x28, 0x60, 0xc0, 0xb0, 0x9e, 0x58, 0x69, 0x00, 0xc1, 0xb0, 0x9e, 0x58, 0x6b, 0x00, 0xc5, 0xb0, 0xcc, 0x60, 0x0c, 0x68, 0xc6, 0xb0, 0x9e, 0x58, 0x6a, 0x00, 0xc2, 0xb0, 0x9e, 0x58, 0xb1, 0x04, 0x00, 0x61, 0x19, 0x48, 0x06, 0x8a, 0xff, 0x60, 0xff, 0x68, 0x07, 0x38, 0x9b, 0x28, 0x1a, 0x38, 0x1a, 0x38, 0x2f, 0x39, 0x9f, 0x28, 0x1a, 0x38, 0x1a, 0x38, 0x41, 0xab, 0x94, 0xa9, 0x41, 0xa9, 0x00, 0x60, 0xc6, 0xb0, 0x3a, 0x38, 0x18, 0x70, 0x00, 0x38, 0xee, 0x01, 0x03, 0x59, 0xbe, 0x59, 0x6c, 0x00, 0x3a, 0x38, 0x15, 0x70, 0xfe, 0x58, 0xff, 0x20, 0x00, 0x38, 0x80, 0x01, 0x03, 0x59, 0x11, 0x79, 0x16, 0x70, 0xfe, 0x58, 0xff, 0x20, 0x00, 0x38, 0x80, 0x01, 0x03, 0x59, 0x12, 0x79, 0x17, 0x70, 0xfe, 0x58, 0xff, 0x20, 0x00, 0x38, 0x80, 0x01, 0xd5, 0xc2, 
+0xc0, 0x28, 0x03, 0x59, 0x13, 0x79, 0x3a, 0x38, 0x18, 0x70, 0x00, 0x38, 0xb7, 0x01, 0x03, 0x59, 0xbe, 0x59, 0x4b, 0x00, 0x3a, 0x38, 0x18, 0x70, 0x00, 0x38, 0xb7, 0x01, 0x9e, 0x5f, 0x4b, 0x00, 0x9e, 0x5b, 0x32, 0x04, 0x18, 0x33, 0x01, 0x88, 0x0b, 0x9e, 0x00, 0x62, 0x9e, 0x5e, 0x4e, 0x00, 0xda, 0x48, 0x06, 0x8a, 0x03, 0x5a, 0x19, 0x16, 0xc7, 0x38, 0xde, 0x28, 0xe2, 0x07, 0xe8, 0x5f, 0xfb, 0x58, 0x3a, 0x38, 0x18, 0x70, 0x00, 0x38, 0xee, 0x01, 0x9e, 0x59, 0x6c, 0x00, 0x3b, 0x58, 0x3a, 0x38, 0x18, 0x70, 0x00, 0x38, 0x93, 0x02, 0x9e, 0x59, 0xf9, 0x00, 0x19, 0x31, 0x13, 0x88, 0x9e, 0x5f, 0xc3, 0x04, 0x9e, 0x59, 0x0b, 0x04, 0x20, 0x3e, 0x93, 0x02, 0x06, 0x31, 0x03, 0x8a, 0x7b, 0x06, 0x06, 0x31, 0x08, 0x88, 0x9e, 0x58, 0x6d, 0x00, 0xe8, 0x61, 0x03, 0x69, 0x11, 0x40, 0x3c, 0x5f, 0xe2, 0x7c, 
+0x00, 0x29, 0x1b, 0x5e, 0x3a, 0x38, 0x9e, 0x59, 0x6d, 0x00, 0x3b, 0x58, 0x3a, 0x38, 0x18, 0x70, 0x00, 0x38, 0x80, 0x01, 0x14, 0x71, 0x3b, 0x58, 0x3a, 0x38, 0x00, 0x62, 0x36, 0x67, 0xb7, 0x63, 0x01, 0x6b, 0x80, 0x64, 0x09, 0x6c, 0x90, 0x3c, 0x17, 0x01, 0x63, 0x58, 0x1b, 0x5c, 0x19, 0x02, 0x19, 0x03, 0x90, 0x3c, 0xd3, 0x04, 0x5f, 0x48, 0xf8, 0x81, 0x3a, 0x38, 0x00, 0x60, 0xbe, 0x58, 0x0d, 0x01, 0xbe, 0x58, 0x11, 0x01, 0xbe, 0x58, 0x12, 0x01, 0xbe, 0x58, 0xc1, 0x03, 0xff, 0x60, 0xff, 0x68, 0xbe, 0x58, 0xc0, 0x03, 0x9e, 0x58, 0x11, 0x01, 0x78, 0xac, 0xfc, 0x93, 0xcf, 0xea, 0x37, 0xac, 0x04, 0x90, 0x9e, 0x58, 0xda, 0x00, 0x18, 0x30, 0x3a, 0x88, 0x2b, 0xe8, 0xad, 0xe8, 0x5a, 0xe8, 0xc8, 0xe1, 0x9e, 0x58, 0x11, 0x01, 0x02, 0x38, 0x00, 0x80, 0xec, 0x8b, 0x04, 0x9e, 0x9e, 0x58, 0x4d, 0xeb, 
+0x40, 0x29, 0x11, 0x01, 0x78, 0xac, 0xfc, 0x93, 0xd9, 0xe1, 0xe3, 0xac, 0x05, 0x90, 0x9e, 0x58, 0x11, 0x01, 0x78, 0xac, 0xfc, 0x93, 0x28, 0x9e, 0x0e, 0x60, 0xbe, 0x58, 0xc3, 0x03, 0x02, 0x61, 0x9e, 0x58, 0x12, 0x01, 0x19, 0x10, 0x20, 0x40, 0x00, 0x3d, 0x80, 0x3d, 0x2f, 0x38, 0x68, 0x29, 0xab, 0x5b, 0x73, 0xac, 0x09, 0x92, 0xfe, 0x5b, 0xff, 0x23, 0x18, 0x7b, 0x9e, 0x58, 0xc3, 0x03, 0x03, 0x5b, 0xbe, 0x5b, 0x4b, 0x00, 0xca, 0xe8, 0x9e, 0x58, 0xc3, 0x03, 0x19, 0x00, 0xbe, 0x58, 0xc3, 0x03, 0x1a, 0x38, 0x9e, 0x58, 0x11, 0x01, 0x9e, 0x59, 0x12, 0x01, 0x19, 0x48, 0x04, 0x8a, 0x15, 0x70, 0x78, 0xac, 0xb8, 0x91, 0xcc, 0x9f, 0x00, 0x60, 0xbe, 0x58, 0x0d, 0x01, 0xbe, 0x58, 0x11, 0x01, 0xbe, 0x58, 0x12, 0x01, 0xb4, 0xea, 0x9e, 0x59, 0xd3, 0x04, 0x02, 0x60, 0x38, 0x48, 0x1c, 0x80, 0x5c, 0x9b, 
+0x80, 0x29, 0x08, 0x60, 0x19, 0x48, 0x19, 0x80, 0x00, 0x60, 0x0a, 0x78, 0xe3, 0xac, 0x01, 0x92, 0x0c, 0xe9, 0x9e, 0x58, 0x17, 0x01, 0xe3, 0xac, 0x03, 0x92, 0x19, 0x00, 0xbe, 0x58, 0x17, 0x01, 0x9e, 0x59, 0xd3, 0x04, 0x19, 0x48, 0x04, 0x80, 0x00, 0x60, 0xbe, 0x58, 0x17, 0x01, 0x04, 0x9e, 0x9e, 0x58, 0xd4, 0x04, 0x78, 0xac, 0x8f, 0x93, 0xf3, 0xe2, 0x00, 0x60, 0xbe, 0x58, 0x18, 0x00, 0xaf, 0x3e, 0xab, 0x29, 0xc3, 0xe8, 0x4b, 0x71, 0x18, 0x01, 0x01, 0x8a, 0x83, 0xe7, 0x9e, 0x58, 0x18, 0x00, 0x19, 0x00, 0xbe, 0x58, 0x18, 0x00, 0x1a, 0x38, 0x9e, 0x58, 0xda, 0x00, 0x19, 0x00, 0x9e, 0x59, 0x57, 0x04, 0x19, 0x48, 0x01, 0x96, 0x00, 0x60, 0xbe, 0x58, 0xda, 0x00, 0x9e, 0x58, 0x7d, 0x04, 0x18, 0x30, 0x02, 0x8a, 0xf7, 0xea, 0x01, 0x9e, 0xcb, 0xeb, 0x25, 0x61, 0x02, 0x69, 0x93, 0x62, 0x93, 0x22, 
+0xc0, 0x29, 0x02, 0x6a, 0xca, 0x63, 0x02, 0x6b, 0x6f, 0x67, 0x03, 0x6f, 0xaf, 0x3e, 0xcf, 0x29, 0x45, 0x5c, 0x65, 0x5d, 0x9d, 0x5f, 0x85, 0x14, 0x00, 0x65, 0x9d, 0x48, 0x01, 0x98, 0x00, 0x64, 0x9d, 0x59, 0x97, 0xee, 0x53, 0xea, 0xdc, 0xe9, 0x9e, 0x5a, 0x08, 0x00, 0x19, 0x02, 0x46, 0x38, 0x00, 0x00, 0x02, 0x8a, 0xbe, 0x5a, 0x08, 0x00, 0x3a, 0x38, 0x9e, 0x59, 0x44, 0x05, 0x18, 0x11, 0x0c, 0x8a, 0x9e, 0x58, 0x40, 0x01, 0x19, 0x48, 0x08, 0x96, 0xe9, 0xac, 0x06, 0x92, 0x9e, 0x58, 0xb1, 0x00, 0x19, 0x10, 0x02, 0x88, 0xfb, 0xe9, 0x3a, 0xea, 0x9e, 0x58, 0xab, 0x04, 0x08, 0x58, 0x08, 0x58, 0x07, 0x63, 0x1b, 0x48, 0x07, 0x88, 0xb3, 0x61, 0x02, 0x69, 0x30, 0x39, 0x0a, 0x04, 0x9e, 0x5a, 0xc0, 0x03, 0x5d, 0x59, 0x3a, 0x38, 0x25, 0x60, 0x02, 0x68, 0x9e, 0x59, 0x0b, 0x04, 0x00, 0x62, 0x1b, 0x3e, 
+0x00, 0x2a, 0x25, 0x63, 0x02, 0x6b, 0x27, 0x38, 0x09, 0x2a, 0x03, 0x59, 0x3a, 0x48, 0x02, 0x9a, 0x21, 0x5a, 0x01, 0x5b, 0x19, 0x00, 0x40, 0x60, 0x02, 0x68, 0x9e, 0x59, 0x0b, 0x04, 0x27, 0x38, 0x15, 0x2a, 0x03, 0x59, 0x3a, 0x48, 0x02, 0x9a, 0x21, 0x5a, 0x01, 0x5b, 0x19, 0x00, 0x40, 0x60, 0x02, 0x68, 0x78, 0x48, 0x02, 0x94, 0x25, 0x60, 0x02, 0x68, 0x00, 0x61, 0x72, 0x3c, 0x45, 0x05, 0x98, 0x48, 0x01, 0x96, 0x83, 0x59, 0x10, 0x38, 0x0b, 0x04, 0x00, 0x62, 0x70, 0x3c, 0x45, 0x05, 0x98, 0x48, 0x01, 0x98, 0x83, 0x5a, 0xbe, 0x59, 0xc0, 0x03, 0x3a, 0x48, 0x02, 0x94, 0xbe, 0x5a, 0xc0, 0x03, 0x9e, 0x58, 0x46, 0x05, 0x9e, 0x59, 0xc0, 0x03, 0x19, 0x40, 0x64, 0x62, 0x3c, 0x5a, 0xbe, 0x58, 0xc0, 0x03, 0x3a, 0x38, 0x25, 0x60, 0x02, 0x68, 0x9e, 0x59, 0x0b, 0x04, 0x27, 0x38, 0x45, 0x2a, 0x3b, 0x93, 
+0x40, 0x2a, 0x03, 0x59, 0x32, 0x39, 0xc0, 0x03, 0x01, 0x94, 0x00, 0x61, 0x3d, 0x58, 0x40, 0x60, 0x02, 0x68, 0x9e, 0x59, 0x0b, 0x04, 0x27, 0x38, 0x51, 0x2a, 0x03, 0x59, 0x32, 0x39, 0xc0, 0x03, 0x01, 0x94, 0x00, 0x61, 0x3d, 0x58, 0x3a, 0x38, 0x9e, 0x58, 0x1f, 0x05, 0x18, 0x30, 0x41, 0x8a, 0xe9, 0xac, 0x3f, 0x92, 0xe8, 0xac, 0x1f, 0x92, 0x9e, 0x58, 0xc0, 0x00, 0x30, 0xac, 0x10, 0x90, 0x9e, 0x58, 0x40, 0x01, 0x9e, 0x59, 0x1f, 0x05, 0x19, 0x48, 0x0a, 0x96, 0x9e, 0x58, 0x2c, 0x01, 0x19, 0x00, 0x9e, 0x59, 0x22, 0x05, 0x19, 0x48, 0x0b, 0x9a, 0x21, 0x58, 0xe8, 0xa8, 0x08, 0x9e, 0x9e, 0x58, 0x2c, 0x01, 0x19, 0x10, 0x00, 0x61, 0x19, 0x48, 0x02, 0x94, 0x21, 0x58, 0x00, 0x9e, 0xbe, 0x58, 0x2c, 0x01, 0x1e, 0x9e, 0x9e, 0x58, 0x40, 0x01, 0x9e, 0x59, 0x23, 0x05, 0x19, 0x48, 0x0d, 0x98, 0xa8, 0xdb, 
+0x80, 0x2a, 0x9e, 0x58, 0x2e, 0x01, 0x19, 0x00, 0x9e, 0x59, 0x24, 0x05, 0x19, 0x48, 0x0e, 0x9a, 0x00, 0x60, 0xbe, 0x58, 0x2c, 0x01, 0xe8, 0xaa, 0x99, 0xa8, 0x08, 0x9e, 0x9e, 0x58, 0x2e, 0x01, 0x19, 0x10, 0x00, 0x61, 0x19, 0x48, 0x02, 0x94, 0x21, 0x58, 0x00, 0x9e, 0xbe, 0x58, 0x2e, 0x01, 0x00, 0x9e, 0x9e, 0x58, 0xab, 0x04, 0x08, 0x58, 0x08, 0x58, 0x06, 0x63, 0x1b, 0x48, 0x14, 0x88, 0xb3, 0x61, 0x02, 0x69, 0x30, 0x39, 0x0a, 0x04, 0x9e, 0x5a, 0x40, 0x01, 0x5d, 0x59, 0x9e, 0x5a, 0xc1, 0x03, 0x5d, 0x59, 0x9e, 0x5a, 0xc9, 0x03, 0x5d, 0x59, 0x00, 0x62, 0x9e, 0x58, 0xc0, 0x00, 0x30, 0xac, 0x01, 0x90, 0x01, 0x62, 0x5d, 0x59, 0x3a, 0x38, 0x9e, 0x58, 0x01, 0x04, 0x18, 0x10, 0x16, 0x8a, 0x00, 0x60, 0x00, 0x61, 0x00, 0x64, 0xd2, 0x62, 0x01, 0x6a, 0x50, 0x3a, 0x0a, 0x04, 0x45, 0x5b, 0x6c, 0xe0, 
+0xc0, 0x2a, 0x18, 0x03, 0x03, 0x8a, 0x19, 0x04, 0x03, 0x00, 0xfa, 0x9f, 0xb7, 0x62, 0x01, 0x6a, 0x50, 0x3a, 0x09, 0x04, 0x43, 0x5b, 0x19, 0x04, 0x03, 0x00, 0x1c, 0x5c, 0x1b, 0x5a, 0x3a, 0x38, 0x0a, 0x70, 0x00, 0x38, 0x80, 0x3d, 0x15, 0x63, 0xff, 0x67, 0xff, 0x6f, 0x2f, 0x38, 0xd9, 0x2a, 0x0b, 0x59, 0x3d, 0x5b, 0xe1, 0x27, 0x02, 0x38, 0x80, 0x3d, 0x0a, 0x78, 0x15, 0x71, 0x16, 0x72, 0x17, 0x73, 0xeb, 0xea, 0x15, 0x60, 0x04, 0x61, 0x01, 0x69, 0x2f, 0x38, 0xe9, 0x2a, 0x05, 0x5a, 0xfe, 0x5a, 0xff, 0x22, 0x5d, 0x59, 0x3a, 0x38, 0xff, 0x60, 0xff, 0x68, 0xca, 0xb0, 0xcb, 0xb0, 0x24, 0x38, 0x3f, 0x00, 0x44, 0x3c, 0x3f, 0x00, 0xfe, 0x5c, 0x04, 0x28, 0xc9, 0xb0, 0x3a, 0x38, 0xc1, 0xeb, 0x00, 0xac, 0x2e, 0x92, 0x76, 0xeb, 0x06, 0x39, 0x00, 0x00, 0x2e, 0x8a, 0x06, 0x39, 0x01, 0x00, 0x42, 0x5a, 
+0x00, 0x2b, 0x27, 0x8a, 0xc8, 0xac, 0x09, 0x92, 0x93, 0x60, 0x02, 0x68, 0x01, 0x61, 0x03, 0x69, 0x00, 0x66, 0x01, 0x67, 0x4e, 0xeb, 0xc8, 0xa8, 0x20, 0x9e, 0x93, 0x60, 0x02, 0x68, 0xd5, 0xeb, 0x9e, 0x59, 0x81, 0x04, 0x19, 0x48, 0x15, 0x96, 0xb4, 0xeb, 0x9e, 0x59, 0x82, 0x04, 0x19, 0x48, 0x10, 0x98, 0x9e, 0x58, 0xe1, 0x00, 0x19, 0x00, 0xbe, 0x58, 0xe1, 0x00, 0x9e, 0x59, 0x83, 0x04, 0x19, 0x48, 0x0b, 0x96, 0x01, 0x60, 0x03, 0x68, 0xca, 0x61, 0x02, 0x69, 0x00, 0x66, 0x02, 0x67, 0x4e, 0xeb, 0x00, 0x60, 0xbe, 0x58, 0xe1, 0x00, 0xc8, 0xaa, 0x9e, 0x58, 0x01, 0x04, 0x18, 0x30, 0x13, 0x8a, 0x80, 0x60, 0x01, 0x68, 0x10, 0x38, 0x03, 0x01, 0x03, 0x58, 0xbc, 0x61, 0x7f, 0x69, 0x19, 0x48, 0x0a, 0x82, 0x93, 0x60, 0x02, 0x68, 0x10, 0x38, 0x03, 0x01, 0x03, 0x58, 0x9e, 0x59, 0x84, 0x04, 0x0b, 0xfd, 
+0x40, 0x2b, 0x19, 0x48, 0x01, 0x98, 0xcb, 0xeb, 0xca, 0x60, 0x02, 0x68, 0xd5, 0xeb, 0x9e, 0x59, 0x85, 0x04, 0x19, 0x48, 0x02, 0x96, 0x95, 0xa8, 0x01, 0x9e, 0x95, 0xaa, 0x3a, 0x38, 0x9e, 0x5a, 0x0b, 0x04, 0x47, 0x38, 0x59, 0x2b, 0x1b, 0x64, 0x80, 0x04, 0x83, 0x5b, 0x1b, 0x64, 0x81, 0x04, 0x7b, 0x5c, 0x05, 0x5b, 0x7d, 0x59, 0x9e, 0x58, 0xab, 0x04, 0x00, 0xac, 0x17, 0x90, 0x08, 0xac, 0x03, 0x92, 0xe6, 0x38, 0x01, 0x00, 0x12, 0x8a, 0xca, 0x60, 0x02, 0x68, 0xd5, 0xeb, 0x01, 0x5e, 0x04, 0x60, 0x27, 0x78, 0x78, 0x60, 0x28, 0x78, 0xc1, 0x58, 0xfe, 0x58, 0x29, 0x78, 0xc1, 0x58, 0x2a, 0x78, 0xe1, 0x58, 0x2b, 0x78, 0xa2, 0xa8, 0x93, 0xc6, 0x60, 0xd1, 0x3a, 0x38, 0x9e, 0x58, 0xdd, 0x00, 0x9e, 0x59, 0x7e, 0x04, 0x19, 0x48, 0x25, 0x96, 0x00, 0x60, 0xbe, 0x58, 0xdd, 0x00, 0x9e, 0x58, 0xf6, 0x5b, 
+0x80, 0x2b, 0xde, 0x00, 0x9e, 0x59, 0xdf, 0x00, 0x9e, 0x5a, 0xde, 0x00, 0xbe, 0x5a, 0xdf, 0x00, 0x00, 0x62, 0xbe, 0x5a, 0xde, 0x00, 0x53, 0xdc, 0x00, 0x61, 0x9e, 0x5a, 0x7e, 0x04, 0x3c, 0x5a, 0x9e, 0x59, 0x7f, 0x04, 0x19, 0x48, 0x0a, 0x94, 0x9e, 0x58, 0xe0, 0x00, 0x19, 0x00, 0xbe, 0x58, 0xe0, 0x00, 0x9e, 0x59, 0x80, 0x04, 0x19, 0x48, 0x0f, 0x96, 0x12, 0x9e, 0x00, 0x60, 0xbe, 0x58, 0xe0, 0x00, 0x0c, 0x9e, 0x19, 0x00, 0xbe, 0x58, 0xdd, 0x00, 0x93, 0x60, 0x02, 0x68, 0xd5, 0xeb, 0x10, 0x38, 0xde, 0x00, 0xbe, 0x58, 0xde, 0x00, 0x00, 0x60, 0x06, 0x9e, 0x01, 0x60, 0x04, 0x9e, 0x00, 0x60, 0xbe, 0x58, 0xe0, 0x00, 0x02, 0x60, 0x3a, 0x38, 0x38, 0x62, 0x03, 0x6a, 0x9e, 0x59, 0x0b, 0x04, 0x00, 0x60, 0x27, 0x38, 0xbf, 0x2b, 0x45, 0x5b, 0x78, 0x48, 0x01, 0x96, 0x61, 0x58, 0x1a, 0x38, 0x42, 0xb8, 
+0xc0, 0x2b, 0x3a, 0x38, 0x9e, 0x58, 0xd1, 0x00, 0x15, 0x38, 0xb1, 0x00, 0x18, 0x30, 0x02, 0x88, 0x00, 0x60, 0x01, 0x9e, 0x01, 0x60, 0x3a, 0x38, 0xca, 0x60, 0x02, 0x68, 0x01, 0x61, 0x03, 0x69, 0x00, 0x62, 0xaf, 0x3e, 0xd3, 0x2b, 0x5d, 0x58, 0x5d, 0x59, 0x3a, 0x38, 0x9e, 0x59, 0x0b, 0x04, 0x00, 0x62, 0x27, 0x38, 0xe2, 0x2b, 0x03, 0x5c, 0x44, 0x02, 0x10, 0x38, 0x1b, 0x00, 0x05, 0x5c, 0x44, 0x02, 0x12, 0x38, 0x1b, 0x00, 0x1a, 0x38, 0x41, 0x58, 0x3a, 0x38, 0x00, 0x64, 0x00, 0x65, 0xd8, 0xac, 0x02, 0x92, 0xe9, 0xac, 0xf4, 0x90, 0x5b, 0xed, 0x00, 0x66, 0xbe, 0x5e, 0xca, 0x03, 0x6f, 0x60, 0x03, 0x68, 0x9e, 0x59, 0xca, 0x04, 0x9e, 0x5a, 0xce, 0x04, 0x47, 0x38, 0xff, 0x2b, 0x05, 0x5b, 0x68, 0x5f, 0xe8, 0x5f, 0xe8, 0x5f, 0xc7, 0x06, 0x79, 0x48, 0x01, 0x9a, 0x19, 0x05, 0x1a, 0x38, 0xd1, 0x2d, 
+0x00, 0x2c, 0xc1, 0x58, 0x00, 0x61, 0x1c, 0x5a, 0x01, 0x5e, 0xbe, 0x5e, 0xca, 0x03, 0x00, 0x66, 0x8a, 0x60, 0x03, 0x68, 0x9e, 0x59, 0xca, 0x04, 0x47, 0x38, 0x15, 0x2c, 0x05, 0x5b, 0x68, 0x5f, 0xe8, 0x5f, 0xe8, 0x5f, 0xc7, 0x06, 0x79, 0x48, 0x01, 0x9a, 0x19, 0x05, 0x1a, 0x38, 0xc1, 0x58, 0x00, 0x61, 0x1c, 0x5a, 0x9e, 0x5e, 0xca, 0x03, 0xc0, 0x06, 0xc8, 0x5e, 0x9e, 0x58, 0x00, 0x01, 0x01, 0x61, 0x19, 0x48, 0x0e, 0x8a, 0x9e, 0x58, 0xc9, 0x04, 0x02, 0x61, 0x19, 0x40, 0xb8, 0x48, 0x22, 0x9a, 0x01, 0x60, 0xbe, 0x58, 0x00, 0x01, 0xbe, 0x5e, 0x47, 0x01, 0xe9, 0xac, 0xe1, 0x92, 0x78, 0x9e, 0x9e, 0x59, 0x47, 0x01, 0x28, 0x5a, 0x48, 0x5f, 0x47, 0x02, 0xc2, 0x03, 0x3b, 0x48, 0x05, 0x98, 0xd9, 0x48, 0xd6, 0x9a, 0xbe, 0x5e, 0x47, 0x01, 0xd3, 0x9e, 0x9e, 0x58, 0x01, 0x01, 0x19, 0x00, 0x3a, 0x0b, 
+0x40, 0x2c, 0xbe, 0x58, 0x01, 0x01, 0x9e, 0x59, 0xcc, 0x04, 0x19, 0x48, 0xca, 0x9a, 0x00, 0x60, 0xbe, 0x58, 0x00, 0x01, 0x9c, 0x9e, 0x00, 0x60, 0xbe, 0x58, 0x01, 0x01, 0xe9, 0xac, 0x0a, 0x92, 0x12, 0xed, 0x9e, 0x58, 0xc7, 0x04, 0xf8, 0x48, 0xb9, 0x98, 0x9e, 0x58, 0xd1, 0x00, 0x00, 0x67, 0x1f, 0x48, 0xb4, 0x88, 0x00, 0x66, 0xbe, 0x5e, 0xca, 0x03, 0x6f, 0x60, 0x03, 0x68, 0x9e, 0x59, 0xb8, 0x04, 0x9e, 0x5a, 0xcd, 0x04, 0x47, 0x38, 0x6c, 0x2c, 0x05, 0x5b, 0x68, 0x5f, 0xe8, 0x5f, 0xe8, 0x5f, 0xc7, 0x06, 0x79, 0x48, 0x01, 0x9a, 0x19, 0x04, 0x1a, 0x38, 0xc1, 0x58, 0x00, 0x61, 0x1c, 0x5a, 0x01, 0x5e, 0xbe, 0x5e, 0xca, 0x03, 0x00, 0x66, 0x8a, 0x60, 0x03, 0x68, 0x47, 0x38, 0x80, 0x2c, 0x05, 0x5b, 0x68, 0x5f, 0xe8, 0x5f, 0xe8, 0x5f, 0xc7, 0x06, 0x79, 0x48, 0x01, 0x9a, 0x19, 0x04, 0x32, 0xf8, 
+0x80, 0x2c, 0x1a, 0x38, 0xc1, 0x58, 0x00, 0x61, 0x1c, 0x5a, 0x9e, 0x5e, 0xca, 0x03, 0xc0, 0x06, 0xc8, 0x5e, 0xe9, 0xac, 0x07, 0x92, 0x9e, 0x58, 0xb7, 0x04, 0x02, 0x61, 0x19, 0x40, 0x98, 0x48, 0x4f, 0x9a, 0x0d, 0x9e, 0x9e, 0x59, 0x48, 0x01, 0x28, 0x5a, 0x48, 0x5f, 0x47, 0x02, 0xc2, 0x03, 0x3b, 0x48, 0x46, 0x98, 0xd9, 0x48, 0x75, 0x9a, 0xbe, 0x5e, 0x48, 0x01, 0x72, 0x9e, 0x9e, 0x58, 0xfe, 0x00, 0x19, 0x00, 0xfe, 0x78, 0x9e, 0x59, 0xb9, 0x04, 0x19, 0x48, 0x6a, 0x9a, 0xbe, 0x5e, 0x48, 0x01, 0x00, 0x60, 0xfe, 0x78, 0xe9, 0xa8, 0x8d, 0xa8, 0x9e, 0x58, 0xb9, 0x04, 0xbe, 0x58, 0xfc, 0x00, 0x08, 0x60, 0x27, 0x78, 0x5a, 0x60, 0x28, 0x78, 0x00, 0x60, 0x29, 0x78, 0x2a, 0x78, 0x2b, 0x78, 0x2c, 0x78, 0x2d, 0x78, 0x2e, 0x78, 0x2f, 0x78, 0x30, 0x78, 0xa2, 0xa8, 0x93, 0xc6, 0x60, 0xd1, 0x23, 0x43, 
+0xc0, 0x2c, 0xf4, 0x60, 0x01, 0x68, 0xf4, 0x61, 0x01, 0x69, 0x9e, 0xed, 0xfa, 0x60, 0x28, 0x78, 0xce, 0x60, 0x29, 0x78, 0xaa, 0x60, 0x2a, 0x78, 0x2b, 0x78, 0xff, 0x60, 0x2c, 0x78, 0x2d, 0x78, 0x2e, 0x78, 0x2f, 0x78, 0x30, 0x78, 0xa2, 0xa8, 0x93, 0xc6, 0x60, 0xd1, 0x9e, 0x58, 0xfc, 0x00, 0x9e, 0x59, 0xb9, 0x04, 0x19, 0x48, 0x35, 0x94, 0x19, 0x00, 0xbe, 0x58, 0xfc, 0x00, 0x31, 0x9e, 0x00, 0x60, 0x9e, 0x59, 0xfc, 0x00, 0x38, 0x48, 0x23, 0x98, 0xe9, 0xac, 0x2a, 0x90, 0xe9, 0xaa, 0x8d, 0xaa, 0xfa, 0x60, 0x28, 0x78, 0xce, 0x60, 0x29, 0x78, 0x55, 0x60, 0x2a, 0x78, 0x2b, 0x78, 0xff, 0x60, 0x2c, 0x78, 0x2d, 0x78, 0x2e, 0x78, 0x2f, 0x78, 0x30, 0x78, 0xa2, 0xa8, 0x00, 0x60, 0xbe, 0x58, 0xfe, 0x00, 0xbe, 0x58, 0x01, 0x01, 0xbe, 0x58, 0x00, 0x01, 0x93, 0xc6, 0x60, 0xd1, 0x73, 0xed, 0x84, 0xbd, 
+0x00, 0x2d, 0x9e, 0x58, 0x1a, 0x05, 0x00, 0x61, 0x19, 0x48, 0x0b, 0x8a, 0x73, 0xed, 0x09, 0x9e, 0x9e, 0x59, 0xfc, 0x00, 0x19, 0x11, 0xbe, 0x59, 0xfc, 0x00, 0x03, 0x9e, 0x6b, 0xed, 0x00, 0x60, 0xfe, 0x78, 0x1a, 0x38, 0x3a, 0x38, 0x1e, 0x5c, 0x8f, 0xed, 0x00, 0x65, 0x38, 0x66, 0x03, 0x6e, 0x9e, 0x5f, 0x0b, 0x04, 0xe7, 0x38, 0x1f, 0x2d, 0xbe, 0x49, 0x02, 0x94, 0xc3, 0x5d, 0xc1, 0x5c, 0x19, 0x06, 0x64, 0x60, 0xb8, 0x48, 0x03, 0x98, 0x00, 0x67, 0x3e, 0x5c, 0x3a, 0x38, 0x38, 0x66, 0x03, 0x6e, 0x1a, 0x06, 0x9e, 0x48, 0x0b, 0x98, 0x00, 0x63, 0x1a, 0x04, 0x02, 0x67, 0xe7, 0x38, 0x31, 0x2d, 0x93, 0x03, 0x19, 0x04, 0x0a, 0x62, 0xba, 0x40, 0x3c, 0x5b, 0x21, 0x9e, 0x82, 0x38, 0x02, 0x00, 0x80, 0x39, 0x02, 0x00, 0x38, 0x62, 0x03, 0x6a, 0x19, 0x07, 0xe0, 0x3b, 0x38, 0x03, 0x1a, 0x48, 0x9b, 0x6b, 
+0x40, 0x2d, 0x12, 0x96, 0x1b, 0x48, 0x10, 0x98, 0x3a, 0x48, 0x10, 0x96, 0x3b, 0x48, 0x0e, 0x98, 0x03, 0x5b, 0x23, 0x5c, 0x7c, 0x48, 0x04, 0x98, 0x0a, 0x62, 0xba, 0x40, 0x3c, 0x5b, 0x08, 0x9e, 0x0a, 0x62, 0xba, 0x40, 0x3c, 0x5c, 0x04, 0x9e, 0x23, 0x5c, 0xfa, 0x9f, 0x03, 0x5b, 0xf4, 0x9f, 0x01, 0x5f, 0x3e, 0x5c, 0x3a, 0x38, 0x3a, 0x38, 0x9e, 0x58, 0xfd, 0x00, 0x01, 0x61, 0x19, 0x48, 0x07, 0x8a, 0x9e, 0x58, 0xff, 0x00, 0x19, 0x10, 0xff, 0x78, 0x00, 0x61, 0x19, 0x48, 0xa9, 0x89, 0x01, 0x60, 0xbe, 0x58, 0xfd, 0x00, 0x3a, 0x38, 0x00, 0x60, 0xbe, 0x58, 0xfd, 0x00, 0x9e, 0x58, 0xc8, 0x04, 0xbe, 0x58, 0xff, 0x00, 0x3a, 0x38, 0xb7, 0x60, 0x01, 0x68, 0xee, 0x62, 0x01, 0x6a, 0x9e, 0x5d, 0x0b, 0x04, 0x9e, 0x5e, 0x02, 0x04, 0xa6, 0x05, 0x9e, 0x5e, 0x01, 0x04, 0xa6, 0x05, 0xa7, 0x38, 0x4c, 0x93, 
+0x80, 0x2d, 0x82, 0x2d, 0x05, 0x5c, 0x9d, 0x5a, 0xd2, 0x61, 0x01, 0x69, 0x09, 0x63, 0x02, 0x6b, 0x9e, 0x5d, 0x0b, 0x04, 0xa1, 0x5d, 0xa7, 0x38, 0x8d, 0x2d, 0x25, 0x5c, 0x9d, 0x5b, 0x3a, 0x38, 0x6f, 0x63, 0x03, 0x6b, 0x8a, 0x64, 0x03, 0x6c, 0x38, 0x65, 0x03, 0x6d, 0x9e, 0x59, 0x0b, 0x04, 0x27, 0x38, 0x9c, 0x2d, 0x65, 0x58, 0x85, 0x59, 0x01, 0x00, 0x1d, 0x5d, 0x3a, 0x38, 0x01, 0x5a, 0x41, 0x58, 0x19, 0x10, 0xfe, 0x89, 0x19, 0x11, 0xfb, 0x89, 0x3a, 0x38, 0x6f, 0x65, 0x03, 0x6d, 0x00, 0x66, 0x9e, 0x5a, 0xce, 0x04, 0x47, 0x38, 0xb0, 0x2d, 0xa3, 0x58, 0x1e, 0x48, 0x01, 0x9a, 0x01, 0x5e, 0x19, 0x05, 0x8a, 0x65, 0x03, 0x6d, 0x9e, 0x5a, 0xce, 0x04, 0x47, 0x38, 0xbb, 0x2d, 0xa3, 0x58, 0x1e, 0x48, 0x01, 0x9a, 0x01, 0x5e, 0x19, 0x05, 0xc1, 0x58, 0x3a, 0x38, 0x01, 0xb8, 0x41, 0xab, 0x50, 0x21, 
+0xc0, 0x2d, 0x13, 0xb8, 0x14, 0xb8, 0x15, 0xb8, 0x00, 0x61, 0x00, 0x62, 0xef, 0x3f, 0xc8, 0x2d, 0x0b, 0x59, 0x22, 0x02, 0x03, 0x31, 0x01, 0x8a, 0xf9, 0x9f, 0x41, 0xab, 0x95, 0xb8, 0x94, 0xb8, 0x93, 0xb8, 0x81, 0xb8, 0x3a, 0x38, 0x01, 0xb8, 0x41, 0xab, 0x13, 0xb8, 0x14, 0xb8, 0x15, 0xb8, 0x00, 0x60, 0x00, 0x61, 0x00, 0x62, 0x1b, 0x63, 0x02, 0x6b, 0xef, 0x3f, 0xe2, 0x2d, 0x1b, 0x48, 0x02, 0x8a, 0x09, 0x59, 0x22, 0x02, 0x19, 0x00, 0x06, 0x39, 0x40, 0x02, 0x01, 0x8a, 0xf5, 0x9f, 0x41, 0xab, 0x95, 0xb8, 0x94, 0xb8, 0x93, 0xb8, 0x81, 0xb8, 0x3a, 0x38, 0x00, 0x62, 0x40, 0x3b, 0x0e, 0x00, 0x63, 0x58, 0x06, 0x3d, 0xff, 0xff, 0x10, 0x8a, 0x9e, 0x5d, 0xcf, 0x04, 0x18, 0x05, 0x01, 0x8a, 0x05, 0x40, 0x9e, 0x5d, 0x30, 0x04, 0xa2, 0x3c, 0x01, 0x00, 0x01, 0x8a, 0x1c, 0x5d, 0x9e, 0x59, 0xd3, 0x12, 
+0x00, 0x2e, 0x32, 0x04, 0x18, 0x31, 0x01, 0x88, 0x08, 0x58, 0x1b, 0x5b, 0x19, 0x02, 0x42, 0x3b, 0x02, 0x00, 0xe5, 0x81, 0x3a, 0x38, 0xf0, 0xac, 0x8a, 0x90, 0x9e, 0x5f, 0x2a, 0x05, 0x01, 0x60, 0xf8, 0x48, 0x85, 0x9c, 0x93, 0x61, 0x02, 0x69, 0x1b, 0x01, 0x25, 0x5c, 0x25, 0x5d, 0x25, 0x5e, 0xdd, 0x48, 0x1e, 0x9c, 0xbc, 0x48, 0x1c, 0x9c, 0xae, 0x61, 0x02, 0x69, 0x1b, 0x01, 0x25, 0x5c, 0x25, 0x5d, 0x25, 0x5e, 0xdd, 0x48, 0x14, 0x9c, 0xbc, 0x48, 0x12, 0x9c, 0x93, 0x61, 0x02, 0x69, 0x1b, 0x01, 0x23, 0x58, 0x9e, 0x5d, 0x0b, 0x04, 0x1c, 0x15, 0xb7, 0x38, 0x1d, 0x59, 0xae, 0x61, 0x02, 0x69, 0x1b, 0x01, 0x23, 0x58, 0x9e, 0x5d, 0x0b, 0x04, 0x1c, 0x15, 0xb7, 0x38, 0x1d, 0x59, 0x9e, 0x5d, 0x0b, 0x04, 0x93, 0x61, 0x02, 0x69, 0xae, 0x62, 0x02, 0x6a, 0x5c, 0x63, 0x02, 0x6b, 0x77, 0x64, 0x4b, 0x5c, 
+0x40, 0x2e, 0x02, 0x6c, 0xa7, 0x38, 0x46, 0x2e, 0x25, 0x58, 0x1d, 0x5b, 0x45, 0x58, 0x1d, 0x5c, 0x04, 0x65, 0x5c, 0x66, 0x02, 0x6e, 0x56, 0xee, 0x1e, 0x5a, 0x04, 0x65, 0x77, 0x66, 0x02, 0x6e, 0x56, 0xee, 0x3e, 0x5c, 0x41, 0x5e, 0x0b, 0x9e, 0x58, 0xe3, 0x00, 0x62, 0x5b, 0x59, 0x58, 0xe3, 0x00, 0x62, 0x5b, 0x59, 0x58, 0xe3, 0x00, 0x62, 0x5b, 0x59, 0x58, 0xe3, 0x3a, 0x38, 0x93, 0x62, 0x02, 0x6a, 0xae, 0x63, 0x02, 0x6b, 0x9e, 0x5d, 0x0b, 0x04, 0xa7, 0x38, 0x89, 0x2e, 0x0a, 0x65, 0x9e, 0x59, 0x2b, 0x05, 0x20, 0x39, 0x92, 0x02, 0x59, 0x48, 0x19, 0x80, 0x9e, 0x59, 0x2c, 0x05, 0x20, 0x39, 0x92, 0x02, 0x3a, 0x48, 0x13, 0x80, 0x43, 0x58, 0x04, 0x10, 0x04, 0x9c, 0x07, 0x40, 0x00, 0x61, 0x1c, 0x5d, 0x01, 0x9e, 0x00, 0x60, 0x1d, 0x5a, 0x63, 0x58, 0x06, 0x10, 0x04, 0x9c, 0x07, 0x40, 0x8f, 0x90, 
+0x80, 0x2e, 0x00, 0x61, 0x1c, 0x5d, 0x01, 0x9e, 0x00, 0x60, 0x1d, 0x5b, 0x03, 0x9e, 0x00, 0x60, 0x1d, 0x5a, 0x1d, 0x5b, 0x1a, 0x38, 0x9e, 0x59, 0x01, 0x04, 0x9e, 0x58, 0x02, 0x04, 0x20, 0x00, 0x06, 0x8a, 0x19, 0x10, 0x07, 0x38, 0x95, 0x2e, 0x00, 0x60, 0x1d, 0x5a, 0x1a, 0x38, 0x3a, 0x38, 0x01, 0x60, 0xfb, 0xdb, 0xfc, 0xda, 0x59, 0xdc, 0x69, 0xf0, 0xc8, 0x67, 0x03, 0x6f, 0x4f, 0x38, 0xa3, 0x2e, 0xe2, 0x38, 0xc7, 0x03, 0xae, 0xf0, 0x1d, 0x5f, 0xed, 0xf0, 0x70, 0xf1, 0x9e, 0x58, 0x42, 0x01, 0x01, 0x61, 0x19, 0x48, 0x98, 0x3a, 0x16, 0x30, 0x02, 0x61, 0x19, 0x48, 0x98, 0x3a, 0x16, 0x30, 0x03, 0x61, 0x19, 0x48, 0x98, 0x3a, 0xbf, 0x2f, 0x05, 0x61, 0x19, 0x48, 0x07, 0x8a, 0x04, 0x61, 0x19, 0x48, 0x98, 0x3a, 0xe0, 0x2f, 0x06, 0x61, 0x19, 0x48, 0x5e, 0x8a, 0x9e, 0x58, 0x10, 0x05, 0xad, 0x13, 
+0xc0, 0x2e, 0x00, 0x61, 0x38, 0x48, 0x28, 0x8a, 0x9e, 0x59, 0x40, 0x01, 0x38, 0x48, 0x15, 0x98, 0xb1, 0x70, 0x19, 0x10, 0x12, 0x98, 0x9e, 0x58, 0xca, 0x03, 0x9e, 0x59, 0x11, 0x05, 0x19, 0x48, 0x0c, 0x98, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xa8, 0x18, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xa8, 0x05, 0x60, 0xbe, 0x58, 0x42, 0x01, 0x98, 0x3f, 0x16, 0x30, 0x9e, 0x58, 0x42, 0x01, 0x05, 0x61, 0x19, 0x48, 0x0a, 0x88, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xaa, 0x18, 0xaa, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xaa, 0x00, 0x60, 0xbe, 0x58, 0x42, 0x01, 0x9e, 0x58, 0xa5, 0x04, 0x18, 0x10, 0x2d, 0x9a, 0xb1, 0x70, 0x19, 0x10, 0x2a, 0x98, 0x9e, 0x58, 0x0b, 0x04, 0x38, 0x61, 0x03, 0x69, 0x00, 0x62, 0x9e, 0x5b, 0xa6, 0x04, 0x00, 0x64, 0x07, 0x38, 0x04, 0x2f, 0x23, 0x58, 0x19, 0x04, 0x1b, 0x48, 0x01, 0x98, 0x87, 0x2e, 
+0x00, 0x2f, 0x00, 0x64, 0x9a, 0x48, 0x01, 0x9a, 0x81, 0x5a, 0x19, 0x01, 0xbe, 0x5a, 0xd0, 0x03, 0x9e, 0x5c, 0xa7, 0x04, 0x5c, 0x48, 0x11, 0x96, 0x9e, 0x58, 0xc9, 0x03, 0x9e, 0x59, 0xa5, 0x04, 0x19, 0x48, 0x0b, 0x98, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xa8, 0x18, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xa8, 0x01, 0x60, 0xbe, 0x58, 0x42, 0x01, 0xfa, 0x9e, 0x9e, 0x58, 0x50, 0x05, 0x18, 0x10, 0x49, 0x8a, 0x9e, 0x59, 0x40, 0x01, 0x38, 0x48, 0x36, 0x96, 0x9e, 0x58, 0x51, 0x05, 0x38, 0x48, 0x32, 0x98, 0x02, 0x67, 0x9e, 0x5e, 0x9b, 0x04, 0x9e, 0x58, 0x41, 0x01, 0x04, 0x38, 0xff, 0x3f, 0x38, 0x61, 0x03, 0x69, 0x30, 0x39, 0x0b, 0x04, 0xe7, 0x38, 0x3d, 0x2f, 0x03, 0x5a, 0x19, 0x00, 0x19, 0x48, 0x05, 0x98, 0x03, 0x5b, 0x43, 0x12, 0x5e, 0x48, 0x1d, 0x98, 0x1a, 0x38, 0x9e, 0x58, 0x41, 0x01, 0x8e, 0xa4, 
+0x40, 0x2f, 0x04, 0x38, 0xff, 0x3f, 0x38, 0x61, 0x03, 0x69, 0xe7, 0x38, 0x4e, 0x2f, 0x03, 0x5a, 0x19, 0x10, 0x19, 0x48, 0x05, 0x96, 0x03, 0x5b, 0x43, 0x12, 0x5e, 0x48, 0x0c, 0x98, 0x1a, 0x38, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xa8, 0x18, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xa8, 0x06, 0x60, 0xbe, 0x58, 0x42, 0x01, 0xbc, 0x9e, 0x9e, 0x58, 0x42, 0x01, 0x06, 0x61, 0x19, 0x48, 0x0a, 0x88, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xaa, 0x18, 0xaa, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xaa, 0x00, 0x60, 0xbe, 0x58, 0x42, 0x01, 0x0c, 0x60, 0x03, 0x68, 0xbe, 0x58, 0xcf, 0x03, 0x9e, 0x58, 0x3d, 0x05, 0x18, 0x10, 0x4e, 0x8a, 0xaf, 0xf1, 0x38, 0x48, 0x0a, 0x80, 0xbb, 0xf1, 0x9e, 0x59, 0x3e, 0x05, 0x19, 0x48, 0x05, 0x96, 0x0d, 0x60, 0x03, 0x68, 0xbe, 0x58, 0xcf, 0x03, 0x36, 0x9e, 0x9e, 0x58, 0x40, 0x01, 0x18, 0xc5, 
+0x80, 0x2f, 0x9e, 0x59, 0x3f, 0x05, 0x19, 0x48, 0x18, 0x96, 0x9e, 0x58, 0x41, 0x01, 0x04, 0x38, 0xff, 0x3f, 0x02, 0x38, 0x38, 0x03, 0x00, 0x38, 0x25, 0x02, 0x03, 0x59, 0x7b, 0x00, 0x03, 0x58, 0x21, 0x5a, 0x38, 0x48, 0x01, 0x96, 0x01, 0x5a, 0x9e, 0x58, 0x40, 0x05, 0x58, 0x48, 0x05, 0x94, 0x0e, 0x60, 0x03, 0x68, 0xbe, 0x58, 0xcf, 0x03, 0x18, 0x9e, 0x89, 0xf1, 0x9e, 0x58, 0xc6, 0x03, 0x9e, 0x59, 0x41, 0x05, 0x19, 0x48, 0x05, 0x96, 0x0f, 0x60, 0x03, 0x68, 0xbe, 0x58, 0xcf, 0x03, 0x0c, 0x9e, 0x99, 0xf1, 0x9e, 0x58, 0xc7, 0x03, 0x9e, 0x59, 0x42, 0x05, 0x19, 0x48, 0x10, 0x96, 0x10, 0x60, 0x03, 0x68, 0xbe, 0x58, 0xcf, 0x03, 0x00, 0x9e, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xa8, 0x18, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xa8, 0x02, 0x60, 0xbe, 0x58, 0x42, 0x01, 0x57, 0x9e, 0x9e, 0x58, 0x80, 0xec, 
+0xc0, 0x2f, 0x25, 0x05, 0x00, 0x61, 0x38, 0x48, 0x1c, 0x8a, 0x9e, 0x59, 0x40, 0x01, 0x38, 0x48, 0x0a, 0x96, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xa8, 0x03, 0x60, 0xbe, 0x58, 0x42, 0x01, 0x44, 0x9e, 0x9e, 0x58, 0x42, 0x01, 0x03, 0x61, 0x19, 0x48, 0x09, 0x88, 0x9e, 0x58, 0xc0, 0x00, 0x38, 0xaa, 0xbe, 0x58, 0xc0, 0x00, 0x85, 0xaa, 0x00, 0x60, 0xbe, 0x58, 0x42, 0x01, 0x9e, 0x58, 0x20, 0x05, 0x18, 0x10, 0x32, 0x8a, 0x9e, 0x59, 0x40, 0x01, 0x38, 0x48, 0x16, 0x96, 0x9e, 0x58, 0xc0, 0x00, 0x30, 0xac, 0x12, 0x90, 0x9e, 0x58, 0x3f, 0x01, 0x19, 0x00, 0x9e, 0x59, 0x21, 0x05, 0x19, 0x48, 0x20, 0x9a, 0x21, 0x58, 0x9e, 0x59, 0xc0, 0x00, 0x39, 0xa8, 0xbe, 0x59, 0xc0, 0x00, 0x85, 0xa8, 0x04, 0x61, 0xbe, 0x59, 0x42, 0x01, 0x18, 0x9e, 0x9e, 0x58, 0x3f, 0x01, 0x4d, 0xbd, 
+0x00, 0x30, 0x19, 0x10, 0x00, 0x61, 0x19, 0x48, 0x0f, 0x94, 0x21, 0x58, 0x9e, 0x5f, 0x42, 0x01, 0x04, 0x66, 0xfe, 0x48, 0x09, 0x88, 0x9e, 0x59, 0xc0, 0x00, 0x39, 0xaa, 0xbe, 0x59, 0xc0, 0x00, 0x85, 0xaa, 0x00, 0x61, 0xbe, 0x59, 0x42, 0x01, 0xbe, 0x58, 0x3f, 0x01, 0x00, 0x9e, 0xb3, 0x61, 0x02, 0x69, 0x30, 0x39, 0x0a, 0x04, 0x9e, 0x5a, 0x42, 0x01, 0x5d, 0x59, 0x9e, 0x58, 0xab, 0x04, 0x08, 0x58, 0x08, 0x58, 0x02, 0x63, 0x1b, 0x48, 0x10, 0x8a, 0x01, 0x63, 0x1b, 0x48, 0x17, 0x8a, 0x05, 0x63, 0x1b, 0x48, 0x1b, 0x8a, 0x03, 0x63, 0x1b, 0x48, 0x22, 0x8a, 0x04, 0x63, 0x1b, 0x48, 0x23, 0x8a, 0x08, 0x63, 0x1b, 0x48, 0x31, 0x8a, 0x34, 0x9e, 0x9e, 0x5a, 0x40, 0x01, 0x5d, 0x59, 0x9e, 0x5a, 0xc9, 0x03, 0x5d, 0x59, 0x9e, 0x5a, 0xcf, 0x03, 0x5d, 0x59, 0x2a, 0x9e, 0x9e, 0x5a, 0xd0, 0x03, 0x6f, 0xf4, 
+0x40, 0x30, 0x5d, 0x59, 0x9e, 0x5a, 0xc9, 0x03, 0x5d, 0x59, 0x23, 0x9e, 0x9e, 0x5a, 0x40, 0x01, 0x5d, 0x59, 0x9e, 0x5a, 0xca, 0x03, 0x5d, 0x59, 0x9e, 0x5a, 0xb1, 0x00, 0x5d, 0x59, 0x19, 0x9e, 0x9e, 0x5a, 0x40, 0x01, 0x5d, 0x59, 0x15, 0x9e, 0x9e, 0x5a, 0x40, 0x01, 0x5d, 0x59, 0x9e, 0x5a, 0xc1, 0x03, 0x5d, 0x59, 0x9e, 0x5a, 0xc9, 0x03, 0x5d, 0x59, 0x00, 0x62, 0x9e, 0x58, 0xc0, 0x00, 0x30, 0xac, 0x01, 0x90, 0x01, 0x62, 0x5d, 0x59, 0x04, 0x9e, 0x9e, 0x5a, 0x40, 0x01, 0x5d, 0x59, 0x00, 0x9e, 0x3a, 0x38, 0x70, 0x65, 0x00, 0x60, 0xbe, 0x58, 0x40, 0x01, 0x9e, 0x58, 0xb1, 0x00, 0x19, 0x10, 0x01, 0x94, 0x00, 0x60, 0x07, 0x38, 0x99, 0x30, 0xa3, 0x5e, 0x00, 0x63, 0xc2, 0x39, 0x01, 0x00, 0x38, 0x62, 0x03, 0x6a, 0x3a, 0x48, 0x01, 0x96, 0x23, 0x5b, 0x00, 0x64, 0xc0, 0x39, 0x01, 0x00, 0xf1, 0x77, 
+0x80, 0x30, 0x38, 0x62, 0x03, 0x6a, 0x50, 0x3a, 0x0b, 0x04, 0x3a, 0x48, 0x01, 0x98, 0x23, 0x5c, 0xff, 0x60, 0xff, 0x68, 0x61, 0x59, 0x7c, 0x48, 0x02, 0x82, 0x01, 0x60, 0x81, 0x59, 0xc3, 0x5a, 0x22, 0x01, 0x9e, 0x5a, 0x40, 0x01, 0x3a, 0x48, 0x05, 0x96, 0xbe, 0x59, 0x40, 0x01, 0xbe, 0x5e, 0x41, 0x01, 0x01, 0x5f, 0x19, 0x05, 0x9e, 0x5e, 0x41, 0x01, 0xc3, 0x59, 0xc7, 0x00, 0x03, 0x58, 0x20, 0x11, 0x2c, 0x62, 0x01, 0x6a, 0x3a, 0x48, 0x09, 0x98, 0x9e, 0x58, 0x41, 0x01, 0x7f, 0xac, 0x02, 0x90, 0x78, 0xa8, 0x01, 0x9e, 0x70, 0xa8, 0xbe, 0x58, 0x41, 0x01, 0x3a, 0x38, 0x01, 0x5d, 0x20, 0xaa, 0x00, 0x63, 0x25, 0xac, 0x02, 0x90, 0xff, 0x63, 0x7f, 0x6b, 0x9e, 0x59, 0x41, 0x01, 0x1e, 0x58, 0x79, 0xac, 0x01, 0x90, 0x19, 0x00, 0x24, 0x39, 0xff, 0x3f, 0x20, 0x11, 0x38, 0x62, 0x03, 0x6a, 0x3e, 0x77, 
+0xc0, 0x30, 0x3a, 0x48, 0x01, 0x96, 0x23, 0x5b, 0x00, 0x64, 0x25, 0xac, 0x02, 0x90, 0xff, 0x64, 0x7f, 0x6c, 0x9e, 0x59, 0x41, 0x01, 0x3e, 0x58, 0x71, 0xac, 0x01, 0x90, 0x19, 0x00, 0x24, 0x39, 0xff, 0x3f, 0x20, 0x01, 0x38, 0x62, 0x03, 0x6a, 0x50, 0x3a, 0x0b, 0x04, 0x3a, 0x48, 0x01, 0x98, 0x23, 0x5c, 0x61, 0x5a, 0x25, 0xac, 0x04, 0x92, 0x7c, 0x48, 0x01, 0x98, 0x81, 0x5a, 0x03, 0x9e, 0x7c, 0x48, 0x01, 0x96, 0x81, 0x5a, 0x9e, 0x58, 0x41, 0x01, 0x04, 0x38, 0xff, 0x3f, 0x03, 0x58, 0xe8, 0x61, 0x03, 0x69, 0x02, 0x02, 0x19, 0x40, 0x3c, 0x5a, 0x3a, 0x38, 0xff, 0x60, 0x7f, 0x68, 0xc2, 0x61, 0x03, 0x69, 0x6f, 0x38, 0xf4, 0x30, 0x1d, 0x59, 0x1a, 0x38, 0x9e, 0x58, 0xb1, 0x00, 0x19, 0x10, 0x01, 0x94, 0x00, 0x60, 0x37, 0x61, 0x03, 0x69, 0xbe, 0x59, 0xcb, 0x03, 0x9e, 0x59, 0x71, 0x00, 0xa4, 0x6e, 
+0x00, 0x31, 0xbe, 0x59, 0xcd, 0x03, 0x9e, 0x59, 0x70, 0x00, 0xbe, 0x59, 0xcc, 0x03, 0x39, 0x61, 0x03, 0x69, 0x30, 0x39, 0x0b, 0x04, 0xbe, 0x59, 0xce, 0x03, 0x00, 0x61, 0xbe, 0x59, 0xc0, 0x03, 0x00, 0x67, 0x07, 0x38, 0x5b, 0x31, 0x70, 0x61, 0x30, 0x39, 0xc0, 0x03, 0x23, 0x58, 0x1b, 0x10, 0xcb, 0x61, 0x03, 0x69, 0x30, 0x39, 0xc0, 0x03, 0x23, 0x59, 0xff, 0x66, 0x7f, 0x6e, 0x19, 0x48, 0x14, 0x9a, 0x07, 0x5a, 0x5f, 0x48, 0x11, 0x96, 0x5e, 0x48, 0x0f, 0x98, 0xc2, 0x64, 0x03, 0x6c, 0x90, 0x3c, 0xc0, 0x03, 0x83, 0x5b, 0xff, 0x66, 0x7f, 0x6e, 0x7e, 0x48, 0x02, 0x88, 0x41, 0x5b, 0x01, 0x9e, 0x62, 0x03, 0x7b, 0x5c, 0x41, 0x5e, 0xea, 0x9f, 0x70, 0x61, 0x30, 0x39, 0xc0, 0x03, 0x23, 0x58, 0x1b, 0x00, 0xcd, 0x61, 0x03, 0x69, 0x30, 0x39, 0xc0, 0x03, 0x23, 0x59, 0xff, 0x66, 0x7f, 0x6e, 0xf3, 0x08, 
+0x40, 0x31, 0x19, 0x48, 0x14, 0x94, 0x05, 0x5a, 0x5f, 0x48, 0x11, 0x96, 0x5e, 0x48, 0x0f, 0x98, 0xc4, 0x64, 0x03, 0x6c, 0x90, 0x3c, 0xc0, 0x03, 0x83, 0x5b, 0xff, 0x66, 0x7f, 0x6e, 0x7e, 0x48, 0x02, 0x88, 0x41, 0x5b, 0x01, 0x9e, 0x62, 0x03, 0x7b, 0x5c, 0x41, 0x5e, 0xea, 0x9f, 0x9e, 0x5a, 0xc0, 0x03, 0x19, 0x02, 0xbe, 0x5a, 0xc0, 0x03, 0x1a, 0x38, 0xc2, 0x60, 0x03, 0x68, 0xff, 0x61, 0x7f, 0x69, 0x6f, 0x38, 0x66, 0x31, 0x03, 0x5a, 0x59, 0x48, 0x01, 0x94, 0x41, 0x59, 0x19, 0x00, 0x00, 0x60, 0xff, 0x62, 0x7f, 0x6a, 0x3a, 0x48, 0x01, 0x8a, 0x21, 0x58, 0xbe, 0x58, 0xc1, 0x03, 0x3a, 0x38, 0x9e, 0x58, 0xc0, 0x00, 0x30, 0xaa, 0x9e, 0x59, 0x40, 0x01, 0x9e, 0x5a, 0xad, 0x04, 0x3a, 0x48, 0x0d, 0x96, 0x9e, 0x59, 0xc1, 0x03, 0x9e, 0x5a, 0xae, 0x04, 0x3a, 0x48, 0x07, 0x96, 0x9e, 0x59, 0x2a, 0x92, 
+0x80, 0x31, 0xc9, 0x03, 0x9e, 0x5a, 0xaf, 0x04, 0x3a, 0x48, 0x01, 0x96, 0x30, 0xa8, 0xbe, 0x58, 0xc0, 0x00, 0x3a, 0x38, 0x9e, 0x58, 0x0b, 0x04, 0x38, 0x61, 0x03, 0x69, 0xff, 0x62, 0x7f, 0x6a, 0x07, 0x38, 0x95, 0x31, 0x23, 0x58, 0x1a, 0x48, 0x01, 0x94, 0x01, 0x5a, 0x19, 0x01, 0xbe, 0x5a, 0xc6, 0x03, 0x3a, 0x38, 0x00, 0x62, 0x9e, 0x58, 0x02, 0x04, 0x18, 0x10, 0x0e, 0x8a, 0x25, 0x61, 0x02, 0x69, 0x30, 0x39, 0x0a, 0x04, 0x30, 0x39, 0x01, 0x04, 0x19, 0x10, 0x07, 0x38, 0xab, 0x31, 0x23, 0x58, 0x1a, 0x48, 0x01, 0x9a, 0x01, 0x5a, 0x19, 0x01, 0xbe, 0x5a, 0xc7, 0x03, 0x3a, 0x38, 0x70, 0x66, 0xc3, 0x5e, 0x71, 0x67, 0xe3, 0x5f, 0xc1, 0x5a, 0xc3, 0x59, 0xe3, 0x5b, 0x3b, 0x48, 0x02, 0x98, 0x61, 0x59, 0xe1, 0x5a, 0x3a, 0x38, 0x00, 0x65, 0x42, 0x3b, 0x01, 0x00, 0x38, 0x64, 0x03, 0x6c, 0x2c, 0x4e, 
+0xc0, 0x31, 0x7c, 0x48, 0x01, 0x96, 0x63, 0x5d, 0x00, 0x66, 0x40, 0x3b, 0x01, 0x00, 0x38, 0x64, 0x03, 0x6c, 0x90, 0x3c, 0x0b, 0x04, 0x7c, 0x48, 0x01, 0x98, 0x63, 0x5e, 0xa1, 0x58, 0xbe, 0x48, 0x01, 0x98, 0xc1, 0x58, 0x20, 0x07, 0xe8, 0x60, 0x03, 0x68, 0x19, 0x40, 0x3c, 0x5f, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x00, 0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 0x20, 0x00, 0x28, 0x00, 0x40, 0x00, 0x30, 0x00, 0x48, 0x00, 0x38, 0x00, 0x50, 0x00, 0x58, 0x00, 0x60, 0x00, 0x68, 0x00, 0x70, 0x00, 0x78, 0x53, 0x60, 0x16, 0x39, 0x1c, 0x00, 0x91, 0x8a, 0x54, 0x60, 0x16, 0x39, 0x1c, 0x00, 0x98, 0x3a, 0xb3, 0x35, 0x45, 0x60, 0x16, 0x39, 0x1c, 0x00, 0x11, 0x88, 0x49, 0x60, 0x16, 0x39, 0x1d, 0x00, 0x0d, 0x88, 0x41, 0x60, 0x16, 0x39, 0x1e, 0x00, 0x09, 0x88, 0x50, 0x60, 0xc6, 0xf3, 
+0x00, 0x32, 0x16, 0x39, 0x1f, 0x00, 0x05, 0x88, 0xff, 0x60, 0xff, 0x68, 0x18, 0xc7, 0x70, 0xc0, 0x3a, 0x38, 0x77, 0xf2, 0x26, 0x38, 0x56, 0x00, 0x02, 0x88, 0x84, 0xaa, 0x3a, 0x38, 0x77, 0xf2, 0x26, 0x38, 0xa6, 0x00, 0x02, 0x88, 0x84, 0xa8, 0x3a, 0x38, 0x77, 0xf2, 0x26, 0x38, 0x57, 0x00, 0x02, 0x88, 0xca, 0xa8, 0x3a, 0x38, 0x77, 0xf2, 0x26, 0x38, 0xa7, 0x00, 0x02, 0x88, 0xca, 0xaa, 0x3a, 0x38, 0x77, 0xf2, 0x26, 0x38, 0xa8, 0x00, 0x03, 0x88, 0xa1, 0xa8, 0xbc, 0xa8, 0x3a, 0x38, 0x77, 0xf2, 0x26, 0x38, 0x77, 0x00, 0x02, 0x88, 0x83, 0xa8, 0x3a, 0x38, 0x77, 0xf2, 0x26, 0x38, 0x88, 0x00, 0x02, 0x88, 0x94, 0xa8, 0x3a, 0x38, 0x57, 0x60, 0x16, 0x39, 0x1c, 0x00, 0x98, 0x3a, 0xfd, 0x37, 0x59, 0x60, 0x16, 0x39, 0x1c, 0x00, 0x98, 0x3a, 0xff, 0x37, 0x9f, 0x60, 0x16, 0x39, 0x1c, 0x00, 0xac, 0xe7, 
+0x40, 0x32, 0x0d, 0x88, 0x00, 0x60, 0x16, 0x39, 0x1d, 0x00, 0x36, 0x38, 0x1e, 0x00, 0x06, 0x88, 0x01, 0x60, 0x16, 0x39, 0x1f, 0x00, 0x02, 0x88, 0xb9, 0xaa, 0x9b, 0xaa, 0x3a, 0x38, 0x96, 0x60, 0x16, 0x39, 0x1c, 0x00, 0x05, 0x88, 0xf1, 0x60, 0x16, 0x39, 0x21, 0x00, 0x98, 0x3a, 0xac, 0x37, 0x97, 0x60, 0x16, 0x39, 0x1c, 0x00, 0x05, 0x88, 0xf1, 0x60, 0x16, 0x39, 0x21, 0x00, 0x98, 0x3a, 0xe1, 0x37, 0x98, 0x60, 0x16, 0x39, 0x1c, 0x00, 0x05, 0x88, 0xf1, 0x60, 0x16, 0x39, 0x21, 0x00, 0x98, 0x3a, 0xc4, 0x37, 0x77, 0xf2, 0x26, 0x38, 0x55, 0x00, 0x02, 0x88, 0xba, 0xaa, 0x3a, 0x38, 0x77, 0xf2, 0x26, 0x38, 0xa5, 0x00, 0x03, 0x88, 0xba, 0xa8, 0x81, 0xaa, 0x3a, 0x38, 0x3a, 0x38, 0x1c, 0x70, 0x14, 0x39, 0x1d, 0x00, 0x34, 0x38, 0x1e, 0x00, 0x14, 0x39, 0x1f, 0x00, 0x3a, 0x38, 0xa2, 0xa8, 0x25, 0x56, 
+0x80, 0x32, 0x04, 0x60, 0x27, 0x78, 0x52, 0x60, 0x28, 0x78, 0x1d, 0x70, 0x29, 0x78, 0x00, 0x60, 0x2a, 0x78, 0x01, 0x60, 0x2b, 0x78, 0x1d, 0x70, 0x7f, 0x38, 0x08, 0x58, 0x3f, 0x20, 0x00, 0x39, 0x92, 0x32, 0x29, 0x58, 0x5e, 0x58, 0xa2, 0x32, 0x4b, 0x33, 0x79, 0x33, 0x7a, 0x33, 0x7b, 0x33, 0x7c, 0x33, 0x96, 0x33, 0xe6, 0x33, 0x07, 0x34, 0x3b, 0x34, 0x50, 0x33, 0xa4, 0x34, 0xd3, 0x34, 0xd4, 0x34, 0x02, 0x35, 0x28, 0x35, 0x1d, 0x70, 0x06, 0x39, 0x00, 0x00, 0x0d, 0x8a, 0x06, 0x39, 0x0e, 0x00, 0x3a, 0x8a, 0x06, 0x39, 0x0f, 0x00, 0x52, 0x8a, 0x06, 0x39, 0x01, 0x00, 0x53, 0x8a, 0x06, 0x39, 0x02, 0x00, 0x79, 0x8a, 0x3a, 0x38, 0xfd, 0x60, 0x3f, 0x68, 0x09, 0x59, 0x26, 0x38, 0xaa, 0x55, 0x0c, 0x88, 0xfe, 0x60, 0x3f, 0x68, 0x09, 0x59, 0x26, 0x38, 0xcc, 0x33, 0x06, 0x88, 0x11, 0x63, 0x81, 0x22, 
+0xc0, 0x32, 0x9e, 0x5c, 0x07, 0x04, 0x84, 0x3c, 0xff, 0x00, 0x03, 0x9e, 0x00, 0x63, 0x00, 0x64, 0x00, 0x9e, 0x61, 0x58, 0x04, 0x39, 0xf0, 0x00, 0x7f, 0x38, 0x28, 0x59, 0x35, 0x39, 0x29, 0x00, 0x29, 0x79, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x81, 0x58, 0x04, 0x3a, 0xf0, 0x00, 0x7f, 0x38, 0x48, 0x5a, 0x41, 0x2a, 0x2a, 0x7a, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x35, 0x39, 0x2b, 0x00, 0x2b, 0x79, 0x3a, 0x38, 0x06, 0x60, 0x04, 0x39, 0xf0, 0x00, 0x7f, 0x38, 0x28, 0x59, 0x35, 0x39, 0x29, 0x00, 0x29, 0x79, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x20, 0x60, 0x04, 0x3a, 0xf0, 0x00, 0x7f, 0x38, 0x48, 0x5a, 0x41, 0x2a, 0x2a, 0x7a, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x35, 0x39, 0x2b, 0x00, 0x2b, 0x79, 0x3a, 0x38, 0x14, 0x60, 0x7f, 0x68, 0x80, 0xee, 
+0x00, 0x33, 0x2a, 0x78, 0x3a, 0x38, 0x29, 0x70, 0x04, 0x38, 0xf0, 0x00, 0x29, 0x78, 0x1c, 0x60, 0x02, 0x68, 0x09, 0x58, 0x04, 0x38, 0x00, 0xff, 0xff, 0x38, 0x08, 0x58, 0x04, 0x39, 0xf0, 0x00, 0x7f, 0x38, 0x28, 0x59, 0x35, 0x39, 0x29, 0x00, 0x29, 0x79, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x1c, 0x60, 0x02, 0x68, 0x09, 0x58, 0x04, 0x38, 0xff, 0x00, 0x04, 0x3a, 0xf0, 0x00, 0x7f, 0x38, 0x48, 0x5a, 0x41, 0x2a, 0x2a, 0x7a, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x35, 0x39, 0x2b, 0x00, 0x2b, 0x79, 0x3a, 0x38, 0x9e, 0x58, 0x28, 0x05, 0xfe, 0x58, 0x04, 0x38, 0xff, 0x00, 0x04, 0x39, 0xf0, 0x00, 0x7f, 0x38, 0x28, 0x59, 0x29, 0x79, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x9e, 0x58, 0x28, 0x05, 0x04, 0x38, 0xff, 0x00, 0x04, 0x3a, 0xf0, 0x00, 0x7f, 0x38, 0x02, 0xc0, 
+0x40, 0x33, 0x48, 0x5a, 0x41, 0x2a, 0x2a, 0x7a, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x35, 0x39, 0x2b, 0x00, 0x2b, 0x79, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x39, 0x10, 0x00, 0x01, 0x8a, 0x3a, 0x38, 0x29, 0x70, 0x04, 0x38, 0xf0, 0x00, 0x29, 0x78, 0x1c, 0x60, 0x02, 0x68, 0x09, 0x58, 0x04, 0x38, 0x00, 0xff, 0xff, 0x38, 0x08, 0x58, 0x04, 0x39, 0xf0, 0x00, 0x7f, 0x38, 0x28, 0x59, 0x35, 0x39, 0x29, 0x00, 0x29, 0x79, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x1c, 0x60, 0x02, 0x68, 0x09, 0x58, 0x04, 0x38, 0xff, 0x00, 0x04, 0x3a, 0xf0, 0x00, 0x7f, 0x38, 0x48, 0x5a, 0x41, 0x2a, 0x2a, 0x7a, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x35, 0x39, 0x2b, 0x00, 0x2b, 0x79, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x1d, 0x70, 0x04, 0x39, 0xf0, 0x00, 0x06, 0x3a, 0xc2, 0xb2, 
+0x80, 0x33, 0x50, 0x00, 0x04, 0x8a, 0x06, 0x3a, 0x51, 0x00, 0x0c, 0x8a, 0x3a, 0x38, 0x00, 0x60, 0xc3, 0xac, 0x02, 0x90, 0x18, 0xa8, 0x03, 0x9e, 0xf3, 0xac, 0x01, 0x90, 0x00, 0xa8, 0x20, 0x29, 0x29, 0x79, 0x3a, 0x38, 0x29, 0x78, 0x9e, 0x59, 0x49, 0x00, 0x2a, 0x79, 0x3a, 0x38, 0xb8, 0xac, 0x04, 0x90, 0xc0, 0xac, 0x01, 0x92, 0x01, 0x9e, 0x00, 0x9e, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0xa2, 0x33, 0x09, 0x59, 0x5e, 0x59, 0xb2, 0x33, 0xc5, 0x33, 0xc6, 0x33, 0xc7, 0x33, 0xda, 0x33, 0xdb, 0x33, 0xdc, 0x33, 0xdd, 0x33, 0xde, 0x33, 0xdf, 0x33, 0xe0, 0x33, 0xe1, 0x33, 0xe2, 0x33, 0xe3, 0x33, 0xe4, 0x33, 0xe5, 0x33, 0x9e, 0x5a, 0x03, 0x04, 0x18, 0x32, 0x03, 0x88, 0x9e, 0x5a, 0xd9, 0x04, 0x02, 0x9e, 0x9e, 0x5a, 0xda, 0x04, 0x2a, 0x7a, 0x44, 0x3a, 0x00, 0x0f, 0xfe, 0x5a, 0x7f, 0x38, 0x35, 0x50, 
+0xc0, 0x33, 0x46, 0x5a, 0x55, 0x3a, 0x2b, 0x00, 0x2b, 0x7a, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x9e, 0x5a, 0x03, 0x04, 0x18, 0x32, 0x03, 0x88, 0x9e, 0x5a, 0xda, 0x04, 0x02, 0x9e, 0x9e, 0x5a, 0xd9, 0x04, 0x2a, 0x7a, 0x44, 0x3a, 0x00, 0x0f, 0xfe, 0x5a, 0x7f, 0x38, 0x46, 0x5a, 0x55, 0x3a, 0x2b, 0x00, 0x2b, 0x7a, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0xec, 0x33, 0x09, 0x59, 0x5e, 0x59, 0xf0, 0x33, 0xf6, 0x33, 0xfc, 0x33, 0xfe, 0x33, 0x40, 0x60, 0x02, 0x68, 0x00, 0x63, 0x3c, 0x6b, 0xbe, 0xed, 0x0b, 0x9e, 0x00, 0x60, 0x3c, 0x68, 0x00, 0x63, 0x40, 0x6b, 0xbe, 0xed, 0x05, 0x9e, 0xd2, 0xed, 0x03, 0x9e, 0x9e, 0x5a, 0x31, 0x01, 0x93, 0x4c, 
+0x00, 0x34, 0x00, 0x9e, 0xbe, 0x5a, 0x2b, 0x00, 0xfe, 0x5a, 0xbe, 0x5a, 0x2a, 0x00, 0x3a, 0x38, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0x0e, 0x34, 0x09, 0x59, 0x01, 0x60, 0x5e, 0x59, 0x1e, 0x34, 0x1f, 0x34, 0x20, 0x34, 0x21, 0x34, 0x22, 0x34, 0x23, 0x34, 0x24, 0x34, 0x25, 0x34, 0x26, 0x34, 0x27, 0x34, 0x28, 0x34, 0x29, 0x34, 0x2a, 0x34, 0x2b, 0x34, 0x2c, 0x34, 0x2d, 0x34, 0x3a, 0x38, 0x3a, 0x38, 0x0d, 0x9e, 0x0c, 0x9e, 0x0b, 0x9e, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x07, 0x9e, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x04, 0x39, 0xff, 0x00, 0x2a, 0x79, 0x04, 0x39, 0x00, 0x03, 0xfe, 0x59, 0x7f, 0x38, 0x26, 0x59, 0x2b, 0x72, 0x3f, 0x22, 0x41, 0x2a, 0x2b, 0x7a, 0x3a, 0x38, 0x06, 0x60, 0x27, 0x78, 0x00, 0x60, 0x2b, 0x78, 0x2c, 0x78, 0x7e, 0xfb, 
+0x40, 0x34, 0x01, 0x60, 0x2d, 0x78, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0x48, 0x34, 0x09, 0x59, 0x5e, 0x59, 0x58, 0x34, 0x5b, 0x34, 0x5e, 0x34, 0x61, 0x34, 0x64, 0x34, 0x67, 0x34, 0x68, 0x34, 0x69, 0x34, 0x6a, 0x34, 0x6b, 0x34, 0x6c, 0x34, 0x6d, 0x34, 0x6e, 0x34, 0x77, 0x34, 0x7d, 0x34, 0x8a, 0x34, 0x9e, 0x58, 0x67, 0x00, 0x35, 0x9e, 0x9e, 0x58, 0x68, 0x00, 0x32, 0x9e, 0x9e, 0x58, 0x69, 0x00, 0x2f, 0x9e, 0x9e, 0x58, 0x6a, 0x00, 0x2c, 0x9e, 0x9e, 0x58, 0x6b, 0x00, 0x29, 0x9e, 0x28, 0x9e, 0x27, 0x9e, 0x26, 0x9e, 0x25, 0x9e, 0x24, 0x9e, 0x3a, 0x38, 0x3a, 0x38, 0x00, 0x60, 0xb9, 0xac, 0x01, 0x90, 0x00, 0xa8, 0xba, 0xac, 0x01, 0x90, 0x08, 0xa8, 0x2a, 0x78, 0x3a, 0x38, 0x00, 0x60, 0xbb, 0xac, 0x01, 0x90, 0x00, 0xa8, 0x2a, 0x78, 0x3a, 0x38, 0x00, 0x60, 0x00, 0x71, 0x21, 0xac, 0x83, 0xa9, 
+0x80, 0x34, 0x01, 0x90, 0x00, 0xa8, 0x29, 0xac, 0x01, 0x90, 0x08, 0xa8, 0x31, 0xac, 0x01, 0x90, 0x10, 0xa8, 0x2a, 0x78, 0x3a, 0x38, 0x00, 0x60, 0xa9, 0xac, 0x01, 0x90, 0x01, 0x60, 0x2a, 0x78, 0x3a, 0x38, 0x04, 0x39, 0x00, 0xff, 0xfe, 0x59, 0x04, 0x3a, 0xff, 0x00, 0x2a, 0x79, 0x2b, 0x7a, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x38, 0xa0, 0x00, 0x02, 0x8a, 0xa2, 0xaa, 0x3a, 0x38, 0x01, 0x60, 0xf9, 0xac, 0x01, 0x92, 0x00, 0xaa, 0x2a, 0x78, 0x3a, 0x38, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0xaa, 0x34, 0x09, 0x59, 0x5e, 0x59, 0xba, 0x34, 0xc0, 0x34, 0xc5, 0x34, 0xc6, 0x34, 0xc7, 0x34, 0xc8, 0x34, 0xc9, 0x34, 0xca, 0x34, 0xcb, 0x34, 0xcc, 0x34, 0xcd, 0x34, 0xce, 0x34, 0xcf, 0x34, 0xd0, 0x34, 0xd1, 0x34, 0xd2, 0x34, 0x01, 0x60, 0x90, 0xac, 0x01, 0x8a, 0x00, 0xaa, 0x2a, 0x78, 0x3a, 0x38, 0xfa, 0x86, 
+0xc0, 0x34, 0x03, 0x60, 0x14, 0x38, 0x00, 0x00, 0x2a, 0x78, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0xda, 0x34, 0x09, 0x59, 0x5e, 0x59, 0xea, 0x34, 0xeb, 0x34, 0xec, 0x34, 0xed, 0x34, 0xf6, 0x34, 0xf7, 0x34, 0xf8, 0x34, 0xf9, 0x34, 0xfa, 0x34, 0xfb, 0x34, 0xfc, 0x34, 0xfd, 0x34, 0xfe, 0x34, 0xff, 0x34, 0x00, 0x35, 0x01, 0x35, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x1b, 0x63, 0x02, 0x6b, 0x69, 0x58, 0xbe, 0x58, 0x2b, 0x00, 0xfe, 0x58, 0xbe, 0x58, 0x2a, 0x00, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x37, 0x0c, 
+0x00, 0x35, 0x3a, 0x38, 0x3a, 0x38, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0x08, 0x35, 0x09, 0x59, 0x5e, 0x59, 0x18, 0x35, 0x19, 0x35, 0x1a, 0x35, 0x1b, 0x35, 0x1c, 0x35, 0x1d, 0x35, 0x1e, 0x35, 0x1f, 0x35, 0x20, 0x35, 0x21, 0x35, 0x22, 0x35, 0x23, 0x35, 0x24, 0x35, 0x25, 0x35, 0x26, 0x35, 0x27, 0x35, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x39, 0xf0, 0x00, 0x0e, 0x8a, 0x06, 0x39, 0xf1, 0x00, 0x2d, 0x8a, 0x06, 0x39, 0xf2, 0x00, 0x47, 0x8a, 0x06, 0x39, 0xfe, 0x00, 0x66, 0x8a, 0x06, 0x39, 0xff, 0x00, 0x6f, 0x8a, 0xa2, 0xaa, 0x3a, 0x38, 0x9e, 0x58, 0x08, 0x04, 0xfe, 0x58, 0x04, 0x38, 0xff, 0x00, 0x04, 0x39, 0xc0, 0x7a, 
+0x40, 0x35, 0xf0, 0x00, 0x7f, 0x38, 0x28, 0x59, 0x35, 0x39, 0x29, 0x00, 0x29, 0x79, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x9e, 0x58, 0x08, 0x04, 0x04, 0x38, 0xff, 0x00, 0x04, 0x3a, 0xf0, 0x00, 0x7f, 0x38, 0x48, 0x5a, 0x41, 0x2a, 0x2a, 0x7a, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x35, 0x39, 0x2b, 0x00, 0x2b, 0x79, 0x3a, 0x38, 0x20, 0x60, 0x04, 0x39, 0xf0, 0x00, 0x7f, 0x38, 0x28, 0x59, 0x29, 0x72, 0x44, 0x3a, 0xf0, 0x00, 0x22, 0x29, 0x29, 0x79, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x01, 0x60, 0x04, 0x3a, 0xf0, 0x00, 0x7f, 0x38, 0x48, 0x5a, 0x41, 0x2a, 0x2a, 0x7a, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x35, 0x39, 0x2b, 0x00, 0x2b, 0x79, 0x3a, 0x38, 0x9e, 0x58, 0x18, 0x04, 0xfe, 0x58, 0x04, 0x38, 0xff, 0x00, 0x04, 0x39, 0xf0, 0x00, 0xcc, 0xf8, 
+0x80, 0x35, 0x7f, 0x38, 0x28, 0x59, 0x25, 0x39, 0xf0, 0x00, 0x29, 0x79, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x9e, 0x58, 0x18, 0x04, 0x04, 0x38, 0xff, 0x00, 0x04, 0x3a, 0xf0, 0x00, 0x7f, 0x38, 0x48, 0x5a, 0x41, 0x2a, 0x2a, 0x7a, 0x04, 0x39, 0x0f, 0x00, 0x7f, 0x38, 0x26, 0x59, 0x35, 0x39, 0x2b, 0x00, 0x2b, 0x79, 0x3a, 0x38, 0xc0, 0x60, 0x08, 0x68, 0x04, 0x39, 0xff, 0x00, 0x2b, 0x79, 0xfe, 0x58, 0x04, 0x39, 0xff, 0x00, 0x2a, 0x79, 0xfe, 0x61, 0x29, 0x79, 0x3a, 0x38, 0x30, 0x60, 0x0b, 0x68, 0x04, 0x39, 0xff, 0x00, 0x2b, 0x79, 0xfe, 0x58, 0x04, 0x39, 0xff, 0x00, 0x2a, 0x79, 0xff, 0x61, 0x29, 0x79, 0x3a, 0x38, 0x1d, 0x70, 0x7f, 0x38, 0x08, 0x58, 0x3f, 0x20, 0x00, 0x39, 0xbb, 0x35, 0x29, 0x58, 0x5e, 0x58, 0xcb, 0x35, 0xd8, 0x35, 0xd9, 0x35, 0xda, 0x35, 0xdb, 0x35, 0x47, 0x86, 
+0xc0, 0x35, 0xdc, 0x35, 0xfc, 0x35, 0x10, 0x36, 0x11, 0x36, 0x40, 0x36, 0x87, 0x36, 0x98, 0x36, 0xa2, 0x36, 0xee, 0x36, 0x58, 0x37, 0xab, 0x37, 0x1e, 0x70, 0x12, 0x61, 0x19, 0x48, 0x08, 0x88, 0x1f, 0x70, 0x34, 0x61, 0x19, 0x48, 0x04, 0x88, 0xff, 0x60, 0xff, 0x68, 0x18, 0xc7, 0x70, 0xc0, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x39, 0x58, 0x00, 0x07, 0x8a, 0x06, 0x39, 0x50, 0x00, 0x07, 0x8a, 0x06, 0x39, 0x51, 0x00, 0x0d, 0x8a, 0x3a, 0x38, 0xda, 0xa8, 0xf3, 0xaa, 0x3a, 0x38, 0xda, 0xaa, 0xc3, 0xaa, 0xf3, 0xaa, 0x00, 0x61, 0xbe, 0x59, 0x49, 0x00, 0xbe, 0x59, 0x4a, 0x00, 0x3a, 0x38, 0xda, 0xaa, 0xc3, 0xaa, 0xf3, 0xa8, 0x00, 0x61, 0xbe, 0x59, 0x49, 0x00, 0xbe, 0x59, 0x4a, 0x00, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x39, 0x60, 0x00, 0x07, 0x8a, 0xd4, 0x86, 
+0x00, 0x36, 0x06, 0x39, 0x68, 0x00, 0x07, 0x8a, 0x06, 0x39, 0x6c, 0x00, 0x07, 0x8a, 0x3a, 0x38, 0xb8, 0xa8, 0xc0, 0xaa, 0x3a, 0x38, 0xb8, 0xa8, 0xc0, 0xa8, 0x3a, 0x38, 0xb8, 0xaa, 0xc0, 0xaa, 0x3a, 0x38, 0x3a, 0x38, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0x20, 0x36, 0x09, 0x59, 0x1e, 0x70, 0x1f, 0x72, 0xd8, 0x22, 0xfe, 0x5a, 0x7f, 0x38, 0x48, 0x5a, 0x04, 0x38, 0xff, 0x00, 0x40, 0x28, 0x5e, 0x59, 0x30, 0x36, 0x31, 0x36, 0x32, 0x36, 0x33, 0x36, 0x34, 0x36, 0x35, 0x36, 0x36, 0x36, 0x37, 0x36, 0x38, 0x36, 0x39, 0x36, 0x3a, 0x36, 0x3b, 0x36, 0x3c, 0x36, 0x3d, 0x36, 0x3e, 0x36, 0x3f, 0x36, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x90, 0xbc, 
+0x40, 0x36, 0x1e, 0x70, 0xfe, 0x58, 0x15, 0x3a, 0x1f, 0x00, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0x4a, 0x36, 0x09, 0x59, 0x5e, 0x59, 0x5a, 0x36, 0x5d, 0x36, 0x60, 0x36, 0x63, 0x36, 0x66, 0x36, 0x69, 0x36, 0x6a, 0x36, 0x6b, 0x36, 0x6c, 0x36, 0x6d, 0x36, 0x6e, 0x36, 0x6f, 0x36, 0x70, 0x36, 0x71, 0x36, 0x77, 0x36, 0x78, 0x36, 0xbe, 0x5a, 0x62, 0x00, 0x3a, 0x38, 0xbe, 0x5a, 0x63, 0x00, 0x3a, 0x38, 0xbe, 0x5a, 0x64, 0x00, 0x3a, 0x38, 0xbe, 0x5a, 0x65, 0x00, 0x3a, 0x38, 0xbe, 0x5a, 0x66, 0x00, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x1e, 0x70, 0xbb, 0xaa, 0x00, 0xac, 0x01, 0x90, 0xbb, 0xa8, 0x3a, 0x38, 0x3a, 0x38, 0xa1, 0xaa, 0xa9, 0xaa, 0x1e, 0x70, 0x06, 0x39, 0x01, 0x00, 0x04, 0x8a, 0x06, 0x39, 0x00, 0x00, 0x5f, 0x25, 
+0x80, 0x36, 0x02, 0x8a, 0x3a, 0x38, 0xa9, 0xa8, 0xa9, 0xac, 0x01, 0x92, 0xa1, 0xa8, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x39, 0xa0, 0x00, 0x01, 0x8a, 0x3a, 0x38, 0x1e, 0x70, 0x06, 0x39, 0x01, 0x00, 0x04, 0x8a, 0x06, 0x39, 0x00, 0x00, 0x03, 0x8a, 0x3a, 0x38, 0xf9, 0xa8, 0x3a, 0x38, 0xf9, 0xa8, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x39, 0xb0, 0x00, 0x04, 0x8a, 0x06, 0x39, 0xb1, 0x00, 0x02, 0x8a, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x39, 0xc0, 0x00, 0x0a, 0x8a, 0x06, 0x39, 0xc1, 0x00, 0x19, 0x8a, 0x06, 0x39, 0xc2, 0x00, 0x27, 0x8a, 0x06, 0x39, 0xc3, 0x00, 0x32, 0x8a, 0x3a, 0x38, 0x1e, 0x70, 0x06, 0x39, 0x00, 0x00, 0x0d, 0x88, 0x1f, 0x70, 0x06, 0x39, 0x01, 0x00, 0x09, 0x88, 0xd8, 0xaa, 0xe9, 0xaa, 0x8d, 0xaa, 0x00, 0x60, 0xfe, 0x78, 0xfc, 0x78, 0xfd, 0x78, 0xbe, 0x58, 0x4c, 0xfc, 
+0xc0, 0x36, 0x00, 0x01, 0x3a, 0x38, 0x1e, 0x70, 0x06, 0x39, 0x00, 0x00, 0x0c, 0x88, 0x1f, 0x70, 0x06, 0x39, 0x01, 0x00, 0x08, 0x88, 0xd8, 0xa8, 0x01, 0x60, 0xfd, 0x78, 0x00, 0x60, 0xbe, 0x58, 0x43, 0x01, 0xbe, 0x58, 0x44, 0x01, 0x3a, 0x38, 0x1e, 0x70, 0x06, 0x39, 0x00, 0x00, 0x09, 0x88, 0x1f, 0x70, 0x06, 0x39, 0x01, 0x00, 0x05, 0x88, 0xf0, 0xaa, 0x9e, 0x58, 0x95, 0x04, 0xbe, 0x58, 0x4c, 0x00, 0x3a, 0x38, 0x1e, 0x70, 0x06, 0x39, 0x00, 0x00, 0x08, 0x88, 0x1f, 0x70, 0x06, 0x39, 0x01, 0x00, 0x04, 0x88, 0xf0, 0xa8, 0x00, 0x60, 0xbe, 0x58, 0x4c, 0x00, 0x3a, 0x38, 0x1d, 0x70, 0x06, 0x39, 0xd2, 0x00, 0x10, 0x8a, 0x06, 0x39, 0xd5, 0x00, 0x38, 0x8a, 0x06, 0x39, 0xd6, 0x00, 0x39, 0x8a, 0x06, 0x39, 0xd7, 0x00, 0x3a, 0x8a, 0x06, 0x39, 0xd8, 0x00, 0x43, 0x8a, 0x06, 0x39, 0xd9, 0x00, 0xf8, 0x16, 
+0x00, 0x37, 0x4d, 0x8a, 0x3a, 0x38, 0x1e, 0x70, 0xfe, 0x58, 0x15, 0x38, 0x1f, 0x00, 0xbe, 0x58, 0x3e, 0x01, 0x11, 0xc4, 0x1c, 0x70, 0xfe, 0x58, 0x15, 0x38, 0x1d, 0x00, 0xd3, 0x61, 0x54, 0x69, 0x01, 0x30, 0x41, 0xa9, 0x50, 0xb7, 0xe0, 0x2f, 0xd0, 0xb7, 0x41, 0xab, 0x1c, 0x70, 0xfe, 0x58, 0x15, 0x38, 0x1d, 0x00, 0x06, 0x39, 0xd2, 0x54, 0x09, 0x88, 0x06, 0x38, 0x88, 0xb5, 0xac, 0xb0, 0x1b, 0x60, 0x02, 0x68, 0x3e, 0x61, 0x01, 0x69, 0x1f, 0x38, 0x7a, 0x38, 0x00, 0x60, 0xac, 0xb0, 0x41, 0xa9, 0x50, 0xb7, 0x07, 0xaa, 0xd0, 0xb7, 0x41, 0xab, 0x3a, 0x38, 0x00, 0x60, 0xbe, 0x58, 0x33, 0x01, 0x3a, 0x38, 0x01, 0x60, 0xbe, 0x58, 0x33, 0x01, 0x3a, 0x38, 0x02, 0x60, 0xbe, 0x58, 0x33, 0x01, 0x00, 0x60, 0xbe, 0x58, 0x34, 0x01, 0xbe, 0x58, 0x35, 0x01, 0x1e, 0x70, 0xbe, 0x58, 0x36, 0x01, 0x06, 0xf4, 
+0x40, 0x37, 0x3a, 0x38, 0x02, 0x60, 0x01, 0x68, 0xbe, 0x58, 0x33, 0x01, 0x00, 0x60, 0xbe, 0x58, 0x34, 0x01, 0xbe, 0x58, 0x35, 0x01, 0x1e, 0x70, 0xbe, 0x58, 0x36, 0x01, 0x3a, 0x38, 0x02, 0x60, 0x03, 0x68, 0xbe, 0x58, 0x33, 0x01, 0x00, 0x60, 0xbe, 0x58, 0x34, 0x01, 0xbe, 0x58, 0x35, 0x01, 0x3a, 0x38, 0x1d, 0x70, 0x3f, 0x20, 0x00, 0x38, 0x68, 0x37, 0x09, 0x59, 0x1e, 0x70, 0x1f, 0x72, 0x44, 0x3a, 0xf0, 0x00, 0xfe, 0x5a, 0x7f, 0x38, 0x48, 0x5a, 0x04, 0x38, 0xff, 0x00, 0x40, 0x28, 0x5e, 0x59, 0x78, 0x37, 0x79, 0x37, 0x7b, 0x37, 0x94, 0x37, 0x9f, 0x37, 0xa0, 0x37, 0xa1, 0x37, 0xa2, 0x37, 0xa3, 0x37, 0xa4, 0x37, 0xa5, 0x37, 0xa6, 0x37, 0xa7, 0x37, 0xa8, 0x37, 0xa9, 0x37, 0xaa, 0x37, 0x3a, 0x38, 0x07, 0x78, 0x3a, 0x38, 0x1e, 0x70, 0xfe, 0x58, 0x15, 0x38, 0x1f, 0x00, 0x06, 0x39, 0xdf, 0xd0, 
+0x80, 0x37, 0x01, 0x00, 0x02, 0x88, 0xd1, 0xa8, 0x0f, 0x9e, 0x1e, 0x70, 0xfe, 0x58, 0x15, 0x38, 0x1f, 0x00, 0x06, 0x39, 0x01, 0x77, 0x08, 0x88, 0x9e, 0x58, 0x1b, 0x05, 0x18, 0x30, 0x04, 0x88, 0x01, 0x60, 0xbe, 0x58, 0x4a, 0x01, 0xd1, 0xa8, 0x3a, 0x38, 0xd9, 0xa8, 0x1e, 0x70, 0xfe, 0x58, 0x15, 0x38, 0x1f, 0x00, 0x06, 0x39, 0x01, 0x00, 0xf7, 0x8b, 0xbe, 0x58, 0x54, 0x05, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x3a, 0x38, 0x11, 0xc4, 0xa2, 0xa8, 0x06, 0x60, 0x27, 0x78, 0x95, 0x60, 0x28, 0x78, 0x1e, 0x70, 0x2a, 0x78, 0x1d, 0x70, 0x29, 0x78, 0xfe, 0x58, 0x15, 0x38, 0x1e, 0x00, 0x03, 0x59, 0x24, 0x38, 0x00, 0xff, 0xfe, 0x58, 0x2b, 0x78, 0x24, 0x38, 0xff, 0x00, 0xdf, 0xea, 
+0xc0, 0x37, 0x2c, 0x78, 0xf1, 0x60, 0x2d, 0x78, 0x3a, 0x38, 0x11, 0xc4, 0xa2, 0xa8, 0x06, 0x60, 0x27, 0x78, 0x97, 0x60, 0x28, 0x78, 0x1e, 0x70, 0x2a, 0x78, 0x1d, 0x70, 0x29, 0x78, 0xfe, 0x58, 0x15, 0x38, 0x1e, 0x00, 0x00, 0x61, 0x00, 0x62, 0x3c, 0x6a, 0x1a, 0x48, 0x01, 0x80, 0x09, 0x59, 0x24, 0x38, 0x00, 0xff, 0xfe, 0x58, 0x2b, 0x78, 0x24, 0x38, 0xff, 0x00, 0x2c, 0x78, 0xf1, 0x60, 0x2d, 0x78, 0x3a, 0x38, 0x11, 0xc4, 0x1d, 0x70, 0xfe, 0x58, 0x15, 0x38, 0x1e, 0x00, 0x1f, 0x71, 0xfe, 0x59, 0x35, 0x39, 0x20, 0x00, 0x06, 0x3a, 0xf0, 0xff, 0x0b, 0x8a, 0x06, 0x3a, 0xf1, 0xff, 0x06, 0x8a, 0x06, 0x3a, 0xf2, 0xff, 0x07, 0x8a, 0x00, 0x9e, 0x3b, 0x58, 0x06, 0x9e, 0xc1, 0xa8, 0x04, 0x9e, 0xc1, 0xaa, 0x02, 0x9e, 0xf1, 0xa8, 0x00, 0x9e, 0x3a, 0x38, 0x98, 0x3f, 0x76, 0x32, 0xba, 0xac, 0x80, 0x31, 
+0x00, 0x38, 0x98, 0x3c, 0x76, 0x32, 0x81, 0xaa, 0xb9, 0xaa, 0x1d, 0x70, 0x3d, 0x78, 0x1e, 0x70, 0x3e, 0x78, 0x1f, 0x70, 0x3f, 0x78, 0x20, 0x70, 0x40, 0x78, 0x21, 0x70, 0x41, 0x78, 0x22, 0x70, 0x42, 0x78, 0x23, 0x70, 0x43, 0x78, 0x24, 0x70, 0x44, 0x78, 0x25, 0x70, 0x45, 0x78, 0x26, 0x70, 0x46, 0x78, 0x00, 0x63, 0x3e, 0x70, 0x78, 0x48, 0x62, 0x88, 0x00, 0x63, 0x3d, 0x70, 0x38, 0xac, 0x03, 0x92, 0x3f, 0x7b, 0x40, 0x7b, 0x41, 0x7b, 0x30, 0xac, 0x03, 0x92, 0x42, 0x7b, 0x43, 0x7b, 0x44, 0x7b, 0x28, 0xac, 0x01, 0x92, 0x45, 0x7b, 0x20, 0xac, 0x01, 0x92, 0x46, 0x7b, 0x00, 0x63, 0x2a, 0x7b, 0x04, 0x39, 0x0f, 0x00, 0xe0, 0xaa, 0x19, 0xac, 0x01, 0x90, 0xe0, 0xa8, 0x20, 0x3a, 0x3a, 0x38, 0x49, 0x5b, 0x5e, 0x5b, 0x44, 0x38, 0x44, 0x38, 0x44, 0x38, 0x58, 0x38, 0x58, 0x38, 0x80, 0x01, 0x5b, 0x45, 
+0x40, 0x38, 0x80, 0x01, 0xee, 0x01, 0xb7, 0x01, 0x25, 0x02, 0x0f, 0x63, 0x74, 0x3c, 0x3d, 0x00, 0x7f, 0x38, 0x8a, 0x5c, 0x47, 0x7c, 0x9b, 0xa8, 0x80, 0x63, 0x01, 0x6b, 0x9e, 0x5f, 0xab, 0x04, 0x07, 0xac, 0x02, 0x90, 0xca, 0x63, 0x02, 0x6b, 0x08, 0xac, 0x25, 0x90, 0xee, 0x63, 0x01, 0x6b, 0x22, 0x9e, 0x0f, 0x63, 0x74, 0x3c, 0x3d, 0x00, 0x7f, 0x38, 0x8a, 0x5c, 0x47, 0x7c, 0x9b, 0xa8, 0xb7, 0x63, 0x01, 0x6b, 0x10, 0xac, 0x17, 0x90, 0x9e, 0x5b, 0x33, 0x01, 0x03, 0xac, 0x0e, 0x92, 0x0b, 0xac, 0x0f, 0x92, 0x9e, 0x5b, 0x49, 0x01, 0x60, 0x3b, 0x6f, 0x38, 0x69, 0x5b, 0x0b, 0x9e, 0x93, 0x02, 0x25, 0x02, 0x6f, 0x03, 0x38, 0x03, 0xca, 0x02, 0x01, 0x03, 0xc0, 0x63, 0x08, 0x6b, 0x02, 0x9e, 0x30, 0x63, 0x0b, 0x6b, 0xbe, 0x5b, 0x02, 0x01, 0xb9, 0xa8, 0x3a, 0x38, 0x3d, 0x70, 0x04, 0x39, 0xe5, 0xba, 
+0x80, 0x38, 0x07, 0x00, 0x20, 0x3a, 0x85, 0x38, 0x49, 0x5b, 0x5e, 0x5b, 0x8a, 0x38, 0x8a, 0x38, 0x8a, 0x38, 0x94, 0x38, 0x94, 0x38, 0x0f, 0x63, 0x74, 0x3c, 0x3d, 0x00, 0x7f, 0x38, 0x8a, 0x5c, 0x47, 0x7c, 0x9b, 0xa8, 0x08, 0xac, 0x0a, 0x90, 0x09, 0x9e, 0x0f, 0x63, 0x74, 0x3c, 0x3d, 0x00, 0x7f, 0x38, 0x8a, 0x5c, 0x47, 0x7c, 0x9b, 0xa8, 0x10, 0xac, 0x00, 0x90, 0x48, 0x7b, 0xb9, 0xa8, 0x3a, 0x38, 0x00, 0x63, 0x3e, 0x70, 0x78, 0x48, 0xbd, 0x88, 0x3f, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x42, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x48, 0x72, 0x1a, 0x7a, 0x90, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0xa7, 0x90, 0xa2, 0xac, 0xfc, 0x93, 0x40, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x2e, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x3f, 0x71, 0x14, 0xd9, 
+0xc0, 0x38, 0x1a, 0x11, 0x28, 0x59, 0x30, 0x3b, 0x1a, 0x00, 0x1a, 0x7b, 0x90, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x19, 0x02, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x8e, 0x90, 0xa2, 0xac, 0xfc, 0x93, 0x41, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x15, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x40, 0x71, 0x1a, 0x11, 0x28, 0x59, 0x30, 0x3b, 0x1a, 0x00, 0x1a, 0x7b, 0x90, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x1a, 0x02, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x75, 0x90, 0xa2, 0xac, 0xfc, 0x93, 0x42, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x44, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x48, 0x72, 0x40, 0x3b, 0x1b, 0x00, 0x1a, 0x7b, 0x91, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x5f, 0x90, 0xa2, 0xac, 0xfc, 0x93, 0xfa, 0x09, 
+0x00, 0x39, 0x43, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x2e, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x42, 0x71, 0x1a, 0x11, 0x28, 0x59, 0x30, 0x3b, 0x1a, 0x00, 0x1a, 0x7b, 0x91, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x19, 0x02, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x46, 0x90, 0xa2, 0xac, 0xfc, 0x93, 0x44, 0x71, 0x26, 0x3a, 0x00, 0x00, 0xcd, 0x8b, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x43, 0x71, 0x1a, 0x11, 0x28, 0x59, 0x30, 0x3b, 0x1a, 0x00, 0x1a, 0x7b, 0x91, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x1a, 0x02, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x2d, 0x90, 0xa2, 0xac, 0xfc, 0x93, 0x45, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x12, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x48, 0x72, 0x50, 0x3a, 0x0a, 0x04, 0x1a, 0x7a, 0x92, 0x62, 0x28, 0x7a, 0x47, 0x72, 0xc9, 0x59, 
+0x40, 0x39, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x17, 0x90, 0xa2, 0xac, 0xfc, 0x93, 0x46, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x10, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x2a, 0x62, 0x1a, 0x7a, 0x94, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x29, 0x7a, 0x81, 0xaa, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x03, 0x90, 0xa2, 0xac, 0xfc, 0x93, 0x3a, 0x38, 0x81, 0xaa, 0xa2, 0xaa, 0x95, 0xc6, 0x3a, 0x38, 0x00, 0x62, 0x2a, 0x7a, 0x48, 0x72, 0x48, 0x76, 0x1a, 0x7a, 0xa0, 0xac, 0x4e, 0x92, 0x3f, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x40, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x93, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0xe5, 0x91, 0xa2, 0xac, 0xfc, 0x93, 0x40, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x2e, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x84, 0x35, 
+0x80, 0x39, 0x27, 0x7a, 0x3f, 0x71, 0x1b, 0x11, 0x28, 0x59, 0x30, 0x3b, 0x1a, 0x00, 0x1a, 0x7b, 0x93, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x19, 0x02, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0xcc, 0x91, 0xa2, 0xac, 0xfc, 0x93, 0x41, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x15, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x40, 0x71, 0x1b, 0x11, 0x28, 0x59, 0x30, 0x3b, 0x1a, 0x00, 0x1a, 0x7b, 0x93, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x1a, 0x02, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0xb3, 0x91, 0xa2, 0xac, 0xfc, 0x93, 0x2a, 0x72, 0x19, 0x02, 0x2a, 0x7a, 0x56, 0x3a, 0x3e, 0x00, 0xaa, 0x8b, 0x1a, 0x70, 0x19, 0x00, 0x1a, 0x78, 0xb2, 0x9f, 0x3f, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x40, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x93, 0x62, 0x28, 0x7a, 0x47, 0x72, 0xf7, 0xfc, 
+0xc0, 0x39, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x97, 0x91, 0xa2, 0xac, 0xfc, 0x93, 0x40, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x2e, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x3f, 0x71, 0x1b, 0x11, 0x28, 0x59, 0x30, 0x3b, 0x1a, 0x00, 0x1a, 0x7b, 0x93, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x19, 0x02, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x7e, 0x91, 0xa2, 0xac, 0xfc, 0x93, 0x41, 0x71, 0x26, 0x3a, 0x00, 0x00, 0x15, 0x8a, 0x24, 0x3a, 0xff, 0x00, 0x27, 0x7a, 0x40, 0x71, 0x1b, 0x11, 0x28, 0x59, 0x30, 0x3b, 0x1a, 0x00, 0x1a, 0x7b, 0x93, 0x62, 0x28, 0x7a, 0x47, 0x72, 0x1a, 0x02, 0x29, 0x7a, 0x81, 0xa8, 0xa2, 0xa8, 0x93, 0xc6, 0xb9, 0xac, 0x65, 0x91, 0xa2, 0xac, 0xfc, 0x93, 0x2a, 0x72, 0x19, 0x02, 0x2a, 0x7a, 0x56, 0x3a, 0x3e, 0x00, 0x5c, 0x8b, 0xe1, 0xbb, 
+0x00, 0x3a, 0xb5, 0x9f, 0xb2, 0xa8, 0xa2, 0xa8, 0xaa, 0xaa, 0x00, 0x60, 0x1b, 0x78, 0x82, 0xac, 0x05, 0x92, 0x52, 0xb2, 0x3a, 0xaa, 0xd2, 0xb2, 0xf9, 0xab, 0x03, 0x9e, 0xe9, 0xab, 0x28, 0x70, 0xf9, 0xb0, 0x93, 0xc6, 0x82, 0xac, 0x02, 0x92, 0xf1, 0xad, 0xfe, 0x91, 0x3e, 0x5f, 0x3e, 0x5e, 0x3e, 0x5d, 0x3e, 0x5c, 0x3e, 0x5b, 0x3e, 0x5a, 0x3e, 0x59, 0x3e, 0x58, 0x80, 0xb8, 0x81, 0xb8, 0x5a, 0x38, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xea, 0xde, 
+0x40, 0x3a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x3a, 
+0x80, 0x3a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x40, 0x3a, 
+0xc0, 0x3a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3a, 
+0x00, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x3a, 
+0x40, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x3b, 
+0x80, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x40, 0x3b, 
+0xc0, 0x3b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3b, 
+0x00, 0x3c, 0x00, 0x00, 0x22, 0x36, 0x00, 0x01, 0x22, 0x36, 0x01, 0x02, 0x21, 0x36, 0x01, 0x03, 0x21, 0x36, 0x02, 0x04, 0x20, 0x36, 0x02, 0x85, 0x20, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x98, 0x8f, 
+0x40, 0x3c, 0x00, 0x00, 0x22, 0x36, 0x00, 0x01, 0x22, 0x36, 0x01, 0x02, 0x21, 0x36, 0x01, 0x03, 0x21, 0x36, 0x02, 0x04, 0x20, 0x36, 0x02, 0x85, 0x20, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd8, 0x8f, 
+0x80, 0x3c, 0x00, 0x00, 0x22, 0x36, 0x00, 0x01, 0x22, 0x36, 0x01, 0x02, 0x21, 0x36, 0x01, 0x03, 0x21, 0x36, 0x02, 0x04, 0x20, 0x36, 0x02, 0x85, 0x20, 0xb6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x18, 0x90, 
+0xc0, 0x3c, 0x15, 0xea, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x96, 0x26, 
+0x00, 0x3d, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1e, 0x00, 0x1e, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7e, 0x43, 
+0x40, 0x3d, 0x23, 0x00, 0x00, 0x1b, 0x22, 0x01, 0x01, 0x1c, 0x21, 0x02, 0x02, 0x1d, 0x20, 0x03, 0x03, 0x1e, 0x1f, 0x04, 0x04, 0x1f, 0x1e, 0x05, 0x05, 0x20, 0x1d, 0x06, 0x06, 0x21, 0x1c, 0x07, 0x07, 0x22, 0x1b, 0x08, 0x08, 0x23, 0x1a, 0x09, 0x09, 0x24, 0x19, 0x0a, 0x0a, 0x25, 0x18, 0x0b, 0x0b, 0x26, 0x17, 0x0c, 0x0c, 0x27, 0x16, 0x0d, 0x0d, 0x28, 0x15, 0x0e, 0x0e, 0x29, 0x14, 0x8f, 0x0f, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x50, 0xdf, 
+0x80, 0x3d, 0x0f, 0x00, 0x22, 0x1b, 0x10, 0x01, 0x21, 0x1c, 0x11, 0x02, 0x20, 0x1d, 0x12, 0x03, 0x1f, 0x1e, 0x13, 0x04, 0x1e, 0x1f, 0x14, 0x05, 0x15, 0x20, 0x4d, 0x07, 0x63, 0x08, 0x0e, 0x86, 0x24, 0xf6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x50, 0x8a, 
+0xc0, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x3d, 
+0x00, 0x3e, 0x0c, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x80, 0x02, 0xd5, 0x01, 0x07, 0x00, 0x03, 0x11, 0xf0, 0x14, 0x06, 0x00, 0x06, 0x00, 0x05, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x75, 0x00, 0x5f, 0x01, 0xea, 0x00, 0x40, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00, 0x8c, 0x00, 0x19, 0x00, 0x0f, 0x00, 0x28, 0x00, 0x00, 0x08, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x0a, 0x00, 0x09, 0x39, 0x00, 0x47, 0x02, 0x39, 0x00, 0x9c, 0x01, 0x3c, 0xa4, 
+0x40, 0x3e, 0xeb, 0x00, 0x91, 0x00, 0x91, 0x00, 0x40, 0x01, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, 0xff, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x01, 0x00, 0x64, 0x00, 0x64, 0x00, 0xc8, 0x00, 0x19, 0x00, 0x40, 0x00, 0x04, 0x00, 0x07, 0x00, 0x20, 0x03, 0xbc, 0x02, 0x00, 0x00, 0xc8, 0x00, 0xc8, 0x00, 0xc8, 0x00, 0xc8, 0x00, 0xc8, 0x00, 0x90, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x2c, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x04, 0x00, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0xb8, 0x0b, 0x32, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x30, 0x75, 0x64, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x64, 0x00, 0x1e, 0x00, 0x64, 0x00, 0x0a, 0x00, 0x0f, 0x27, 0x2c, 0x01, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x2c, 0x01, 0xfd, 0x00, 
+0x80, 0x3e, 0x01, 0x00, 0xfa, 0x00, 0x84, 0x03, 0x07, 0x00, 0x32, 0x00, 0x96, 0x00, 0x00, 0x00, 0x08, 0x00, 0x26, 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x14, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0xe8, 0x03, 0x63, 0x00, 0x63, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x19, 0x00, 0x2c, 0x01, 0x05, 0x00, 0xc8, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x14, 0x00, 0x20, 0x00, 0x28, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x50, 0x00, 0xac, 0x0d, 0x5e, 0x01, 0x20, 0x03, 0x90, 0x01, 0x00, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x00, 0x00, 0x03, 0x00, 0x28, 0x00, 0x0a, 0x00, 0x01, 0x00, 0x64, 0x00, 0x01, 0x00, 0x20, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0xe3, 
+0xc0, 0x3e, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9a, 0x02, 0x2c, 0x01, 0x3e, 0x00, 0x02, 0x00, 0x28, 0x00, 0x96, 0x00, 0x03, 0x00, 0x20, 0x03, 0x04, 0x00, 0x14, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0xfa, 0x00, 0xe6, 0x00, 0x40, 0x01, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x06, 0x00, 0x64, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x4b, 
+0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x2c, 0x01, 0x2c, 0x01, 0x20, 0x03, 0x20, 0x03, 0xc8, 0x00, 0xc8, 0x00, 0x90, 0x01, 0x90, 0x01, 0x00, 0x00, 0x20, 0x03, 0x00, 0x00, 0x60, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x46, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x50, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0xc4, 0x09, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x46, 0x00, 0x01, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x46, 0x00, 0x2c, 0x01, 0x00, 0x00, 0x46, 0x00, 0x30, 0x75, 0x64, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x20, 0x03, 0xb0, 0x04, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe7, 0x03, 0xf4, 0x01, 0xb2, 0xe2, 
+0x40, 0x3f, 0x0a, 0x00, 0xe8, 0x03, 0x88, 0x13, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x46, 0x00, 0x00, 0x00, 0xf4, 0x01, 0x32, 0x00, 0x14, 0x00, 0x0a, 0x00, 0x14, 0x00, 0x32, 0x00, 0x08, 0x00, 0xd0, 0x07, 0x00, 0x00, 0xb0, 0x04, 0x00, 0x00, 0x00, 0x00, 0xe8, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd2, 0x69, 
+0x80, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x40, 0x3f, 
+0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaa, 0x55, 0xcc, 0x33, 0xff, 0xff, 0xf8, 0xc8, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_common.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_common.c
new file mode 100644
index 0000000..94822b5
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_common.c
@@ -0,0 +1,152 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_common.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_common.h"
+
+/*=============================================================*/
+// MACRO DEFINITION
+/*=============================================================*/
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// VARIABLE DEFINITION
+/*=============================================================*/
+
+static u32 _gCrc32Table[256]; 
+
+/*=============================================================*/
+// DATA TYPE DEFINITION
+/*=============================================================*/
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+/// CRC
+u32 DrvCommonCrcDoReflect(u32 nRef, s8 nCh)
+{
+    u32 nValue = 0;
+    u32 i = 0;
+
+    for (i = 1; i < (nCh + 1); i ++)
+    {
+        if (nRef & 1)
+        {
+            nValue |= 1 << (nCh - i);
+        }
+        nRef >>= 1;
+    }
+
+    return nValue;
+}
+
+u32 DrvCommonCrcGetValue(u32 nText, u32 nPrevCRC)
+{
+    u32 nCRC = nPrevCRC;
+
+    nCRC = (nCRC >> 8) ^ _gCrc32Table[(nCRC & 0xFF) ^ nText];
+
+    return nCRC;
+}
+
+void DrvCommonCrcInitTable(void)
+{
+    u32 nMagicNumber = 0x04c11db7;
+    u32 i, j;
+
+    for (i = 0; i <= 0xFF; i ++)
+    {
+        _gCrc32Table[i] = DrvCommonCrcDoReflect(i, 8) << 24;
+        for (j = 0; j < 8; j ++)
+        {
+            _gCrc32Table[i] = (_gCrc32Table[i] << 1) ^ (_gCrc32Table[i] & (0x80000000L) ? nMagicNumber : 0);
+        }
+        _gCrc32Table[i] = DrvCommonCrcDoReflect(_gCrc32Table[i], 32);
+    }
+}
+
+u8 DrvCommonCalculateCheckSum(u8 *pMsg, u32 nLength)
+{
+    s32 nCheckSum = 0;
+    u32 i;
+
+    for (i = 0; i < nLength; i ++)
+    {
+        nCheckSum += pMsg[i];
+    }
+
+    return (u8)((-nCheckSum) & 0xFF);
+}
+
+u32 DrvCommonConvertCharToHexDigit(char *pCh, u32 nLength)
+{
+    u32 nRetVal = 0;
+    u32 i;
+    
+    DBG("nLength = %d\n", nLength);
+
+    for (i = 0; i < nLength; i ++)
+    {
+        char ch = *pCh++;
+        u32 n = 0;
+        
+        if ((i == 0 && ch == '0') || (i == 1 && ch == 'x'))
+        {
+            continue;		
+        }
+        
+        if ('0' <= ch && ch <= '9')
+        {
+            n = ch-'0';
+        }
+        else if ('a' <= ch && ch <= 'f')
+        {
+            n = 10 + ch-'a';
+        }
+        else if ('A' <= ch && ch <= 'F')
+        {
+            n = 10 + ch-'A';
+        }
+        
+        if (i < 6)
+        {
+            nRetVal = n + nRetVal*16;
+        }
+    }
+    
+    return nRetVal;
+}
+
+//------------------------------------------------------------------------------//
\ No newline at end of file
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_common.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_common.h
new file mode 100644
index 0000000..88374b6
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_common.h
@@ -0,0 +1,320 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_common.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_COMMON_H__
+#define __MSTAR_DRV_COMMON_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/earlysuspend.h>
+#include <linux/i2c.h>
+#include <linux/proc_fs.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+/*--------------------------------------------------------------------------*/
+/* TOUCH DEVICE DRIVER RELEASE VERSION                                      */
+/*--------------------------------------------------------------------------*/
+
+#define DEVICE_DRIVER_RELEASE_VERSION   ("2.2.0.0")
+
+
+/*--------------------------------------------------------------------------*/
+/* COMPILE OPTION DEFINITION                                                */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling for distinct smart phone developer platform.
+ * For running on Spreadtrum platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM.
+ * For running on Qualcomm platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM.
+ * For running on MediaTek platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM.
+ */
+//#define CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM
+//#define CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+#define CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling for distinct touch ic.
+ * Please enable the compile option depends on the touch ic that customer project are using and disable the others.
+ */
+#define CONFIG_ENABLE_CHIP_MSG21XXA
+//#define CONFIG_ENABLE_CHIP_MSG22XX
+//#define CONFIG_ENABLE_CHIP_MSG26XXM
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling to make sure main board can supply power to touch ic for some specific BB chip of MTK(EX. MT6582)/SPRD(EX. SC7715)/QCOM(EX. MSM8610).
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_REGULATOR_POWER_ON
+
+/*
+ * Note.
+ * The below compile option is used to distinguish different workqueue scheduling mechanism when firmware report finger touch to device driver by IRQ interrupt.
+ * For MTK platform, there are two type of workqueue scheduling mechanism available.
+ * Please refer to the related code which is enclosed by compile option CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM in mstar_drv_platform_porting_layer.c for more detail.
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+
+//#define CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+
+/*
+ * Note.
+ * The below compile option is used to apply DMA mode for read/write data between device driver and firmware by I2C.
+ * The DMA mode is used to reslove I2C read/write 8 bytes limitation for specific MTK BB chip(EX. MT6589/MT6572/...)
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_DMA_IIC
+
+/*
+ * Note.
+ * The below compile option is used to enable the output log mechanism while touch device driver is running.
+ * If this compile option is not defined, the function for output log will be disabled.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_TOUCH_DRIVER_DEBUG
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling when touch panel support virtual key(EX. Menu, Home, Back, Search).
+ * If this compile option is not defined, the function for virtual key handling will be disabled.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_TP_HAVE_KEY
+
+/*
+ * Note.
+ * Since specific MTK BB chip report virtual key touch by using coordinate instead of key code, the below compile option is used to enable the code handling for reporting key with coordinate.
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+
+/*
+ * Note.
+ * The below compile option is used to enable debug mode data log for firmware.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+/*
+ * Note.
+ * The below compile option is used to enable gesture wakeup.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*
+ * Note.
+ * The below compile option is used to enable phone level MP test handling.
+ * By the way, phone level MP test is ready for MSG21XXA(support Open Test&Short Test)/MSG26XXM(support Open Test) only, but phone level MP test for MSG22XX is not ready yet.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_ITO_MP_TEST
+
+
+/*
+ * Note.
+ * The below compile option is used to change the permission of the sysfs virtual file system for CTS test.
+ * If this compile option is enabled, the permission 0644 will be used. 
+ * If this compile option is disabled, the permission 0777 will be used. 
+ * By default, this compile option is disabled.
+ */
+//#define SYSFS_AUTHORITY_CHANGE_FOR_CTS_TEST
+
+/*
+ * Note.
+ * If this compile option is not defined, the SW ID mechanism for updating firmware will be disabled.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*
+ * Note.
+ * If this compile option is defined, the update firmware bin file shall be stored in a two dimensional array format.
+ * Else, the update firmware bin file shall be stored in an one dimensional array format.
+ * Be careful, MSG22XX only support storing update firmware bin file in an one dimensional array format, it does not support two dimensional array format.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY 
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define u8   unsigned char
+#define u16  unsigned short
+#define u32  unsigned int
+#define s8   signed char
+#define s16  signed short
+#define s32  signed int
+
+//#define SLAVE_I2C_ID_DBBUS         (0xB2>>1) //0x59 // for MSG22XX
+#define SLAVE_I2C_ID_DBBUS         (0xC4>>1) //0x62 // for MSG21XX/MSG21XXA/MSG26XXM
+#define SLAVE_I2C_ID_DWI2C         (0x4C>>1) //0x26 
+
+#define CHIP_TYPE_MSG21XX   (0x01) // EX. MSG2133
+#define CHIP_TYPE_MSG21XXA  (0x02) // EX. MSG2133A/MSG2138A(Besides, use version to distinguish MSG2133A/MSG2138A, you may refer to _DrvFwCtrlUpdateFirmwareCash()) 
+#define CHIP_TYPE_MSG26XXM  (0x03) // EX. MSG2633M
+#define CHIP_TYPE_MSG22XX   (0x7A) // EX. MSG2238/MSG2256
+
+#define PACKET_TYPE_TOOTH_PATTERN   (0x20)
+#define PACKET_TYPE_GESTURE_WAKEUP  (0x50)
+
+#define TOUCH_SCREEN_X_MIN   (0)
+#define TOUCH_SCREEN_Y_MIN   (0)
+/*
+ * Note.
+ * Please change the below touch screen resolution according to the touch panel that you are using.
+ */
+#define TOUCH_SCREEN_X_MAX   (240) //LCD_WIDTH
+#define TOUCH_SCREEN_Y_MAX   (320) //LCD_HEIGHT
+/*
+ * Note.
+ * Please do not change the below setting.
+ */
+#define TPD_WIDTH   (2048)
+#define TPD_HEIGHT  (2048)
+
+
+#define BIT0  (1<<0)  // 0x0001
+#define BIT1  (1<<1)  // 0x0002
+#define BIT2  (1<<2)  // 0x0004
+#define BIT3  (1<<3)  // 0x0008
+#define BIT4  (1<<4)  // 0x0010
+#define BIT5  (1<<5)  // 0x0020
+#define BIT6  (1<<6)  // 0x0040
+#define BIT7  (1<<7)  // 0x0080
+#define BIT8  (1<<8)  // 0x0100
+#define BIT9  (1<<9)  // 0x0200
+#define BIT10 (1<<10) // 0x0400
+#define BIT11 (1<<11) // 0x0800
+#define BIT12 (1<<12) // 0x1000
+#define BIT13 (1<<13) // 0x2000
+#define BIT14 (1<<14) // 0x4000
+#define BIT15 (1<<15) // 0x8000
+
+
+#define MAX_DEBUG_REGISTER_NUM     (10)
+
+
+#ifdef SYSFS_AUTHORITY_CHANGE_FOR_CTS_TEST
+#define SYSFS_AUTHORITY (0644)
+#else
+#define SYSFS_AUTHORITY (0777)
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#define GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG     0x0001    //0000 0000 0000 0001
+#define GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG        0x0002    //0000 0000 0000 0010
+#define GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG      0x0004    //0000 0000 0000 0100
+#define GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG      0x0008    //0000 0000 0000 1000
+#define GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG     0x0010    //0000 0000 0001 0000
+#define GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG      0x0020    //0000 0000 0010 0000
+#define GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG      0x0040    //0000 0000 0100 0000
+#define GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG      0x0080    //0000 0000 1000 0000
+#define GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG      0x0100    //0000 0001 0000 0000
+#define GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG      0x0200    //0000 0010 0000 0000
+#define GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG      0x0400    //0000 0100 0000 0000
+#define GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG      0x0800    //0000 1000 0000 0000
+#define GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG      0x1000    //0001 0000 0000 0000
+
+#define GESTURE_WAKEUP_PACKET_LENGTH    (6)
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR MACRO DEFINITION                                            */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_TOUCH_DRIVER_DEBUG
+//#define DBG(fmt, arg...) pr_info(fmt, ##arg)
+#define DBG(fmt, arg...) printk(fmt, ##arg)
+#else
+#define DBG(fmt, arg...)
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+typedef enum
+{
+    EMEM_ALL = 0,
+    EMEM_MAIN,
+    EMEM_INFO
+} EmemType_e;
+
+typedef enum
+{
+    ITO_TEST_MODE_OPEN_TEST = 1,
+    ITO_TEST_MODE_SHORT_TEST = 2
+} ItoTestMode_e;
+
+typedef enum
+{
+    ITO_TEST_OK = 0,
+    ITO_TEST_FAIL,
+    ITO_TEST_GET_TP_TYPE_ERROR,
+    ITO_TEST_UNDEFINED_ERROR,
+    ITO_TEST_UNDER_TESTING
+
+} ItoTestResult_e;
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL VARIABLE DEFINITION                                               */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern u8 DrvCommonCalculateCheckSum(u8 *pMsg, u32 nLength);
+extern u32 DrvCommonConvertCharToHexDigit(char *pCh, u32 nLength);
+extern u32 DrvCommonCrcDoReflect(u32 nRef, s8 nCh);
+extern u32 DrvCommonCrcGetValue(u32 nText, u32 nPrevCRC);
+extern void DrvCommonCrcInitTable(void);
+
+#endif  /* __MSTAR_DRV_COMMON_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_ic_fw_porting_layer.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_ic_fw_porting_layer.c
new file mode 100644
index 0000000..ca562b5
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_ic_fw_porting_layer.c
@@ -0,0 +1,195 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_ic_fw_porting_layer.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u16 g_GestureWakeupMode;
+extern u8 g_GestureWakeupFlag;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+u8 DrvIcFwLyrGetChipType(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvFwCtrlGetChipType();
+}
+
+void DrvIcFwLyrGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetCustomerFirmwareVersion(pMajor, pMinor, ppVersion);
+}
+
+void DrvIcFwLyrGetPlatformFirmwareVersion(u8 **ppVersion)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetPlatformFirmwareVersion(ppVersion);
+}
+
+s32 DrvIcFwLyrUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvFwCtrlUpdateFirmware(szFwData, eEmemType);
+}	
+
+u32 DrvIcFwLyrIsRegisterFingerTouchInterruptHandler(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return 1; // Indicate that it is necessary to register interrupt handler with GPIO INT pin when firmware is running on IC
+}
+
+void DrvIcFwLyrHandleFingerTouch(u8 *pPacket, u16 nLength)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlHandleFingerTouch();
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+void DrvIcFwLyrOpenGestureWakeup(u16 nWakeupMode)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlOpenGestureWakeup(nWakeupMode);
+}	
+
+void DrvIcFwLyrCloseGestureWakeup(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlCloseGestureWakeup();
+}	
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+u16 DrvIcFwLyrGetFirmwareMode(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvFwCtrlGetFirmwareMode();
+}
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+
+u16 DrvIcFwLyrChangeFirmwareMode(u16 nMode)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvFwCtrlChangeFirmwareMode(nMode); 
+}
+
+void DrvIcFwLyrGetFirmwareInfo(FirmwareInfo_t *pInfo)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetFirmwareInfo(pInfo);
+}
+
+void DrvIcFwLyrRestoreFirmwareModeToLogDataMode(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlRestoreFirmwareModeToLogDataMode();
+}	
+
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+void DrvIcFwLyrCheckFirmwareUpdateBySwId(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlCheckFirmwareUpdateBySwId();
+}
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+void DrvIcFwLyrCreateMpTestWorkQueue(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+	
+    DrvMpTestCreateMpTestWorkQueue();
+}
+
+void DrvIcFwLyrScheduleMpTestWork(ItoTestMode_e eItoTestMode)
+{
+//    DBG("*** %s() ***\n", __func__);
+	
+    DrvMpTestScheduleMpTestWork(eItoTestMode);
+}
+
+s32 DrvIcFwLyrGetMpTestResult(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+	
+    return DrvMpTestGetTestResult();
+}
+
+void DrvIcFwLyrGetMpTestFailChannel(ItoTestMode_e eItoTestMode, u8 *pFailChannel, u32 *pFailChannelCount)
+{
+//    DBG("*** %s() ***\n", __func__);
+	
+    return DrvMpTestGetTestFailChannel(eItoTestMode, pFailChannel, pFailChannelCount);
+}
+
+void DrvIcFwLyrGetMpTestDataLog(ItoTestMode_e eItoTestMode, u8 *pDataLog, u32 *pLength)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvMpTestGetTestDataLog(eItoTestMode, pDataLog, pLength);
+}
+#endif //CONFIG_ENABLE_ITO_MP_TEST		
\ No newline at end of file
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_ic_fw_porting_layer.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_ic_fw_porting_layer.h
new file mode 100644
index 0000000..2ca7fcb
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_ic_fw_porting_layer.h
@@ -0,0 +1,90 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_ic_fw_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_IC_FW_PORTING_LAYER_H__
+#define __MSTAR_DRV_IC_FW_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+#include "mstar_drv_mutual_fw_control.h"
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#include "mstar_drv_mutual_mp_test.h"
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+#include "mstar_drv_self_fw_control.h"
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#include "mstar_drv_self_mp_test.h"
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern void DrvIcFwLyrOpenGestureWakeup(u16 nWakeupMode);
+extern void DrvIcFwLyrCloseGestureWakeup(void);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern u16 DrvIcFwLyrChangeFirmwareMode(u16 nMode);
+extern void DrvIcFwLyrGetFirmwareInfo(FirmwareInfo_t *pInfo);
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+extern u16 DrvIcFwLyrGetFirmwareMode(void);
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+extern void DrvIcFwLyrRestoreFirmwareModeToLogDataMode(void);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+extern void DrvIcFwLyrCheckFirmwareUpdateBySwId(void);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+extern u8 DrvIcFwLyrGetChipType(void);
+extern void DrvIcFwLyrGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion);
+extern void DrvIcFwLyrGetPlatformFirmwareVersion(u8 **ppVersion);
+extern void DrvIcFwLyrHandleFingerTouch(u8 *pPacket, u16 nLength);
+extern u32 DrvIcFwLyrIsRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvIcFwLyrUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern void DrvIcFwLyrCreateMpTestWorkQueue(void);
+extern void DrvIcFwLyrScheduleMpTestWork(ItoTestMode_e eItoTestMode);
+extern void DrvIcFwLyrGetMpTestDataLog(ItoTestMode_e eItoTestMode, u8 *pDataLog, u32 *pLength);
+extern void DrvIcFwLyrGetMpTestFailChannel(ItoTestMode_e eItoTestMode, u8 *pFailChannel, u32 *pFailChannelCount);
+extern s32 DrvIcFwLyrGetMpTestResult(void);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+        
+#endif  /* __MSTAR_DRV_IC_FW_PORTING_LAYER_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_main.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_main.c
new file mode 100644
index 0000000..4a5faed
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_main.c
@@ -0,0 +1,987 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_main.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_main.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern FirmwareInfo_t g_FirmwareInfo;
+extern u8 *g_LogModePacket;
+extern u16 g_FirmwareMode;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u16 g_GestureWakeupMode;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+extern u8 g_ChipType;
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static u16 _gDebugReg[MAX_DEBUG_REGISTER_NUM] = {0};
+static u32 _gDebugRegCount = 0;
+
+static u8 *_gPlatformFwVersion = NULL; // internal use firmware version for MStar
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+static ItoTestMode_e _gItoTestMode = 0;
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+static u32 _gIsUpdateComplete = 0;
+
+static u8 *_gFwVersion = NULL; // customer firmware version
+
+static struct class *_gFirmwareClass = NULL;
+static struct device *_gFirmwareCmdDev = NULL;
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+struct kset *g_TouchKSet = NULL;
+struct kobject *g_TouchKObj = NULL;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+u8 g_FwData[94][1024];
+u32 g_FwDataCount = 0;
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+ssize_t DrvMainFirmwareChipTypeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return sprintf(pBuf, "%d", g_ChipType);
+}
+
+ssize_t DrvMainFirmwareChipTypeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+//    g_ChipType = DrvIcFwLyrGetChipType();
+
+    return nSize;
+}
+
+static DEVICE_ATTR(chip_type, SYSFS_AUTHORITY, DrvMainFirmwareChipTypeShow, DrvMainFirmwareChipTypeStore);
+
+ssize_t DrvMainFirmwareDriverVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return sprintf(pBuf, "%s", DEVICE_DRIVER_RELEASE_VERSION);
+}
+
+ssize_t DrvMainFirmwareDriverVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(driver_version, SYSFS_AUTHORITY, DrvMainFirmwareDriverVersionShow, DrvMainFirmwareDriverVersionStore);
+
+/*--------------------------------------------------------------------------*/
+
+ssize_t DrvMainFirmwareUpdateShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    return sprintf(pBuf, "%s\n", _gFwVersion);
+}
+
+ssize_t DrvMainFirmwareUpdateStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DBG("*** %s() g_FwDataCount = %d ***\n", __func__, g_FwDataCount);
+
+    if (0 != DrvIcFwLyrUpdateFirmware(g_FwData, EMEM_ALL))
+    {
+        _gIsUpdateComplete = 0;
+        DBG("Update FAILED\n");
+    }
+    else
+    {
+        _gIsUpdateComplete = 1;
+        DBG("Update SUCCESS\n");
+    }
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    DrvIcFwLyrRestoreFirmwareModeToLogDataMode();    
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    DrvPlatformLyrEnableFingerTouchReport();
+  
+    return nSize;
+}
+
+static DEVICE_ATTR(update, SYSFS_AUTHORITY, DrvMainFirmwareUpdateShow, DrvMainFirmwareUpdateStore);
+
+ssize_t DrvMainFirmwareVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    return sprintf(pBuf, "%s\n", _gFwVersion);
+}
+
+ssize_t DrvMainFirmwareVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u16 nMajor = 0, nMinor = 0;
+    
+    DrvIcFwLyrGetCustomerFirmwareVersion(&nMajor, &nMinor, &_gFwVersion);
+
+    DBG("*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(version, SYSFS_AUTHORITY, DrvMainFirmwareVersionShow, DrvMainFirmwareVersionStore);
+
+ssize_t DrvMainFirmwareDataShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() g_FwDataCount = %d ***\n", __func__, g_FwDataCount);
+    
+    return g_FwDataCount;
+}
+
+ssize_t DrvMainFirmwareDataStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u32 nCount = nSize / 1024;
+    u32 i;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (nCount > 0) // nSize >= 1024
+   	{
+        for (i = 0; i < nCount; i ++)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuf+(i*1024), 1024);
+
+            g_FwDataCount ++;
+        }
+    }
+    else // nSize < 1024
+    {
+    		if (nSize > 0)
+    		{
+            memcpy(g_FwData[g_FwDataCount], pBuf, nSize);
+
+            g_FwDataCount ++;
+    		}
+    }
+
+    DBG("*** g_FwDataCount = %d ***\n", g_FwDataCount);
+
+    if (pBuf != NULL)
+    {
+        DBG("*** buf[0] = %c ***\n", pBuf[0]);
+    }
+   
+    return nSize;
+}
+
+static DEVICE_ATTR(data, SYSFS_AUTHORITY, DrvMainFirmwareDataShow, DrvMainFirmwareDataStore);
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+ssize_t DrvMainFirmwareTestShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+    DBG("*** ctp mp test status = %d ***\n", DrvIcFwLyrGetMpTestResult());
+    
+    return sprintf(pBuf, "%d", DrvIcFwLyrGetMpTestResult());
+}
+
+ssize_t DrvMainFirmwareTestStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u32 nMode = 0;
+
+    DBG("*** %s() ***\n", __func__);
+    
+    if (pBuf != NULL)
+    {
+        sscanf(pBuf, "%x", &nMode);   
+
+        DBG("Mp Test Mode = 0x%x\n", nMode);
+
+        if (nMode == ITO_TEST_MODE_OPEN_TEST) //open test
+        {
+            _gItoTestMode = ITO_TEST_MODE_OPEN_TEST;
+            DrvIcFwLyrScheduleMpTestWork(ITO_TEST_MODE_OPEN_TEST);
+        }
+        else if (nMode == ITO_TEST_MODE_SHORT_TEST) //short test
+        {
+            _gItoTestMode = ITO_TEST_MODE_SHORT_TEST;
+            DrvIcFwLyrScheduleMpTestWork(ITO_TEST_MODE_SHORT_TEST);
+        }
+        else
+        {
+            DBG("*** Undefined MP Test Mode ***\n");
+        }
+    }
+
+    return nSize;
+}
+
+static DEVICE_ATTR(test, SYSFS_AUTHORITY, DrvMainFirmwareTestShow, DrvMainFirmwareTestStore);
+
+ssize_t DrvMainFirmwareTestLogShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    u32 nLength = 0;
+    
+    DBG("*** %s() ***\n", __func__);
+    
+    DrvIcFwLyrGetMpTestDataLog(_gItoTestMode, pBuf, &nLength);
+    
+    return nLength;
+}
+
+ssize_t DrvMainFirmwareTestLogStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(test_log, SYSFS_AUTHORITY, DrvMainFirmwareTestLogShow, DrvMainFirmwareTestLogStore);
+
+ssize_t DrvMainFirmwareTestFailChannelShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    u32 nCount = 0;
+
+    DBG("*** %s() ***\n", __func__);
+    
+    DrvIcFwLyrGetMpTestFailChannel(_gItoTestMode, pBuf, &nCount);
+    
+    return nCount;
+}
+
+ssize_t DrvMainFirmwareTestFailChannelStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(test_fail_channel, SYSFS_AUTHORITY, DrvMainFirmwareTestFailChannelShow, DrvMainFirmwareTestFailChannelStore);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+ssize_t DrvMainFirmwareGestureWakeupModeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+    DBG("g_GestureWakeupMode = 0x%x\n", g_GestureWakeupMode);
+
+    return sprintf(pBuf, "%x", g_GestureWakeupMode);
+}
+
+ssize_t DrvMainFirmwareGestureWakeupModeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u32 nLength, nWakeupMode;
+    
+    DBG("*** %s() ***\n", __func__);
+
+    if (pBuf != NULL)
+    {
+        sscanf(pBuf, "%x", &nWakeupMode);   
+        DBG("nWakeupMode = 0x%x\n", nWakeupMode);
+
+        nLength = nSize;
+        DBG("nLength = %d\n", nLength);
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG) == GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG);
+        }
+        
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG);
+        }
+       
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG);
+        }
+
+        DBG("g_GestureWakeupMode = 0x%x\n", g_GestureWakeupMode);
+    }
+        
+    return nSize;
+}
+
+static DEVICE_ATTR(gesture_wakeup_mode, SYSFS_AUTHORITY, DrvMainFirmwareGestureWakeupModeShow, DrvMainFirmwareGestureWakeupModeStore);
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*--------------------------------------------------------------------------*/
+
+ssize_t DrvMainFirmwareDebugShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    u32 i;
+    u8 nBank, nAddr;
+    u16 szRegData[MAX_DEBUG_REGISTER_NUM] = {0};
+    u8 szOut[MAX_DEBUG_REGISTER_NUM*25] = {0}, szValue[10] = {0};
+
+    DBG("*** %s() ***\n", __func__);
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+    
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+        szRegData[i] = RegGet16BitValue(_gDebugReg[i]);
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+    	  nBank = (_gDebugReg[i] >> 8) & 0xFF;
+    	  nAddr = _gDebugReg[i] & 0xFF;
+    	  
+        DBG("reg(0x%X,0x%X)=0x%04X\n", nBank, nAddr, szRegData[i]);
+
+        strcat(szOut, "reg(");
+        sprintf(szValue, "0x%X", nBank);
+        strcat(szOut, szValue);
+        strcat(szOut, ",");
+        sprintf(szValue, "0x%X", nAddr);
+        strcat(szOut, szValue);
+        strcat(szOut, ")=");
+        sprintf(szValue, "0x%04X", szRegData[i]);
+        strcat(szOut, szValue);
+        strcat(szOut, "\n");
+    }
+
+    return sprintf(pBuf, "%s\n", szOut);
+}
+
+ssize_t DrvMainFirmwareDebugStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u32 i;
+    char *pCh;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (pBuf != NULL)
+    {
+        DBG("*** %s() pBuf[0] = %c ***\n", __func__, pBuf[0]);
+        DBG("*** %s() pBuf[1] = %c ***\n", __func__, pBuf[1]);
+        DBG("*** %s() pBuf[2] = %c ***\n", __func__, pBuf[2]);
+        DBG("*** %s() pBuf[3] = %c ***\n", __func__, pBuf[3]);
+        DBG("*** %s() pBuf[4] = %c ***\n", __func__, pBuf[4]);
+        DBG("*** %s() pBuf[5] = %c ***\n", __func__, pBuf[5]);
+
+        DBG("nSize = %d\n", nSize);
+       
+        i = 0;
+        while ((pCh = strsep((char **)&pBuf, " ,")) && (i < MAX_DEBUG_REGISTER_NUM))
+        {
+            DBG("pCh = %s\n", pCh);
+            
+            _gDebugReg[i] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+
+            DBG("_gDebugReg[%d] = 0x%04X\n", i, _gDebugReg[i]);
+            i ++;
+        }
+        _gDebugRegCount = i;
+        
+        DBG("_gDebugRegCount = %d\n", _gDebugRegCount);
+    }
+
+    return nSize;
+}
+
+static DEVICE_ATTR(debug, SYSFS_AUTHORITY, DrvMainFirmwareDebugShow, DrvMainFirmwareDebugStore);
+
+/*--------------------------------------------------------------------------*/
+
+ssize_t DrvMainFirmwarePlatformVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() _gPlatformFwVersion = %s ***\n", __func__, _gPlatformFwVersion);
+
+    return sprintf(pBuf, "%s\n", _gPlatformFwVersion);
+}
+
+ssize_t DrvMainFirmwarePlatformVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DrvIcFwLyrGetPlatformFirmwareVersion(&_gPlatformFwVersion);
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    DrvIcFwLyrRestoreFirmwareModeToLogDataMode();    
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    DBG("*** %s() _gPlatformFwVersion = %s ***\n", __func__, _gPlatformFwVersion);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(platform_version, SYSFS_AUTHORITY, DrvMainFirmwarePlatformVersionShow, DrvMainFirmwarePlatformVersionStore);
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+ssize_t DrvMainFirmwareModeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    g_FirmwareMode = DrvIcFwLyrGetFirmwareMode();
+    
+    DBG("%s() firmware mode = 0x%x\n", __func__, g_FirmwareMode);
+
+    return sprintf(pBuf, "%x", g_FirmwareMode);
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+    g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+
+    DBG("%s() firmware mode = 0x%x, can change firmware mode = %d\n", __func__, g_FirmwareInfo.nFirmwareMode, g_FirmwareInfo.nIsCanChangeFirmwareMode);
+
+    return sprintf(pBuf, "%x,%d", g_FirmwareInfo.nFirmwareMode, g_FirmwareInfo.nIsCanChangeFirmwareMode);
+#endif
+}
+
+ssize_t DrvMainFirmwareModeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    u32 nMode;
+    
+    if (pBuf != NULL)
+    {
+        sscanf(pBuf, "%x", &nMode);   
+        DBG("firmware mode = 0x%x\n", nMode);
+
+        if (nMode == FIRMWARE_MODE_DEMO_MODE) //demo mode
+        {
+            g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_DEMO_MODE);
+        }
+        else if (nMode == FIRMWARE_MODE_DEBUG_MODE) //debug mode
+        {
+            g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_DEBUG_MODE);
+        }
+#if defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+        else if (nMode == FIRMWARE_MODE_RAW_DATA_MODE) //raw data mode
+        {
+            g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_RAW_DATA_MODE);
+        }
+#endif
+        else
+        {
+            DBG("*** Undefined Firmware Mode ***\n");
+        }
+    }
+
+    DBG("*** g_FirmwareMode = 0x%x ***\n", g_FirmwareMode);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(mode, SYSFS_AUTHORITY, DrvMainFirmwareModeShow, DrvMainFirmwareModeStore);
+/*
+ssize_t DrvMainFirmwarePacketShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    u32 i = 0;
+    u32 nLength = 0;
+    
+    DBG("*** %s() ***\n", __func__);
+    
+    if (g_LogModePacket != NULL)
+    {
+        DBG("g_FirmwareMode=%x, g_LogModePacket[0]=%x, g_LogModePacket[1]=%x\n", g_FirmwareMode, g_LogModePacket[0], g_LogModePacket[1]);
+        DBG("g_LogModePacket[2]=%x, g_LogModePacket[3]=%x\n", g_LogModePacket[2], g_LogModePacket[3]);
+        DBG("g_LogModePacket[4]=%x, g_LogModePacket[5]=%x\n", g_LogModePacket[4], g_LogModePacket[5]);
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+        if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE) && (g_LogModePacket[0] == 0xA5 || g_LogModePacket[0] == 0xAB || g_LogModePacket[0] == 0xA7))
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+        if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE) && (g_LogModePacket[0] == 0x62))
+#endif
+        {
+            for (i = 0; i < g_FirmwareInfo.nLogModePacketLength; i ++)
+            {
+                pBuf[i] = g_LogModePacket[i];
+            }
+
+            nLength = g_FirmwareInfo.nLogModePacketLength;
+            DBG("nLength = %d\n", nLength);
+        }
+        else
+        {
+            DBG("CURRENT MODE IS NOT DEBUG MODE/WRONG DEBUG MODE HEADER\n");
+//        nLength = 0;
+        }
+    }
+    else
+    {
+        DBG("g_LogModePacket is NULL\n");
+//        nLength = 0;
+    }
+
+    return nLength;
+}
+
+ssize_t DrvMainFirmwarePacketStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(packet, SYSFS_AUTHORITY, DrvMainFirmwarePacketShow, DrvMainFirmwarePacketStore);
+*/
+ssize_t DrvMainFirmwareSensorShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    if (g_FirmwareInfo.nLogModePacketHeader == 0xA5 || g_FirmwareInfo.nLogModePacketHeader == 0xAB)
+    {
+        return sprintf(pBuf, "%d,%d", g_FirmwareInfo.nMx, g_FirmwareInfo.nMy);
+    }
+    else if (g_FirmwareInfo.nLogModePacketHeader == 0xA7)
+    {
+        return sprintf(pBuf, "%d,%d,%d,%d", g_FirmwareInfo.nMx, g_FirmwareInfo.nMy, g_FirmwareInfo.nSs, g_FirmwareInfo.nSd);
+    }
+    else
+    {
+        DBG("Undefined debug mode packet format : 0x%x\n", g_FirmwareInfo.nLogModePacketHeader);
+        return 0;
+    }
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    return sprintf(pBuf, "%d", g_FirmwareInfo.nLogModePacketLength);
+#endif
+}
+
+ssize_t DrvMainFirmwareSensorStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+/*
+    DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+#if defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+#endif 
+*/    
+    return nSize;
+}
+
+static DEVICE_ATTR(sensor, SYSFS_AUTHORITY, DrvMainFirmwareSensorShow, DrvMainFirmwareSensorStore);
+
+ssize_t DrvMainFirmwareHeaderShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return sprintf(pBuf, "%d", g_FirmwareInfo.nLogModePacketHeader);
+}
+
+ssize_t DrvMainFirmwareHeaderStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+/*
+    DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+#if defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+#endif
+*/    
+    return nSize;
+}
+
+static DEVICE_ATTR(header, SYSFS_AUTHORITY, DrvMainFirmwareHeaderShow, DrvMainFirmwareHeaderStore);
+
+//------------------------------------------------------------------------------//
+
+ssize_t DrvMainKObjectPacketShow(struct kobject *pKObj, struct kobj_attribute *pAttr, char *pBuf)
+{
+    u32 i = 0;
+    u32 nLength = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (strcmp(pAttr->attr.name, "packet") == 0)
+    {
+        if (g_LogModePacket != NULL)
+        {
+            DBG("g_FirmwareMode=%x, g_LogModePacket[0]=%x, g_LogModePacket[1]=%x\n", g_FirmwareMode, g_LogModePacket[0], g_LogModePacket[1]);
+            DBG("g_LogModePacket[2]=%x, g_LogModePacket[3]=%x\n", g_LogModePacket[2], g_LogModePacket[3]);
+            DBG("g_LogModePacket[4]=%x, g_LogModePacket[5]=%x\n", g_LogModePacket[4], g_LogModePacket[5]);
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+            if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE) && (g_LogModePacket[0] == 0xA5 || g_LogModePacket[0] == 0xAB || g_LogModePacket[0] == 0xA7))
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+            if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE) && (g_LogModePacket[0] == 0x62))
+#endif
+            {
+                for (i = 0; i < g_FirmwareInfo.nLogModePacketLength; i ++)
+                {
+                    pBuf[i] = g_LogModePacket[i];
+                }
+
+                nLength = g_FirmwareInfo.nLogModePacketLength;
+                DBG("nLength = %d\n", nLength);
+            }
+            else
+            {
+                DBG("CURRENT MODE IS NOT DEBUG MODE/WRONG DEBUG MODE HEADER\n");
+//            nLength = 0;
+            }
+        }
+        else
+        {
+            DBG("g_LogModePacket is NULL\n");
+//            nLength = 0;
+        }
+    }
+    else
+    {
+        DBG("pAttr->attr.name = %s \n", pAttr->attr.name);
+//        nLength = 0;
+    }
+
+    return nLength;
+}
+
+ssize_t DrvMainKObjectPacketStore(struct kobject *pKObj, struct kobj_attribute *pAttr, const char *pBuf, size_t nCount)
+{
+    DBG("*** %s() ***\n", __func__);
+/*
+    if (strcmp(pAttr->attr.name, "packet") == 0)
+    {
+
+    }
+*/    	
+    return nCount;
+}
+
+static struct kobj_attribute packet_attr = __ATTR(packet, 0666, DrvMainKObjectPacketShow, DrvMainKObjectPacketStore);
+
+/* Create a group of attributes so that we can create and destroy them all at once. */
+static struct attribute *attrs[] = {
+    &packet_attr.attr,
+    NULL,	/* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory. If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+struct attribute_group attr_group = {
+    .attrs = attrs,
+};
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+//------------------------------------------------------------------------------//
+
+s32 DrvMainTouchDeviceInitialize(void)
+{
+    s32 nRetVal = 0;
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    u8 *pDevicePath = NULL;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    DBG("*** %s() ***\n", __func__);
+
+    /* set sysfs for firmware */
+    _gFirmwareClass = class_create(THIS_MODULE, "ms-touchscreen-msg20xx");
+    if (IS_ERR(_gFirmwareClass))
+        DBG("Failed to create class(firmware)!\n");
+
+    _gFirmwareCmdDev = device_create(_gFirmwareClass, NULL, 0, NULL, "device");
+    if (IS_ERR(_gFirmwareCmdDev))
+        DBG("Failed to create device(_gFirmwareCmdDev)!\n");
+
+    // version
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_version) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_version.attr.name);
+    // update
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_update) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_update.attr.name);
+    // data
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_data) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_data.attr.name);
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+    // test
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_test) < 0)
+        pr_err("Failed to create device file(%s)!\n", dev_attr_test.attr.name);
+    // test_log
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_test_log) < 0)
+        pr_err("Failed to create device file(%s)!\n", dev_attr_test_log.attr.name);
+    // test_fail_channel
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_test_fail_channel) < 0)
+        pr_err("Failed to create device file(%s)!\n", dev_attr_test_fail_channel.attr.name);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    // mode
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_mode) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_mode.attr.name);
+    // packet
+//    if (device_create_file(_gFirmwareCmdDev, &dev_attr_packet) < 0)
+//        DBG("Failed to create device file(%s)!\n", dev_attr_packet.attr.name);
+    // sensor
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_sensor) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_sensor.attr.name);
+    // header
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_header) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_header.attr.name);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    // debug
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_debug) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_debug.attr.name);
+    // platform version
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_platform_version) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_platform_version.attr.name);
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    // gesture wakeup mode
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_gesture_wakeup_mode) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_gesture_wakeup_mode.attr.name);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+    // chip type
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_chip_type) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_chip_type.attr.name);
+    // driver version
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_driver_version) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_driver_version.attr.name);
+
+    dev_set_drvdata(_gFirmwareCmdDev, NULL);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+    DrvIcFwLyrCreateMpTestWorkQueue();
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+    
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    /* create a kset with the name of "kset_example" which is located under /sys/kernel/ */
+    g_TouchKSet = kset_create_and_add("kset_example", NULL, kernel_kobj);
+    if (!g_TouchKSet)
+    {
+        DBG("*** kset_create_and_add() failed, nRetVal = %d ***\n", nRetVal);
+
+        nRetVal = -ENOMEM;
+    }
+
+    g_TouchKObj = kobject_create();
+    if (!g_TouchKObj)
+    {
+        DBG("*** kobject_create() failed, nRetVal = %d ***\n", nRetVal);
+
+        nRetVal = -ENOMEM;
+		    kset_unregister(g_TouchKSet);
+		    g_TouchKSet = NULL;
+    }
+
+    g_TouchKObj->kset = g_TouchKSet;
+
+    nRetVal = kobject_add(g_TouchKObj, NULL, "%s", "kobject_example");
+    if (nRetVal != 0)
+    {
+        DBG("*** kobject_add() failed, nRetVal = %d ***\n", nRetVal);
+
+		    kobject_put(g_TouchKObj);
+		    g_TouchKObj = NULL;
+		    kset_unregister(g_TouchKSet);
+		    g_TouchKSet = NULL;
+    }
+    
+    /* create the files associated with this kobject */
+    nRetVal = sysfs_create_group(g_TouchKObj, &attr_group);
+    if (nRetVal != 0)
+    {
+        DBG("*** sysfs_create_file() failed, nRetVal = %d ***\n", nRetVal);
+
+        kobject_put(g_TouchKObj);
+		    g_TouchKObj = NULL;
+		    kset_unregister(g_TouchKSet);
+		    g_TouchKSet = NULL;
+    }
+    
+    pDevicePath = kobject_get_path(g_TouchKObj, GFP_KERNEL);
+    DBG("DEVPATH = %s\n", pDevicePath);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    g_ChipType = DrvIcFwLyrGetChipType();
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    // get firmware mode for parsing packet judgement.
+    g_FirmwareMode = DrvIcFwLyrGetFirmwareMode();
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+
+    memset(&g_FirmwareInfo, 0x0, sizeof(FirmwareInfo_t));
+
+    DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+
+#if defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+#endif
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+    DrvIcFwLyrCheckFirmwareUpdateBySwId();
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+    return nRetVal;
+}
+
+//------------------------------------------------------------------------------//
\ No newline at end of file
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_main.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_main.h
new file mode 100644
index 0000000..e19e6b1
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_main.h
@@ -0,0 +1,89 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_main.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_MAIN_H__
+#define __MSTAR_DRV_MAIN_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR MACRO DEFINITION                                            */
+/*--------------------------------------------------------------------------*/
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern ssize_t DrvMainFirmwareDataShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareDataStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwareUpdateShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareUpdateStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwareVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern ssize_t DrvMainFirmwareTestShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareTestStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern ssize_t DrvMainFirmwareGestureWakeupModeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareGestureWakeupModeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+extern ssize_t DrvMainFirmwareDebugShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareDebugStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwarePlatformVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwarePlatformVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern ssize_t DrvMainFirmwareHeaderShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareHeaderStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwareModeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareModeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+//extern ssize_t DrvMainFirmwarePacketShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+//extern ssize_t DrvMainFirmwarePacketStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwareSensorShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareSensorStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainKObjectPacketShow(struct kobject *pKObj, struct kobj_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainKObjectPacketStore(struct kobject *pKObj, struct kobj_attribute *pAttr, const char *pBuf, size_t nCount);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern s32 DrvMainTouchDeviceInitialize(void);
+
+#endif  /* __MSTAR_DRV_MAIN_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_mtk.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_mtk.c
new file mode 100644
index 0000000..756720a
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_mtk.c
@@ -0,0 +1,288 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_mtk.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/hwmsen_helper.h>
+//#include <linux/hw_module_info.h>
+
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/namei.h>
+#include <linux/vmalloc.h>
+
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+#include <mach/mt_gpio.h>
+
+#include <cust_eint.h>
+
+#include "tpd.h"
+#include "cust_gpio_usage.h"
+
+#include "mstar_drv_platform_interface.h"
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+#define MSG_TP_IC_NAME "msg2xxx" //"msg21xxA" or "msg22xx" or "msg26xxM" /* Please define the mstar touch ic name based on the mutual-capacitive ic or self capacitive ic that you are using */
+#define I2C_BUS_ID   (2)       // i2c bus id : 0 or 1
+
+#define TPD_OK (0)
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_TP_HAVE_KEY
+extern const int g_TpVirtualKey[];
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+extern const int g_TpVirtualKeyDimLocal[][4];
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+extern struct tpd_device *tpd;
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+/*
+#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
+static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
+static int tpd_wb_end_local[TPD_WARP_CNT] = TPD_WARP_END;
+#endif
+
+#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
+static int tpd_calmat_local[8] = TPD_CALIBRATION_MATRIX;
+static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
+#endif
+*/
+struct i2c_client *g_I2cClient = NULL;
+//add below for ekt and mstar compat
+extern int ektf2k_probed;
+extern int have_ektf2k_chip_on_board;
+//end add for ekt and mstar compat
+//static int boot_mode = 0;
+
+/*=============================================================*/
+// FUNCTION DECLARATION
+/*=============================================================*/
+
+/*=============================================================*/
+// FUNCTION DEFINITION
+/*=============================================================*/
+
+/* probe function is used for matching and initializing input device */
+static int  tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    TPD_DMESG("TPD probe\n");   
+    
+    if (client == NULL)
+    {
+        TPD_DMESG("i2c client is NULL\n");
+        return -1;
+    }
+	do
+	{
+		printk("--%s:[%d]:wait ekt dirver probe over:have_ektf2k_chip_on_board = %d\n", __func__, __LINE__, have_ektf2k_chip_on_board);
+		msleep(10);
+	}while(ektf2k_probed == 0);
+	if (have_ektf2k_chip_on_board == 1)
+	{
+		printk("--%s:[%d]:Board TP chip is ekt , now mstar probe stop ..\n", __func__, __LINE__);
+		return -1;
+	}
+    g_I2cClient = client;
+    
+    MsDrvInterfaceTouchDeviceSetIicDataRate(g_I2cClient, 100000); // 100 KHZ
+
+    MsDrvInterfaceTouchDeviceProbe(g_I2cClient, id);
+
+    tpd_load_status = 1;
+
+    TPD_DMESG("TPD probe done\n");
+    
+    return TPD_OK;   
+}
+
+static int tpd_detect(struct i2c_client *client, struct i2c_board_info *info) 
+{
+    strcpy(info->type, TPD_DEVICE);    
+//    strcpy(info->type, MSG_TP_IC_NAME);
+    
+    return TPD_OK;
+}
+
+static int tpd_remove(struct i2c_client *client)
+{   
+    TPD_DEBUG("TPD removed\n");
+    
+    MsDrvInterfaceTouchDeviceRemove(client);
+    
+    return TPD_OK;
+}
+
+static struct i2c_board_info __initdata i2c_tpd = {I2C_BOARD_INFO(MSG_TP_IC_NAME, (0x4C>>1))};
+
+/* The I2C device list is used for matching I2C device and I2C device driver. */
+static const struct i2c_device_id tpd_device_id[] =
+{
+    {MSG_TP_IC_NAME, 0},
+    {}, /* should not omitted */ 
+};
+
+MODULE_DEVICE_TABLE(i2c, tpd_device_id);
+
+static struct i2c_driver tpd_i2c_driver = {
+    .driver = {
+        .name = MSG_TP_IC_NAME,
+    },
+    .probe = tpd_probe,
+    .remove = tpd_remove,
+    .id_table = tpd_device_id,
+    .detect = tpd_detect,
+};
+
+static int tpd_local_init(void)
+{  
+    TPD_DMESG("TPD init device driver (Built %s @ %s)\n", __DATE__, __TIME__);
+/*
+    // Software reset mode will be treated as normal boot
+    boot_mode = get_boot_mode();
+    if (boot_mode == 3) 
+    {
+        boot_mode = NORMAL_BOOT;    
+    }
+*/
+    if (i2c_add_driver(&tpd_i2c_driver) != 0)
+    {
+        TPD_DMESG("unable to add i2c driver.\n");
+         
+        return -1;
+    }
+    
+    if (tpd_load_status == 0) 
+    {
+        TPD_DMESG("add error touch panel driver.\n");
+
+        i2c_del_driver(&tpd_i2c_driver);
+        return -1;
+    }
+
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE     
+    // initialize tpd button data
+    tpd_button_setting(4, g_TpVirtualKey, g_TpVirtualKeyDimLocal); //MAX_KEY_NUM
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE  
+#endif //CONFIG_TP_HAVE_KEY  
+
+/*
+#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))    
+    TPD_DO_WARP = 1;
+    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT*4);
+    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT*4);
+#endif 
+
+#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
+    memcpy(tpd_calmat, tpd_def_calmat_local, 8*4);
+    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8*4);    
+#endif  
+*/
+    TPD_DMESG("TPD init done %s, %d\n", __FUNCTION__, __LINE__);  
+        
+    return TPD_OK; 
+}
+
+static void tpd_resume(struct early_suspend *h)
+{
+    TPD_DMESG("TPD wake up\n");
+    
+    MsDrvInterfaceTouchDeviceResume(h);
+    
+    TPD_DMESG("TPD wake up done\n");
+}
+
+static void tpd_suspend(struct early_suspend *h)
+{
+    TPD_DMESG("TPD enter sleep\n");
+
+    MsDrvInterfaceTouchDeviceSuspend(h);
+
+    TPD_DMESG("TPD enter sleep done\n");
+} 
+
+static struct tpd_driver_t tpd_device_driver = {
+     .tpd_device_name = MSG_TP_IC_NAME,
+     .tpd_local_init = tpd_local_init,
+     .suspend = tpd_suspend,
+     .resume = tpd_resume,
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+     .tpd_have_button = 1,
+#else
+     .tpd_have_button = 0,
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE        
+#endif //CONFIG_TP_HAVE_KEY        
+};
+
+static int __init tpd_driver_init(void) 
+{
+    TPD_DMESG("touch panel driver init\n");
+
+    i2c_register_board_info(I2C_BUS_ID, &i2c_tpd, 1);
+    if (tpd_driver_add(&tpd_device_driver) < 0)
+    {
+        TPD_DMESG("TPD add driver failed\n");
+    }
+     
+    return 0;
+}
+ 
+static void __exit tpd_driver_exit(void) 
+{
+    TPD_DMESG("touch panel driver exit\n");
+    
+    tpd_driver_remove(&tpd_device_driver);
+}
+
+module_init(tpd_driver_init);
+module_exit(tpd_driver_exit);
+MODULE_LICENSE("GPL");
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_interface.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_interface.c
new file mode 100644
index 0000000..8ca0510
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_interface.c
@@ -0,0 +1,147 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_interface.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_platform_interface.h"
+#include "mstar_drv_main.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+#include "mstar_drv_platform_porting_layer.h"
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u16 g_GestureWakeupMode;
+extern u8 g_GestureWakeupFlag;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+extern struct input_dev *g_InputDevice;
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+void MsDrvInterfaceTouchDeviceSuspend(struct early_suspend *pSuspend)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+//    g_GestureWakeupMode = 0x1FFF; // Enable all gesture wakeup mode for testing 
+
+    if (g_GestureWakeupMode != 0x0000)
+    {
+        DrvIcFwLyrOpenGestureWakeup(g_GestureWakeupMode);
+        return;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    DrvPlatformLyrFingerTouchReleased(0, 0); // Send touch end for clearing point touch
+    input_sync(g_InputDevice);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+    DrvPlatformLyrTouchDevicePowerOff(); 
+}
+
+void MsDrvInterfaceTouchDeviceResume(struct early_suspend *pSuspend)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        DrvIcFwLyrCloseGestureWakeup();
+    }
+    else
+    {
+        DrvPlatformLyrEnableFingerTouchReport(); 
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+    
+    DrvPlatformLyrTouchDevicePowerOn();
+/*
+    DrvPlatformLyrFingerTouchReleased(0, 0);
+    input_sync(g_InputDevice);
+*/    
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    DrvIcFwLyrRestoreFirmwareModeToLogDataMode();
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifndef CONFIG_ENABLE_GESTURE_WAKEUP
+    DrvPlatformLyrEnableFingerTouchReport(); 
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+}
+
+/* probe function is used for matching and initializing input device */
+s32 /*__devinit*/ MsDrvInterfaceTouchDeviceProbe(struct i2c_client *pClient, const struct i2c_device_id *pDeviceId)
+{
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+  
+    DrvPlatformLyrInputDeviceInitialize(pClient);
+  
+    DrvPlatformLyrTouchDeviceRequestGPIO();
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+    DrvPlatformLyrTouchDeviceRegulatorPowerOn();
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+    DrvPlatformLyrTouchDevicePowerOn();
+
+    DrvMainTouchDeviceInitialize();
+
+    DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler();
+
+    DrvPlatformLyrTouchDeviceRegisterEarlySuspend();
+
+    DBG("*** MStar touch driver registered ***\n");
+    
+    return nRetVal;
+}
+
+/* remove function is triggered when the input device is removed from input sub-system */
+s32 /*__devexit*/ MsDrvInterfaceTouchDeviceRemove(struct i2c_client *pClient)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return DrvPlatformLyrTouchDeviceRemove(pClient);
+}
+
+void MsDrvInterfaceTouchDeviceSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    DrvPlatformLyrSetIicDataRate(pClient, nIicDataRate);
+}    
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_interface.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_interface.h
new file mode 100644
index 0000000..251c45a
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_interface.h
@@ -0,0 +1,47 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_interface.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_INTERFACE_H__
+#define __MSTAR_DRV_PLATFORM_INTERFACE_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern s32 /*__devinit*/ MsDrvInterfaceTouchDeviceProbe(struct i2c_client *pClient, const struct i2c_device_id *pDeviceId);
+extern s32 /*__devexit*/ MsDrvInterfaceTouchDeviceRemove(struct i2c_client *pClient);
+extern void MsDrvInterfaceTouchDeviceResume(struct early_suspend *pSuspend);        
+extern void MsDrvInterfaceTouchDeviceSuspend(struct early_suspend *pSuspend);
+extern void MsDrvInterfaceTouchDeviceSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate);
+        
+#endif  /* __MSTAR_DRV_PLATFORM_INTERFACE_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_porting_layer.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_porting_layer.c
new file mode 100644
index 0000000..944a900
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_porting_layer.c
@@ -0,0 +1,598 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_porting_layer.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+#include "mstar_drv_platform_interface.h"
+
+/*=============================================================*/
+// EXTREN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern struct kset *g_TouchKSet;
+extern struct kobject *g_TouchKObj;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+extern struct tpd_device *tpd;
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+extern struct regulator *g_ReguVdd;
+#endif
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+struct mutex g_Mutex;
+static struct work_struct _gFingerTouchWork;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+static struct early_suspend _gEarlySuspend;
+#endif
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifndef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+static DECLARE_WAIT_QUEUE_HEAD(_gWaiter);
+static struct task_struct *_gThread = NULL;
+static int _gTpdFlag = 0;
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_TP_HAVE_KEY
+const int g_TpVirtualKey[] = {TOUCH_KEY_MENU, TOUCH_KEY_HOME, TOUCH_KEY_BACK, TOUCH_KEY_SEARCH};
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#define BUTTON_W (100)
+#define BUTTON_H (100)
+
+const int g_TpVirtualKeyDimLocal[MAX_KEY_NUM][4] = {{BUTTON_W/2*1,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},{BUTTON_W/2*3,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},{BUTTON_W/2*5,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},{BUTTON_W/2*7,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H}};
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+struct input_dev *g_InputDevice = NULL;
+static int _gIrq = -1;
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+/* read data through I2C then report data to input sub-system when interrupt occurred */
+static void _DrvPlatformLyrFingerTouchDoWork(struct work_struct *pWork)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+    mutex_lock(&g_Mutex);
+
+    DrvIcFwLyrHandleFingerTouch(NULL, 0);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    enable_irq(MS_TS_MSG_IC_GPIO_INT);
+    enable_irq(_gIrq);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
+#endif
+
+    mutex_unlock(&g_Mutex);
+}
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+/* The interrupt service routine will be triggered when interrupt occurred */
+static irqreturn_t _DrvPlatformLyrFingerTouchInterruptHandler(s32 nIrq, void *pDeviceId)
+{
+    DBG("*** %s() ***\n", __func__);
+
+//    disable_irq_nosync(MS_TS_MSG_IC_GPIO_INT);
+    disable_irq_nosync(_gIrq);
+    schedule_work(&_gFingerTouchWork);
+
+    return IRQ_HANDLED;
+}
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+static void _DrvPlatformLyrFingerTouchInterruptHandler(void)
+{
+#ifdef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+    schedule_work(&_gFingerTouchWork);
+#else    
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+
+    _gTpdFlag = 1;
+    wake_up_interruptible(&_gWaiter); 
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+}
+
+static int _DrvPlatformLyrFingerTouchHandler(void *pUnUsed)
+{
+    struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
+    sched_setscheduler(current, SCHED_RR, &param);
+	
+    do
+    {
+        set_current_state(TASK_INTERRUPTIBLE);
+        wait_event_interruptible(_gWaiter, _gTpdFlag != 0);
+        _gTpdFlag = 0;
+        
+        set_current_state(TASK_RUNNING);
+
+        mutex_lock(&g_Mutex);
+
+        DrvIcFwLyrHandleFingerTouch(NULL, 0);
+
+        mutex_unlock(&g_Mutex);
+
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
+		
+    } while (!kthread_should_stop());
+	
+    return 0;
+}
+#endif
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+void DrvPlatformLyrTouchDeviceRegulatorPowerOn(void)
+{
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+    
+    nRetVal = regulator_set_voltage(g_ReguVdd, 2800000, 2800000); // For specific SPRD BB chip(ex. SC7715) or QCOM BB chip, need to enable this function call for correctly power on Touch IC.
+
+    if (nRetVal)
+    {
+        DBG("Could not set to 2800mv.\n");
+    }
+    regulator_enable(g_ReguVdd);
+
+    mdelay(20); //mdelay(100);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    hwPowerOn(MT6323_POWER_LDO_VGP1, VOL_2800, "TP"); // For specific MTK BB chip(ex. MT6582), need to enable this function call for correctly power on Touch IC.
+#endif
+}
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+void DrvPlatformLyrTouchDevicePowerOn(void)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 1);
+//    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1); 
+//    mdelay(100);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+    mdelay(10);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1);
+    mdelay(300);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+
+#ifdef TPD_CLOSE_POWER_IN_SLEEP
+    hwPowerDown(TPD_POWER_SOURCE, "TP"); 
+    mdelay(100);
+    hwPowerOn(TPD_POWER_SOURCE, VOL_2800, "TP"); 
+    mdelay(10);  // reset pulse
+#endif //TPD_CLOSE_POWER_IN_SLEEP
+
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    mdelay(180); // wait stable
+#endif
+}
+
+void DrvPlatformLyrTouchDevicePowerOff(void)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 0);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+#ifdef TPD_CLOSE_POWER_IN_SLEEP
+    hwPowerDown(TPD_POWER_SOURCE, "TP");
+#endif //TPD_CLOSE_POWER_IN_SLEEP
+#endif    
+}
+
+void DrvPlatformLyrTouchDeviceResetHw(void)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 1);
+//    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1); 
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+    mdelay(100); 
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1);
+    mdelay(100); 
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    mdelay(10);
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+    mdelay(50);
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    mdelay(50); 
+#endif
+}
+
+void DrvPlatformLyrDisableFingerTouchReport(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    disable_irq(MS_TS_MSG_IC_GPIO_RST);
+    disable_irq(_gIrq);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif
+}
+
+void DrvPlatformLyrEnableFingerTouchReport(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    enable_irq(MS_TS_MSG_IC_GPIO_RST);
+    enable_irq(_gIrq);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif
+}
+
+void DrvPlatformLyrFingerTouchPressed(s32 nX, s32 nY, s32 nPressure, s32 nId)
+{
+    DBG("*** %s() ***\n", __func__);
+    DBG("point touch pressed\n");
+
+    input_report_key(g_InputDevice, BTN_TOUCH, 1);
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    input_report_abs(g_InputDevice, ABS_MT_TRACKING_ID, nId);
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+    input_report_abs(g_InputDevice, ABS_MT_TOUCH_MAJOR, 1);
+    input_report_abs(g_InputDevice, ABS_MT_WIDTH_MAJOR, 1);
+    input_report_abs(g_InputDevice, ABS_MT_POSITION_X, nX);
+    input_report_abs(g_InputDevice, ABS_MT_POSITION_Y, nY);
+
+    input_mt_sync(g_InputDevice);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_TP_HAVE_KEY    
+    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+    {   
+        tpd_button(nX, nY, 1);  
+    }
+#endif //CONFIG_TP_HAVE_KEY
+
+    TPD_EM_PRINT(nX, nY, nX, nY, nPressure-1, 1);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+}
+
+void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY)
+{
+    DBG("*** %s() ***\n", __func__);
+    DBG("point touch released\n");
+
+    input_report_key(g_InputDevice, BTN_TOUCH, 0);
+    input_mt_sync(g_InputDevice);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_TP_HAVE_KEY 
+    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+    {   
+       tpd_button(nX, nY, 0); 
+//       tpd_button(0, 0, 0); 
+    }            
+#endif //CONFIG_TP_HAVE_KEY    
+
+    TPD_EM_PRINT(nX, nY, nX, nY, 0, 0);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+}
+
+s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient)
+{
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    mutex_init(&g_Mutex);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    /* allocate an input device */
+    g_InputDevice = input_allocate_device();
+    if (g_InputDevice == NULL)
+    {
+        DBG("*** input device allocation failed ***\n");
+        return -ENOMEM;
+    }
+
+    g_InputDevice->name = pClient->name;
+    g_InputDevice->phys = "I2C";
+    g_InputDevice->dev.parent = &pClient->dev;
+    g_InputDevice->id.bustype = BUS_I2C;
+    
+    /* set the supported event type for input device */
+    set_bit(EV_ABS, g_InputDevice->evbit);
+    set_bit(EV_SYN, g_InputDevice->evbit);
+    set_bit(EV_KEY, g_InputDevice->evbit);
+    set_bit(BTN_TOUCH, g_InputDevice->keybit);
+    set_bit(INPUT_PROP_DIRECT, g_InputDevice->propbit);
+
+#ifdef CONFIG_TP_HAVE_KEY
+    {
+        u32 i;
+        for (i = 0; i < MAX_KEY_NUM; i ++)
+        {
+            input_set_capability(g_InputDevice, EV_KEY, g_TpVirtualKey[i]);
+        }
+    }
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    input_set_capability(g_InputDevice, EV_KEY, KEY_POWER);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_UP);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_DOWN);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_LEFT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_RIGHT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_W);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_Z);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_V);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_O);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_M);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_C);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_E);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_S);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*
+#ifdef CONFIG_TP_HAVE_KEY
+    set_bit(TOUCH_KEY_MENU, g_InputDevice->keybit); //Menu
+    set_bit(TOUCH_KEY_HOME, g_InputDevice->keybit); //Home
+    set_bit(TOUCH_KEY_BACK, g_InputDevice->keybit); //Back
+    set_bit(TOUCH_KEY_SEARCH, g_InputDevice->keybit); //Search
+#endif
+*/
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    input_set_abs_params(g_InputDevice, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+    input_set_abs_params(g_InputDevice, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_X, TOUCH_SCREEN_X_MIN, TOUCH_SCREEN_X_MAX, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_Y, TOUCH_SCREEN_Y_MIN, TOUCH_SCREEN_Y_MAX, 0, 0);
+
+    /* register the input device to input sub-system */
+    nRetVal = input_register_device(g_InputDevice);
+    if (nRetVal < 0)
+    {
+        DBG("*** Unable to register touch input device ***\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    g_InputDevice = tpd->dev;
+
+//    g_InputDevice->name = pClient->name;
+    g_InputDevice->phys = "I2C";
+    g_InputDevice->dev.parent = &pClient->dev;
+    g_InputDevice->id.bustype = BUS_I2C;
+    
+    /* set the supported event type for input device */
+    set_bit(EV_ABS, g_InputDevice->evbit);
+    set_bit(EV_SYN, g_InputDevice->evbit);
+    set_bit(EV_KEY, g_InputDevice->evbit);
+    set_bit(BTN_TOUCH, g_InputDevice->keybit);
+    set_bit(INPUT_PROP_DIRECT, g_InputDevice->propbit);
+
+#ifdef CONFIG_TP_HAVE_KEY
+    {
+        u32 i;
+        for (i = 0; i < MAX_KEY_NUM; i ++)
+        {
+            input_set_capability(g_InputDevice, EV_KEY, g_TpVirtualKey[i]);
+        }
+    }
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    input_set_capability(g_InputDevice, EV_KEY, KEY_POWER);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_UP);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_DOWN);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_LEFT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_RIGHT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_W);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_Z);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_V);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_O);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_M);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_C);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_E);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_S);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*
+#ifdef CONFIG_TP_HAVE_KEY
+    set_bit(TOUCH_KEY_MENU, g_InputDevice->keybit); //Menu
+    set_bit(TOUCH_KEY_HOME, g_InputDevice->keybit); //Home
+    set_bit(TOUCH_KEY_BACK, g_InputDevice->keybit); //Back
+    set_bit(TOUCH_KEY_SEARCH, g_InputDevice->keybit); //Search
+#endif
+*/
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    input_set_abs_params(g_InputDevice, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+    input_set_abs_params(g_InputDevice, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_X, TOUCH_SCREEN_X_MIN, TOUCH_SCREEN_X_MAX, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_Y, TOUCH_SCREEN_Y_MIN, TOUCH_SCREEN_Y_MAX, 0, 0);
+#endif
+
+    return nRetVal;    
+}
+
+s32 DrvPlatformLyrTouchDeviceRequestGPIO(void)
+{
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_RST, "C_TP_RST");     
+    if (nRetVal < 0)
+    {
+        DBG("*** Failed to request GPIO %d, error %d ***\n", MS_TS_MSG_IC_GPIO_RST, nRetVal);
+    }
+
+    nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_INT, "C_TP_INT");    
+    if (nRetVal < 0)
+    {
+        DBG("*** Failed to request GPIO %d, error %d ***\n", MS_TS_MSG_IC_GPIO_INT, nRetVal);
+    }
+#endif
+
+    return nRetVal;    
+}
+
+s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void)
+{
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (DrvIcFwLyrIsRegisterFingerTouchInterruptHandler())
+    {    	
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+        /* initialize the finger touch work queue */ 
+        INIT_WORK(&_gFingerTouchWork, _DrvPlatformLyrFingerTouchDoWork);
+
+        _gIrq = gpio_to_irq(MS_TS_MSG_IC_GPIO_INT);
+
+        /* request an irq and register the isr */
+        nRetVal = request_irq(_gIrq/*MS_TS_MSG_IC_GPIO_INT*/, _DrvPlatformLyrFingerTouchInterruptHandler,
+                      IRQF_TRIGGER_RISING /* | IRQF_NO_SUSPEND *//* IRQF_TRIGGER_FALLING */,
+                      "msg2xxx", NULL);
+        if (nRetVal != 0)
+        {
+            DBG("*** Unable to claim irq %d; error %d ***\n", MS_TS_MSG_IC_GPIO_INT, nRetVal);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_INT, GPIO_CTP_EINT_PIN_M_EINT);
+        mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_INT, GPIO_DIR_IN);
+        mt_set_gpio_pull_enable(MS_TS_MSG_IC_GPIO_INT, GPIO_PULL_ENABLE);
+        mt_set_gpio_pull_select(MS_TS_MSG_IC_GPIO_INT, GPIO_PULL_UP);
+
+        mt_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
+        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_RISING, _DrvPlatformLyrFingerTouchInterruptHandler, 1);
+
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+
+#ifdef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+        /* initialize the finger touch work queue */ 
+        INIT_WORK(&_gFingerTouchWork, _DrvPlatformLyrFingerTouchDoWork);
+#else
+        _gThread = kthread_run(_DrvPlatformLyrFingerTouchHandler, 0, TPD_DEVICE);
+        if (IS_ERR(_gThread))
+        { 
+            nRetVal = PTR_ERR(_gThread);
+            DBG("Failed to create kernel thread: %d\n", nRetVal);
+        }
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+#endif
+    }
+    
+    return nRetVal;    
+}	
+
+void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    _gEarlySuspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+    _gEarlySuspend.suspend = MsDrvInterfaceTouchDeviceSuspend;
+    _gEarlySuspend.resume = MsDrvInterfaceTouchDeviceResume;
+    register_early_suspend(&_gEarlySuspend);
+#endif    
+}
+
+/* remove function is triggered when the input device is removed from input sub-system */
+s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    free_irq(MS_TS_MSG_IC_GPIO_INT, g_InputDevice);
+    free_irq(_gIrq, g_InputDevice);
+    gpio_free(MS_TS_MSG_IC_GPIO_INT);
+    gpio_free(MS_TS_MSG_IC_GPIO_RST);
+    input_unregister_device(g_InputDevice);
+#endif    
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    kset_unregister(g_TouchKSet);
+    kobject_put(g_TouchKObj);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    return 0;
+}
+
+void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate)
+{
+    DBG("*** %s() nIicDataRate = %d ***\n", __func__, nIicDataRate);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    // TODO : Please FAE colleague to confirm with customer device driver engineer for how to set i2c data rate on SPRD platform
+    //sprd_i2c_ctl_chg_clk(pClient->adapter->nr, nIicDataRate); 
+    //mdelay(100);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    // TODO : Please FAE colleague to confirm with customer device driver engineer for how to set i2c data rate on QCOM platform
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    pClient->timing = nIicDataRate/1000;
+#endif
+}
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_porting_layer.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_porting_layer.h
new file mode 100644
index 0000000..7a9121c
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_platform_porting_layer.h
@@ -0,0 +1,155 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+#define __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+#include <mach/board.h>
+#include <mach/gpio.h>
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <mach/regulator.h>
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/hwmsen_helper.h>
+//#include <linux/hw_module_info.h>
+
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/namei.h>
+#include <linux/vmalloc.h>
+
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+#include <mach/mt_gpio.h>
+
+#include <cust_eint.h>
+#include "tpd.h"
+#include "cust_gpio_usage.h"
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Note.
+ * Please change the below GPIO pin setting to follow the platform that you are using(EX. MediaTek, Spreadtrum, Qualcomm).
+ */
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+// TODO : Please FAE colleague to confirm with customer device driver engineer about the value of RST and INT GPIO setting
+#define MS_TS_MSG_IC_GPIO_RST   GPIO_CTP_RST_PIN //53 //35 
+#define MS_TS_MSG_IC_GPIO_INT   GPIO_CTP_EINT_PIN   //52 //37
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139) //229
+#define TOUCH_KEY_HOME (172) //102
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+// TODO : Please FAE colleague to confirm with customer device driver engineer about the value of RST and INT GPIO setting
+#define MS_TS_MSG_IC_GPIO_RST   0
+#define MS_TS_MSG_IC_GPIO_INT   1
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139) //229
+#define TOUCH_KEY_HOME (172) //102
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#define MS_TS_MSG_IC_GPIO_RST   (GPIO_CTP_RST_PIN)
+#define MS_TS_MSG_IC_GPIO_INT   (GPIO_CTP_EINT_PIN)
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU    KEY_MENU 
+#define TOUCH_KEY_HOME    KEY_HOMEPAGE 
+#define TOUCH_KEY_BACK    KEY_BACK
+#define TOUCH_KEY_SEARCH  KEY_SEARCH
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern void DrvPlatformLyrDisableFingerTouchReport(void);
+extern void DrvPlatformLyrEnableFingerTouchReport(void);
+extern void DrvPlatformLyrFingerTouchPressed(s32 nX, s32 nY, s32 nPressure, s32 nId);
+extern void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY);
+extern s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient);
+extern void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate);
+extern void DrvPlatformLyrTouchDevicePowerOff(void);
+extern void DrvPlatformLyrTouchDevicePowerOn(void);
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegulatorPowerOn(void);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void);
+extern s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient);
+extern s32 DrvPlatformLyrTouchDeviceRequestGPIO(void);        
+extern void DrvPlatformLyrTouchDeviceResetHw(void);
+        
+#endif  /* __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_self_fw_control.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_self_fw_control.c
new file mode 100644
index 0000000..64f816c
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_self_fw_control.c
@@ -0,0 +1,3974 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_self_fw_control.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_self_fw_control.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_TP_HAVE_KEY
+extern const int g_TpVirtualKey[];
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+extern const int g_TpVirtualKeyDimLocal[][4];
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+extern struct input_dev *g_InputDevice;
+
+extern u8 g_FwData[94][1024];
+extern u32 g_FwDataCount;
+
+extern struct mutex g_Mutex;
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern struct kobject *g_TouchKObj;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static u8 _gTpVendorCode[3] = {0};
+
+static u8 _gDwIicInfoData[1024];
+static u8 _gOneDimenFwData[MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024+MSG22XX_FIRMWARE_INFO_BLOCK_SIZE] = {0}; // used for MSG22XX
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+/*
+ * Note.
+ * Please modify the name of the below .h depends on the vendor TP that you are using.
+ */
+#include "msg2xxx_xxxx_update_bin.h"
+#include "msg2xxx_yyyy_update_bin.h"
+
+static u32 _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+static struct work_struct _gUpdateFirmwareBySwIdWork;
+static struct workqueue_struct *_gUpdateFirmwareBySwIdWorkQueue = NULL;
+
+static u32 _gIsUpdateInfoBlockFirst = 0;
+static u8 _gIsUpdateFirmware = 0x00;
+
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+static u16 _gGestureWakeupValue = 0;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+u8 g_ChipType = 0;
+u8 g_DemoModePacket[DEMO_MODE_PACKET_LENGTH] = {0};
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+FirmwareInfo_t g_FirmwareInfo;
+
+u8 *g_LogModePacket = NULL;
+u16 g_FirmwareMode = FIRMWARE_MODE_DEMO_MODE; 
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+u8 *_gGestureWakeupPacket = NULL;
+
+u16 g_GestureWakeupMode = 0x0000;
+u8 g_GestureWakeupFlag = 0;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*=============================================================*/
+// LOCAL FUNCTION DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+static void _DrvFwCtrlUpdateFirmwareBySwIdDoWork(struct work_struct *pWork);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+static void _DrvFwCtrlEraseEmemC32(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    /////////////////////////
+    //Erase  all
+    /////////////////////////
+    
+    // Enter gpio mode
+    RegSet16BitValue(0x161E, 0xBEAF);
+
+    // Before gpio mode, set the control pin as the orginal status
+    RegSet16BitValue(0x1608, 0x0000);
+    RegSetLByteValue(0x160E, 0x10);
+    mdelay(10); 
+
+    // ptrim = 1, h'04[2]
+    RegSetLByteValue(0x1608, 0x04);
+    RegSetLByteValue(0x160E, 0x10);
+    mdelay(10); 
+
+    // ptm = 6, h'04[12:14] = b'110
+    RegSetLByteValue(0x1609, 0x60);
+    RegSetLByteValue(0x160E, 0x10);
+
+    // pmasi = 1, h'04[6]
+    RegSetLByteValue(0x1608, 0x44);
+    // pce = 1, h'04[11]
+    RegSetLByteValue(0x1609, 0x68);
+    // perase = 1, h'04[7]
+    RegSetLByteValue(0x1608, 0xC4);
+    // pnvstr = 1, h'04[5]
+    RegSetLByteValue(0x1608, 0xE4);
+    // pwe = 1, h'04[9]
+    RegSetLByteValue(0x1609, 0x6A);
+    // trigger gpio load
+    RegSetLByteValue(0x160E, 0x10);
+}
+
+static void _DrvFwCtrlEraseEmemC33(EmemType_e eEmemType)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    // Clear pce
+    RegSetLByteValue(0x1618, 0x80);
+
+    if (eEmemType == EMEM_ALL)
+    {
+        RegSetLByteValue(0x1608, 0x10); //mark
+    }
+
+    RegSetLByteValue(0x1618, 0x40);
+    mdelay(10);
+
+    RegSetLByteValue(0x1618, 0x80);
+
+    // erase trigger
+    if (eEmemType == EMEM_MAIN)
+    {
+        RegSetLByteValue(0x160E, 0x04); //erase main
+    }
+    else
+    {
+        RegSetLByteValue(0x160E, 0x08); //erase all block
+    }
+}
+
+static void _DrvFwCtrlMsg22xxGetTpVendorCode(u8 *pTpVendorCode)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        u16 nRegData1, nRegData2;
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        mdelay(100);
+        
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        // Clear pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xC1E9); // Set start address for tp vendor code on info block(Actually, start reading from 0xC1E8)
+    
+        // Enable burst mode
+//        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        // Set pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+        RegSetLByteValue(0x160E, 0x01); 
+
+        nRegData1 = RegGet16BitValue(0x1604);
+        nRegData2 = RegGet16BitValue(0x1606);
+
+        pTpVendorCode[0] = ((nRegData1 >> 8) & 0xFF);
+        pTpVendorCode[1] = (nRegData2 & 0xFF);
+        pTpVendorCode[2] = ((nRegData2 >> 8) & 0xFF);
+
+        DBG("pTpVendorCode[0] = 0x%x , %c \n", pTpVendorCode[0], pTpVendorCode[0]); 
+        DBG("pTpVendorCode[1] = 0x%x , %c \n", pTpVendorCode[1], pTpVendorCode[1]); 
+        DBG("pTpVendorCode[2] = 0x%x , %c \n", pTpVendorCode[2], pTpVendorCode[2]); 
+        
+        // Clear burst mode
+//        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+        mdelay(100);
+    }
+}
+
+static void _DrvFwCtrlMsg22xxEraseEmem(EmemType_e eEmemType)
+{
+    u32 i;
+    u16 nRegData = 0;
+    
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    DBG("Erase start\n");
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    if (eEmemType == EMEM_ALL) // 48KB + 512Byte
+    {
+        DBG("Erase all block\n");
+
+        // Clear pce
+        RegSetLByteValue(0x1618, 0x80);
+        mdelay(100);
+
+        // Chip erase
+        RegSet16BitValue(0x160E, BIT3);
+
+        DBG("Wait erase done flag\n");
+
+        do // Wait erase done flag
+        {
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            mdelay(50);
+        } while((nRegData & BIT1) != BIT1);
+    }
+    else if (eEmemType == EMEM_MAIN) // 48KB (32+8+8)
+    {
+        DBG("Erase main block\n");
+
+        for (i = 0; i < 3; i ++)
+        {
+            // Clear pce
+            RegSetLByteValue(0x1618, 0x80);
+            mdelay(10);
+
+            if (i == 0)
+            {
+                RegSet16BitValue(0x1600, 0x0000);
+            }
+            else if (i == 1)
+            {
+                RegSet16BitValue(0x1600, 0x8000);
+            }
+            else if (i == 2)
+            {
+                RegSet16BitValue(0x1600, 0xA000);
+            }
+
+            // Sector erase
+            RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+            DBG("Wait erase done flag\n");
+
+            do // Wait erase done flag
+            {
+                nRegData = RegGet16BitValue(0x1610); // Memory status
+                mdelay(50);
+            } while((nRegData & BIT1) != BIT1);
+        }   
+    }
+    else if (eEmemType == EMEM_INFO) // 512Byte
+    {
+        DBG("Erase info block\n");
+
+        // Clear pce
+        RegSetLByteValue(0x1618, 0x80);
+        mdelay(10);
+
+        RegSet16BitValue(0x1600, 0xC000);
+        
+        // Sector erase
+        RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+        DBG("Wait erase done flag\n");
+
+        do // Wait erase done flag
+        {
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            mdelay(50);
+        } while((nRegData & BIT1) != BIT1);
+    }
+    
+    DBG("Erase end\n");
+    
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+}
+
+static void _DrvFwCtrlMsg22xxProgramEmem(EmemType_e eEmemType) // For MSG22XX
+{
+    u32 i, j; 
+    u32 nRemainSize = 0, nBlockSize = 0, nSize = 0, index = 0;
+    u16 nRegData;
+    u8 szDbBusTxData[1024] = {0};
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u32 nSizePerWrite = 125;
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    u32 nSizePerWrite = 1021;
+#endif
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Hold reset pin before program
+    RegSetLByteValue(0x1E06, 0x00);
+
+    DBG("Program start\n");
+
+    RegSet16BitValue(0x161A, 0xABBA);
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+    if (eEmemType == EMEM_MAIN)
+    {
+        DBG("Program main block\n");
+
+        RegSet16BitValue(0x1600, 0x0000); // Set start address of main block
+        nRemainSize = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024; //48KB
+        index = 0;
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        DBG("Program info block\n");
+
+        RegSet16BitValue(0x1600, 0xC000); // Set start address of info block
+        nRemainSize = MSG22XX_FIRMWARE_INFO_BLOCK_SIZE; //512Byte
+        index = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024;
+    }
+    else
+    {
+        DBG("eEmemType = %d is not supported for program e-memory.\n", eEmemType);
+        return;
+    }
+
+    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+
+    // Program start
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x16;
+    szDbBusTxData[2] = 0x02;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+
+    szDbBusTxData[0] = 0x20;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+    i = 0;
+    
+    while (nRemainSize > 0)
+    {
+        if (nRemainSize > nSizePerWrite)
+        {
+            nBlockSize = nSizePerWrite;
+        }
+        else
+        {
+            nBlockSize = nRemainSize;
+        }
+
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+
+        nSize = 3;
+
+        for (j = 0; j < nBlockSize; j ++)
+        {
+            szDbBusTxData[3+j] = _gOneDimenFwData[index+(i*nSizePerWrite)+j];
+            nSize ++; 
+        }
+        i ++;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+
+        nRemainSize = nRemainSize - nBlockSize;
+    }
+
+    // Program end
+    szDbBusTxData[0] = 0x21;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+    nRegData = RegGet16BitValue(0x160C); 
+    RegSet16BitValue(0x160C, nRegData & (~0x01));      
+
+    DBG("Wait write done flag\n");
+
+    // Polling 0x1610 is 0x0002
+    do
+    {
+        nRegData = RegGet16BitValue(0x1610);
+        nRegData = nRegData & BIT1;
+        mdelay(10);
+
+    } while (nRegData != BIT1); // Wait write done flag
+
+    DBG("Program end\n");
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+}
+
+static u32 _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EmemType_e eEmemType) // For MSG22XX
+{
+    u16 nCrcDown = 0;
+    u32 nRetVal = 0; 
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA);      
+
+    // Set PCE high
+    RegSetLByteValue(0x1618, 0x40);      
+
+    if (eEmemType == EMEM_MAIN)
+    {
+        // Set start address and end address for main block
+        RegSet16BitValue(0x1600, 0x0000);      
+        RegSet16BitValue(0x1640, 0xBFF8);      
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        // Set start address and end address for info block
+        RegSet16BitValue(0x1600, 0xC000);      
+        RegSet16BitValue(0x1640, 0xC1F8);      
+    }
+
+    // CRC reset
+    RegSet16BitValue(0x164E, 0x0001);      
+
+    RegSet16BitValue(0x164E, 0x0000);   
+    
+    // Trigger CRC check
+    RegSetLByteValue(0x160E, 0x20);   
+    mdelay(10);
+       
+    nCrcDown = RegGet16BitValue(0x164E);
+    
+    while (nCrcDown != 2)
+    {
+        DBG("Wait CRC down\n");
+        mdelay(10);
+        nCrcDown = RegGet16BitValue(0x164E);
+    }
+
+    nRetVal = RegGet16BitValue(0x1652);
+    nRetVal = (nRetVal << 16) | RegGet16BitValue(0x1650);
+
+    DBG("Hardware CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static void _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(u8 szTwoDimenFwData[][1024], u8* pOneDimenFwData)
+{
+    u32 i, j;
+
+    DBG("*** %s() ***\n", __func__);
+
+    for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+    {
+        if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                pOneDimenFwData[i*1024+j] = szTwoDimenFwData[i][j];
+            }
+        }
+        else // i == 48
+        {
+            for (j = 0; j < 512; j ++)
+            {
+                pOneDimenFwData[i*1024+j] = szTwoDimenFwData[i][j];
+            }
+        }
+    }
+}
+
+static s32 _DrvFwCtrlParsePacket(u8 *pPacket, u16 nLength, TouchInfo_t *pInfo)
+{
+    u8 nCheckSum = 0;
+    u32 nDeltaX = 0, nDeltaY = 0;
+    u32 nX = 0;
+    u32 nY = 0;
+#ifdef CONFIG_SWAP_X_Y
+    u32 nTempX;
+    u32 nTempY;
+#endif
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    u8 nCheckSumIndex = 0;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+    {
+        nCheckSumIndex = 7;
+    }
+    else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE)
+    {
+        nCheckSumIndex = 31;
+    }
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        nCheckSumIndex = nLength-1;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    nCheckSum = DrvCommonCalculateCheckSum(&pPacket[0], nCheckSumIndex);
+    DBG("check sum : [%x] == [%x]? \n", pPacket[nCheckSumIndex], nCheckSum);
+#else
+    nCheckSum = DrvCommonCalculateCheckSum(&pPacket[0], (nLength-1));
+    DBG("check ksum : [%x] == [%x]? \n", pPacket[nLength-1], nCheckSum);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        u8 nWakeupMode = 0;
+        u8 bIsCorrectFormat = 0;
+
+        DBG("received raw data from touch panel as following:\n");
+        DBG("pPacket[0]=%x \n pPacket[1]=%x pPacket[2]=%x pPacket[3]=%x pPacket[4]=%x pPacket[5]=%x \n", \
+            pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5]);
+
+        if (g_ChipType == CHIP_TYPE_MSG22XX && pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x06 && pPacket[3] == 0x50)
+        {
+            nWakeupMode = pPacket[4];
+            bIsCorrectFormat = 1;
+        } 
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA && pPacket[0] == 0x52 && pPacket[1] == 0xFF && pPacket[2] == 0xFF && pPacket[3] == 0xFF && pPacket[4] == 0xFF && pPacket[6] == 0xFF)
+        {
+            nWakeupMode = pPacket[5];
+            bIsCorrectFormat = 1;
+        }
+        
+        if (bIsCorrectFormat) 
+        {
+            DBG("nWakeupMode = 0x%x\n", nWakeupMode);
+
+            switch (nWakeupMode)
+            {
+                case 0x58:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+
+                    DBG("Light up screen by DOUBLE_CLICK gesture wakeup.\n");
+
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x60:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+                    
+                    DBG("Light up screen by UP_DIRECT gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_UP, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_UP, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x61:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+
+                    DBG("Light up screen by DOWN_DIRECT gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_DOWN, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_DOWN, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x62:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+
+                    DBG("Light up screen by LEFT_DIRECT gesture wakeup.\n");
+
+//                  input_report_key(g_InputDevice, KEY_LEFT, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_LEFT, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x63:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+
+                    DBG("Light up screen by RIGHT_DIRECT gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_RIGHT, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_RIGHT, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x64:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+
+                    DBG("Light up screen by m_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_M, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_M, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x65:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+
+                    DBG("Light up screen by W_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_W, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_W, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x66:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+
+                    DBG("Light up screen by C_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_C, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_C, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x67:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+
+                    DBG("Light up screen by e_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_E, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_E, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x68:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+
+                    DBG("Light up screen by V_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_V, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_V, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x69:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+
+                    DBG("Light up screen by O_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_O, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_O, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x6A:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+
+                    DBG("Light up screen by S_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_S, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_S, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x6B:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+
+                    DBG("Light up screen by Z_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_Z, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_Z, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                default:
+                    _gGestureWakeupValue = 0;
+                    break;		
+            }
+
+            DBG("_gGestureWakeupValue = 0x%x\n", _gGestureWakeupValue);
+        }
+        else
+        {
+            DBG("gesture wakeup packet format is incorrect.\n");
+        }
+        
+        return -1;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    DBG("received raw data from touch panel as following:\n");
+    DBG("pPacket[0]=%x \n pPacket[1]=%x pPacket[2]=%x pPacket[3]=%x pPacket[4]=%x \n pPacket[5]=%x pPacket[6]=%x pPacket[7]=%x \n", \
+                pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5], pPacket[6], pPacket[7]);
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    if ((pPacket[nCheckSumIndex] == nCheckSum) && (pPacket[0] == 0x52))   // check the checksum of packet
+#else
+    if ((pPacket[nLength-1] == nCheckSum) && (pPacket[0] == 0x52))   // check the checksum of packet
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    {
+        nX = (((pPacket[1] & 0xF0) << 4) | pPacket[2]);         // parse the packet to coordinate
+        nY = (((pPacket[1] & 0x0F) << 8) | pPacket[3]);
+
+        nDeltaX = (((pPacket[4] & 0xF0) << 4) | pPacket[5]);
+        nDeltaY = (((pPacket[4] & 0x0F) << 8) | pPacket[6]);
+
+        DBG("[x,y]=[%d,%d]\n", nX, nY);
+        DBG("[delta_x,delta_y]=[%d,%d]\n", nDeltaX, nDeltaY);
+
+#ifdef CONFIG_SWAP_X_Y
+        nTempY = nX;
+        nTempX = nY;
+        nX = nTempX;
+        nY = nTempY;
+        
+        nTempY = nDeltaX;
+        nTempX = nDeltaY;
+        nDeltaX = nTempX;
+        nDeltaY = nTempY;
+#endif
+
+#ifdef CONFIG_REVERSE_X
+        nX = 2047 - nX;
+        nDeltaX = 4095 - nDeltaX;
+#endif
+
+#ifdef CONFIG_REVERSE_Y
+        nY = 2047 - nY;
+        nDeltaY = 4095 - nDeltaY;
+#endif
+
+        /*
+         * pPacket[0]:id, pPacket[1]~pPacket[3]:the first point abs, pPacket[4]~pPacket[6]:the relative distance between the first point abs and the second point abs
+         * when pPacket[1]~pPacket[4], pPacket[6] is 0xFF, keyevent, pPacket[5] to judge which key press.
+         * pPacket[1]~pPacket[6] all are 0xFF, release touch
+        */
+        if ((pPacket[1] == 0xFF) && (pPacket[2] == 0xFF) && (pPacket[3] == 0xFF) && (pPacket[4] == 0xFF) && (pPacket[6] == 0xFF))
+        {
+            pInfo->tPoint[0].nX = 0; // final X coordinate
+            pInfo->tPoint[0].nY = 0; // final Y coordinate
+
+            if ((pPacket[5] != 0x00) && (pPacket[5] != 0xFF)) /* pPacket[5] is key value */
+            {   /* 0x00 is key up, 0xff is touch screen up */
+                DBG("touch key down pPacket[5]=%d\n", pPacket[5]);
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = pPacket[5];
+                pInfo->nTouchKeyMode = 1;
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;
+
+                if (pPacket[5] == 4) // TOUCH_KEY_HOME
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[1][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[1][1];
+                }
+                else if (pPacket[5] == 1) // TOUCH_KEY_MENU
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[0][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[0][1];
+                }           
+                else if (pPacket[5] == 2) // TOUCH_KEY_BACK
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[2][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[2][1];
+                }           
+                else if (pPacket[5] == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[3][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[3][1];
+                }
+                else
+                {
+                    DBG("multi-key is pressed.\n");
+
+                    return -1;
+                }
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+            }
+            else
+            {   /* key up or touch up */
+                DBG("touch end\n");
+                pInfo->nFingerNum = 0; //touch end
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;    
+            }
+        }
+        else
+        {
+            pInfo->nTouchKeyMode = 0; //Touch on screen...
+
+//            if ((nDeltaX == 0) && (nDeltaY == 0))
+          if(
+#ifdef CONFIG_REVERSE_X
+                (nDeltaX == 4095)
+#else
+                (nDeltaX == 0)
+#endif
+                &&
+#ifdef CONFIG_REVERSE_Y
+                (nDeltaY == 4095)
+#else
+                (nDeltaY == 0)
+#endif
+            )
+            {   /* one touch point */
+                pInfo->nFingerNum = 1; // one touch
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: [x,y]=[%d,%d]\n", __func__, nX, nY);
+                DBG("[%s]: point[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+            }
+            else
+            {   /* two touch points */
+                u32 nX2, nY2;
+                
+                pInfo->nFingerNum = 2; // two touch
+                /* Finger 1 */
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: point1[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+                /* Finger 2 */
+                if (nDeltaX > 2048)     // transform the unsigned value to signed value
+                {
+                    nDeltaX -= 4096;
+                }
+                
+                if (nDeltaY > 2048)
+                {
+                    nDeltaY -= 4096;
+                }
+
+                nX2 = (u32)(nX + nDeltaX);
+                nY2 = (u32)(nY + nDeltaY);
+
+                pInfo->tPoint[1].nX = (nX2 * TOUCH_SCREEN_X_MAX) / TPD_WIDTH; 
+                pInfo->tPoint[1].nY = (nY2 * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: point2[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[1].nX, pInfo->tPoint[1].nY);
+            }
+        }
+    }
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    else if (pPacket[nCheckSumIndex] == nCheckSum && pPacket[0] == 0x62)
+    {
+        nX = ((pPacket[1] << 8) | pPacket[2]);  // Position_X
+        nY = ((pPacket[3] << 8) | pPacket[4]);  // Position_Y
+
+        nDeltaX = ((pPacket[13] << 8) | pPacket[14]); // Distance_X
+        nDeltaY = ((pPacket[15] << 8) | pPacket[16]); // Distance_Y
+
+        DBG("[x,y]=[%d,%d]\n", nX, nY);
+        DBG("[delta_x,delta_y]=[%d,%d]\n", nDeltaX, nDeltaY);
+
+#ifdef CONFIG_SWAP_X_Y
+        nTempY = nX;
+        nTempX = nY;
+        nX = nTempX;
+        nY = nTempY;
+        
+        nTempY = nDeltaX;
+        nTempX = nDeltaY;
+        nDeltaX = nTempX;
+        nDeltaY = nTempY;
+#endif
+
+#ifdef CONFIG_REVERSE_X
+        nX = 2047 - nX;
+        nDeltaX = 4095 - nDeltaX;
+#endif
+
+#ifdef CONFIG_REVERSE_Y
+        nY = 2047 - nY;
+        nDeltaY = 4095 - nDeltaY;
+#endif
+
+        /*
+         * pPacket[0]:id, pPacket[1]~pPacket[4]:the first point abs, pPacket[13]~pPacket[16]:the relative distance between the first point abs and the second point abs
+         * when pPacket[1]~pPacket[7] is 0xFF, keyevent, pPacket[8] to judge which key press.
+         * pPacket[1]~pPacket[8] all are 0xFF, release touch
+         */
+        if ((pPacket[1] == 0xFF) && (pPacket[2] == 0xFF) && (pPacket[3] == 0xFF) && (pPacket[4] == 0xFF) && (pPacket[5] == 0xFF) && (pPacket[6] == 0xFF) && (pPacket[7] == 0xFF))
+        {
+            pInfo->tPoint[0].nX = 0; // final X coordinate
+            pInfo->tPoint[0].nY = 0; // final Y coordinate
+
+            if ((pPacket[8] != 0x00) && (pPacket[8] != 0xFF)) /* pPacket[8] is key value */
+            {   /* 0x00 is key up, 0xff is touch screen up */
+                DBG("touch key down pPacket[8]=%d\n", pPacket[8]);
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = pPacket[8];
+                pInfo->nTouchKeyMode = 1;
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;
+
+                if (pPacket[8] == 4) // TOUCH_KEY_HOME
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[1][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[1][1];
+                }
+                else if (pPacket[8] == 1) // TOUCH_KEY_MENU
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[0][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[0][1];
+                }           
+                else if (pPacket[8] == 2) // TOUCH_KEY_BACK
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[2][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[2][1];
+                }           
+                else if (pPacket[8] == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[3][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[3][1];
+                }
+                else
+                {
+                    DBG("multi-key is pressed.\n");
+
+                    return -1;
+                }
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+            }
+            else
+            {   /* key up or touch up */
+                DBG("touch end\n");
+                pInfo->nFingerNum = 0; //touch end
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;    
+            }
+        }
+        else
+        {
+            pInfo->nTouchKeyMode = 0; //Touch on screen...
+
+//            if ((nDeltaX == 0) && (nDeltaY == 0))
+            if (
+#ifdef CONFIG_REVERSE_X
+                (nDeltaX == 4095)
+#else
+                (nDeltaX == 0)
+#endif
+                &&
+#ifdef CONFIG_REVERSE_Y
+                (nDeltaY == 4095)
+#else
+                (nDeltaY == 0)
+#endif
+                )
+            {   /* one touch point */
+                pInfo->nFingerNum = 1; // one touch
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: [x,y]=[%d,%d]\n", __func__, nX, nY);
+                DBG("[%s]: point[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+            }
+            else
+            {   /* two touch points */
+                u32 nX2, nY2;
+                
+                pInfo->nFingerNum = 2; // two touch
+                /* Finger 1 */
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: point1[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+                /* Finger 2 */
+                if (nDeltaX > 2048)     // transform the unsigned value to signed value
+                {
+                    nDeltaX -= 4096;
+                }
+                
+                if (nDeltaY > 2048)
+                {
+                    nDeltaY -= 4096;
+                }
+
+                nX2 = (u32)(nX + nDeltaX);
+                nY2 = (u32)(nY + nDeltaY);
+
+                pInfo->tPoint[1].nX = (nX2 * TOUCH_SCREEN_X_MAX) / TPD_WIDTH; 
+                pInfo->tPoint[1].nY = (nY2 * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: point2[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[1].nX, pInfo->tPoint[1].nY);
+            }
+
+            // Notify android application to retrieve log data mode packet from device driver by sysfs.   
+            if (g_TouchKObj != NULL)
+            {
+                char *pEnvp[2];
+                s32 nRetVal = 0; 
+
+                pEnvp[0] = "STATUS=GET_PACKET";  
+                pEnvp[1] = NULL;  
+    
+                nRetVal = kobject_uevent_env(g_TouchKObj, KOBJ_CHANGE, pEnvp); 
+                DBG("kobject_uevent_env() nRetVal = %d\n", nRetVal);
+            }
+        }
+    }
+    else
+    {
+        if (pPacket[nCheckSumIndex] != nCheckSum)
+        {
+            DBG("WRONG CHECKSUM\n");
+            return -1;
+        }
+
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE && pPacket[0] != 0x52)
+        {
+            DBG("WRONG DEMO MODE HEADER\n");
+            return -1;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && pPacket[0] != 0x62)
+        {
+            DBG("WRONG DEBUG MODE HEADER\n");
+            return -1;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE && pPacket[0] != 0x62)
+        {
+            DBG("WRONG RAW DATA MODE HEADER\n");
+            return -1;
+        }
+    }
+#else    
+    else
+    {
+        DBG("pPacket[0]=0x%x, pPacket[7]=0x%x, nCheckSum=0x%x\n", pPacket[0], pPacket[7], nCheckSum);
+
+        if (pPacket[nLength-1] != nCheckSum)
+        {
+            DBG("WRONG CHECKSUM\n");
+            return -1;
+        }
+
+        if (pPacket[0] != 0x52)
+        {
+            DBG("WRONG DEMO MODE HEADER\n");
+            return -1;
+        }
+    }
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    return 0;
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+static void _DrvFwCtrlStoreFirmwareData(u8 *pBuf, u32 nSize)
+{
+    u32 nCount = nSize / 1024;
+    u32 i;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (nCount > 0) // nSize >= 1024
+   	{
+        for (i = 0; i < nCount; i ++)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuf+(i*1024), 1024);
+
+            g_FwDataCount ++;
+        }
+    }
+    else // nSize < 1024
+    {
+        if (nSize > 0)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuf, nSize);
+
+            g_FwDataCount ++;
+        }
+    }
+
+    DBG("*** g_FwDataCount = %d ***\n", g_FwDataCount);
+
+    if (pBuf != NULL)
+    {
+        DBG("*** buf[0] = %c ***\n", pBuf[0]);
+    }
+}
+
+//-------------------------Start of SW ID for MSG22XX----------------------------//
+
+static u32 _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EmemType_e eEmemType) // For MSG22XX
+{
+    u32 nRetVal = 0; 
+    u16 nRegData1 = 0, nRegData2 = 0;
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA); 
+
+    // Clear pce
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+    if (eEmemType == EMEM_MAIN) // Read main block CRC(48KB-4) from main block
+    {
+        RegSet16BitValue(0x1600, 0xBFFC); // Set start address for main block CRC
+    }
+    else if (eEmemType == EMEM_INFO) // Read info block CRC(512Byte-4) from info block
+    {
+        RegSet16BitValue(0x1600, 0xC1FC); // Set start address for info block CRC
+    }
+    
+    // Enable burst mode
+    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+    // Set pce
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+    RegSetLByteValue(0x160E, 0x01); 
+
+    nRegData1 = RegGet16BitValue(0x1604);
+    nRegData2 = RegGet16BitValue(0x1606);
+
+    nRetVal  = ((nRegData2 >> 8) & 0xFF) << 24;
+    nRetVal |= (nRegData2 & 0xFF) << 16;
+    nRetVal |= ((nRegData1 >> 8) & 0xFF) << 8;
+    nRetVal |= (nRegData1 & 0xFF);
+    
+    DBG("CRC = 0x%x\n", nRetVal);
+
+    // Clear burst mode
+    RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+    RegSet16BitValue(0x1600, 0x0000); 
+
+    // Clear RIU password
+    RegSet16BitValue(0x161A, 0x0000); 
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(u8 szTmpBuf[], EmemType_e eEmemType) // For MSG22XX
+{
+    u32 nRetVal = 0; 
+    
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+    
+    if (szTmpBuf != NULL)
+    {
+        if (eEmemType == EMEM_MAIN) // Read main block CRC(48KB-4) from bin file
+        {
+            nRetVal  = szTmpBuf[0xBFFF] << 24;
+            nRetVal |= szTmpBuf[0xBFFE] << 16;
+            nRetVal |= szTmpBuf[0xBFFD] << 8;
+            nRetVal |= szTmpBuf[0xBFFC];
+        }
+        else if (eEmemType == EMEM_INFO) // Read info block CRC(512Byte-4) from bin file
+        {
+            nRetVal  = szTmpBuf[0xC1FF] << 24;
+            nRetVal |= szTmpBuf[0xC1FE] << 16;
+            nRetVal |= szTmpBuf[0xC1FD] << 8;
+            nRetVal |= szTmpBuf[0xC1FC];
+        }
+    }
+
+    return nRetVal;
+}
+
+static u16 _DrvFwCtrlMsg22xxGetSwId(EmemType_e eEmemType) // For MSG22XX
+{
+    u16 nRetVal = 0; 
+    u16 nRegData1 = 0;
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA); 
+
+    // Clear pce
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+    if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+    {
+        RegSet16BitValue(0x1600, 0xBFF4); // Set start address for main block SW ID
+    }
+    else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+    {
+        RegSet16BitValue(0x1600, 0xC1EC); // Set start address for info block SW ID
+    }
+
+    /*
+      Ex. SW ID in Main Block :
+          Major low byte at address 0xBFF4
+          Major high byte at address 0xBFF5
+          
+          SW ID in Info Block :
+          Major low byte at address 0xC1EC
+          Major high byte at address 0xC1ED
+    */
+    
+    // Enable burst mode
+//    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+    // Set pce
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+    RegSetLByteValue(0x160E, 0x01); 
+
+    nRegData1 = RegGet16BitValue(0x1604);
+//    nRegData2 = RegGet16BitValue(0x1606);
+
+    nRetVal = ((nRegData1 >> 8) & 0xFF) << 8;
+    nRetVal |= (nRegData1 & 0xFF);
+    
+    // Clear burst mode
+//    RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+    RegSet16BitValue(0x1600, 0x0000); 
+
+    // Clear RIU password
+    RegSet16BitValue(0x161A, 0x0000); 
+    
+    DBG("SW ID = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;		
+}
+
+static s32 _DrvFwCtrlMsg22xxUpdateFirmwareBySwId(void) // For MSG22XX
+{
+    s32 nRetVal = -1;
+    u32 nCrcInfoA = 0, nCrcInfoB = 0, nCrcMainA = 0, nCrcMainB = 0;
+    
+    DBG("*** %s() ***\n", __func__);
+    
+    DBG("_gIsUpdateInfoBlockFirst = %d, _gIsUpdateFirmware = 0x%x\n", _gIsUpdateInfoBlockFirst, _gIsUpdateFirmware);
+
+    _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(g_FwData, _gOneDimenFwData);
+    
+    if (_gIsUpdateInfoBlockFirst == 1)
+    {
+        if ((_gIsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+ 
+            nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+            DBG("nCrcInfoA = 0x%x, nCrcInfoB = 0x%x\n", nCrcInfoA, nCrcInfoB);
+        
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+                _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+                nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+                nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+                DBG("nCrcMainA = 0x%x, nCrcMainB = 0x%x\n", nCrcMainA, nCrcMainB);
+        		
+                if (nCrcMainA == nCrcMainB)
+                {
+                    _gIsUpdateFirmware = 0x00;
+                    nRetVal = 0;
+                }
+                else
+                {
+                    _gIsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                _gIsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((_gIsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+            DBG("nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+    		
+            if (nCrcMainA == nCrcMainB)
+            {
+                _gIsUpdateFirmware = 0x00;
+                nRetVal = 0;
+            }
+            else
+            {
+                _gIsUpdateFirmware = 0x01;
+            }
+        }
+    }
+    else //_gIsUpdateInfoBlockFirst == 0
+    {
+        if ((_gIsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+            DBG("nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+
+            if (nCrcMainA == nCrcMainB)
+            {
+                _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+                _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+
+                nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+                nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+                
+                DBG("nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+                if (nCrcInfoA == nCrcInfoB)
+                {
+                    _gIsUpdateFirmware = 0x00;
+                    nRetVal = 0;
+                }
+                else
+                {
+                    _gIsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                _gIsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((_gIsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+
+            nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+            DBG("nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                _gIsUpdateFirmware = 0x00;
+                nRetVal = 0;
+            }
+            else
+            {
+                _gIsUpdateFirmware = 0x01;
+            }
+        }    		
+    }
+    
+    return nRetVal;	
+}
+
+void _DrvFwCtrlMsg22xxCheckFirmwareUpdateBySwId(void) // For MSG22XX
+{
+    u32 nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB;
+    u32 i;
+    u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+    u16 nMajor = 0, nMinor = 0;
+    u8 *pVersion = NULL;
+    Msg22xxSwId_e eSwId = MSG22XX_SW_ID_UNDEFINED;
+    
+    DBG("*** %s() ***\n", __func__);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DrvFwCtrlGetCustomerFirmwareVersion(&nMajor, &nMinor, &pVersion);
+
+    nCrcMainA = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+    nCrcMainB = _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EMEM_MAIN);
+
+    nCrcInfoA = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+    nCrcInfoB = _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EMEM_INFO);
+    
+    _gUpdateFirmwareBySwIdWorkQueue = create_singlethread_workqueue("update_firmware_by_sw_id");
+    INIT_WORK(&_gUpdateFirmwareBySwIdWork, _DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+    DBG("nCrcMainA=0x%x, nCrcInfoA=0x%x, nCrcMainB=0x%x, nCrcInfoB=0x%x\n", nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB);
+               
+    if (nCrcMainA == nCrcMainB && nCrcInfoA == nCrcInfoB) // Case 1. Main Block:OK, Info Block:OK
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_MAIN);
+    		
+        if (eSwId == MSG22XX_SW_ID_XXXX)
+        {
+            nUpdateBinMajor = msg2xxx_xxxx_update_bin[0xBFF5]<<8 | msg2xxx_xxxx_update_bin[0xBFF4];
+            nUpdateBinMinor = msg2xxx_xxxx_update_bin[0xBFF7]<<8 | msg2xxx_xxxx_update_bin[0xBFF6];
+        }
+        else if (eSwId == MSG22XX_SW_ID_YYYY)
+        {
+            nUpdateBinMajor = msg2xxx_yyyy_update_bin[0xBFF5]<<8 | msg2xxx_yyyy_update_bin[0xBFF4];
+            nUpdateBinMinor = msg2xxx_yyyy_update_bin[0xBFF7]<<8 | msg2xxx_yyyy_update_bin[0xBFF6];
+        }
+        else //eSwId == MSG22XX_SW_ID_UNDEFINED
+        {
+            DBG("eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG22XX_SW_ID_UNDEFINED;
+            nUpdateBinMajor = 0;
+            nUpdateBinMinor = 0;    		        						
+        }
+    		
+        DBG("eSwId=0x%x, nMajor=%d, nMinor=%d, nUpdateBinMajor=%d, nUpdateBinMinor=%d\n", eSwId, nMajor, nMinor, nUpdateBinMajor, nUpdateBinMinor);
+
+        if (nUpdateBinMinor > nMinor)
+        {
+            if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+            {
+                if (eSwId == MSG22XX_SW_ID_XXXX)
+                {
+                    for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                    {
+                        if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                        {
+                            _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+                        }
+                        else // i == 48
+                        {
+                            _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 512);
+                        }
+                    }
+                }
+                else if (eSwId == MSG22XX_SW_ID_YYYY)
+                {
+                    for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                    {
+                        if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                        {
+                            _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+                        }
+                        else // i == 48
+                        {
+                            _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 512);
+                        }
+                    }
+                }
+
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+                _gIsUpdateFirmware = 0x11;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG("The sw id is invalid.\n");
+                DBG("Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG("The update bin version is older than or equal to the current firmware version on e-flash.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+    else if (nCrcMainA == nCrcMainB && nCrcInfoA != nCrcInfoB) // Case 2. Main Block:OK, Info Block:FAIL
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_MAIN);
+    		
+        DBG("eSwId=0x%x\n", eSwId);
+
+        if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+        {
+            if (eSwId == MSG22XX_SW_ID_XXXX)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+            else if (eSwId == MSG22XX_SW_ID_YYYY)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+            _gIsUpdateFirmware = 0x11;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG("The sw id is invalid.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+    else if (nCrcMainA != nCrcMainB && nCrcInfoA == nCrcInfoB) // Case 3. Main Block:FAIL, Info Block:OK
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_INFO);
+		
+        DBG("eSwId=0x%x\n", eSwId);
+
+        if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+        {
+            if (eSwId == MSG22XX_SW_ID_XXXX)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+            else if (eSwId == MSG22XX_SW_ID_YYYY)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            _gIsUpdateInfoBlockFirst = 0; // Set 0 for indicating main block is broken 
+            _gIsUpdateFirmware = 0x11;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG("The sw id is invalid.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+    else // Case 4. Main Block:FAIL, Info Block:FAIL
+    {
+        DBG("Main block and Info block are broken.\n");
+        DBG("Go to normal boot up process.\n");
+    }
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DrvPlatformLyrEnableFingerTouchReport();
+}
+
+//-------------------------End of SW ID for MSG22XX----------------------------//
+
+//-------------------------Start of SW ID for MSG21XXA----------------------------//
+
+static u32 _DrvFwCtrlMsg21xxaCalculateMainCrcFromEFlash(void) // For MSG21XXA
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop Watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xDF4C); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x9432
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x9432);
+
+    // Read calculated main block CRC from register
+    nRetVal = RegGet16BitValue(0x3C80);
+    nRetVal = (nRetVal << 16) | RegGet16BitValue(0x3C82);
+        
+    DBG("Main Block CRC = 0x%x\n", nRetVal);
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg21xxaRetrieveMainCrcFromMainBlock(void) // For MSG21XXA
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG("*** %s() ***\n", __func__);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+     // Read main block CRC from main block
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[1] = 0x7F;
+    szDbBusTxData[2] = 0xFC;
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+    
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    nRetVal = szDbBusRxData[0];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[1];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[2];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[3];
+   
+    DBG("CRC = 0x%x\n", nRetVal);
+
+    return nRetVal;	
+}
+
+static u16 _DrvFwCtrlMsg21xxaGetSwId(EmemType_e eEmemType) // For MSG21XXA
+{
+    u16 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+    szDbBusTxData[0] = 0x72;
+    if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+    {
+        szDbBusTxData[1] = 0x7F;
+        szDbBusTxData[2] = 0x55;
+    }
+    else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+    {
+        szDbBusTxData[1] = 0x83;
+        szDbBusTxData[2] = 0x00;
+    }
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    DBG("szDbBusRxData[0,1,2,3] = 0x%x,0x%x,0x%x,0x%x\n", szDbBusRxData[0], szDbBusRxData[1], szDbBusRxData[2], szDbBusRxData[3]);
+
+    if ((szDbBusRxData[0] >= 0x30 && szDbBusRxData[0] <= 0x39)
+        &&(szDbBusRxData[1] >= 0x30 && szDbBusRxData[1] <= 0x39)
+        &&(szDbBusRxData[2] >= 0x31 && szDbBusRxData[2] <= 0x39))  
+    {
+        nRetVal = (szDbBusRxData[0]-0x30)*100+(szDbBusRxData[1]-0x30)*10+(szDbBusRxData[2]-0x30);
+    }
+    
+    DBG("SW ID = 0x%x\n", nRetVal);
+
+    return nRetVal;		
+}		
+
+static s32 _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(u8 szFwData[][1024], EmemType_e eEmemType) // For MSG21XXA
+{
+    u32 i, j, nCalculateCrcSize;
+    u32 nCrcMain = 0, nCrcMainTp = 0;
+    u32 nCrcInfo = 0, nCrcInfoTp = 0;
+    u32 nCrcTemp = 0;
+    u16 nRegData = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    // erase main
+    _DrvFwCtrlEraseEmemC33(EMEM_MAIN);
+    mdelay(1000);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x1C70);
+    }
+
+    switch (eEmemType)
+    {
+        case EMEM_ALL:
+            RegSet16BitValue(0x3CE4, 0xE38F);  // for all blocks
+            break;
+        case EMEM_MAIN:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for main block
+            break;
+        case EMEM_INFO:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for info block
+
+            RegSetLByteValue(0x0FE6, 0x01);
+
+            RegSetLByteValue(0x3CE4, 0xC5); 
+            RegSetLByteValue(0x3CE5, 0x78); 
+
+            RegSetLByteValue(0x1E04, 0x9F);
+            RegSetLByteValue(0x1E05, 0x82);
+
+            RegSetLByteValue(0x0FE6, 0x00);
+            mdelay(100);
+            break;
+    }
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    if (eEmemType == EMEM_ALL)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_WHOLE_SIZE;
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE;
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE;
+    }
+    else
+    {
+        nCalculateCrcSize = 0;
+    }
+		
+    for (i = 0; i < nCalculateCrcSize; i ++)
+    {
+        if (eEmemType == EMEM_INFO)
+        {
+            i = 32;
+        }
+
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG("nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG("((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG("Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]);
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(szFwData[i][j], nCrcInfo);
+            }
+            
+            if (eEmemType == EMEM_MAIN)
+            {
+                break;
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // write file done and check crc
+        RegSet16BitValue(0x3CE4, 0x1380);
+    }
+    mdelay(10);
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // Polling 0x3CE4 is 0x9432
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x9432);
+    }
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // CRC Main from TP
+        nCrcMainTp = RegGet16BitValue(0x3C80);
+        nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+    }
+
+    if (eEmemType == EMEM_ALL)
+    {
+        // CRC Info from TP
+        nCrcInfoTp = RegGet16BitValue(0x3CA0);
+        nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+    }
+
+    DBG("nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n", nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        if (nCrcMainTp != nCrcMain)
+        {
+            DBG("Update FAILED\n");
+
+            return -1;
+        }
+    }
+
+    if (eEmemType == EMEM_ALL)
+    {
+        if (nCrcInfoTp != nCrcInfo)
+        {
+            DBG("Update FAILED\n");
+
+            return -1;
+        }
+    }
+
+    DBG("Update SUCCESS\n");
+
+    return 0;
+} 
+
+void _DrvFwCtrlMsg21xxaCheckFirmwareUpdateBySwId(void) // For MSG21XXA
+{
+    u32 nCrcMainA, nCrcMainB;
+    u32 i;
+    u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+    u16 nMajor = 0, nMinor = 0;
+    u8 nIsCompareVersion = 0;
+    u8 *pVersion = NULL; 
+    Msg21xxaSwId_e eMainSwId = MSG21XXA_SW_ID_UNDEFINED, eInfoSwId = MSG21XXA_SW_ID_UNDEFINED, eSwId = MSG21XXA_SW_ID_UNDEFINED;
+
+    DBG("*** %s() ***\n", __func__);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DrvFwCtrlGetCustomerFirmwareVersion(&nMajor, &nMinor, &pVersion);
+
+    nCrcMainA = _DrvFwCtrlMsg21xxaCalculateMainCrcFromEFlash();
+    nCrcMainB = _DrvFwCtrlMsg21xxaRetrieveMainCrcFromMainBlock();
+
+    _gUpdateFirmwareBySwIdWorkQueue = create_singlethread_workqueue("update_firmware_by_sw_id");
+    INIT_WORK(&_gUpdateFirmwareBySwIdWork, _DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+    DBG("nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+               
+    if (nCrcMainA == nCrcMainB) 
+    {
+        eMainSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_MAIN);
+        eInfoSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_INFO);
+    		
+        DBG("Check firmware integrity success\n");
+        DBG("eMainSwId=0x%x, eInfoSwId=0x%x\n", eMainSwId, eInfoSwId);
+
+        if (eMainSwId == eInfoSwId)
+        {
+        		eSwId = eMainSwId;
+        		nIsCompareVersion = 1;
+        }
+        else
+        {
+        		eSwId = eInfoSwId;
+        		nIsCompareVersion = 0;
+        }
+        
+        if (eSwId == MSG21XXA_SW_ID_XXXX)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg2xxx_xxxx_update_bin[31][0x34F]<<8 | msg2xxx_xxxx_update_bin[31][0x34E];
+            nUpdateBinMinor = msg2xxx_xxxx_update_bin[31][0x351]<<8 | msg2xxx_xxxx_update_bin[31][0x350];
+#else // By one dimensional array
+            nUpdateBinMajor = msg2xxx_xxxx_update_bin[0x7F4F]<<8 | msg2xxx_xxxx_update_bin[0x7F4E];
+            nUpdateBinMinor = msg2xxx_xxxx_update_bin[0x7F51]<<8 | msg2xxx_xxxx_update_bin[0x7F50];
+#endif
+        }
+        else if (eSwId == MSG21XXA_SW_ID_YYYY)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg2xxx_yyyy_update_bin[31][0x34F]<<8 | msg2xxx_yyyy_update_bin[31][0x34E];
+            nUpdateBinMinor = msg2xxx_yyyy_update_bin[31][0x351]<<8 | msg2xxx_yyyy_update_bin[31][0x350];
+#else // By one dimensional array
+            nUpdateBinMajor = msg2xxx_yyyy_update_bin[0x7F4F]<<8 | msg2xxx_yyyy_update_bin[0x7F4E];
+            nUpdateBinMinor = msg2xxx_yyyy_update_bin[0x7F51]<<8 | msg2xxx_yyyy_update_bin[0x7F50];
+#endif
+        }
+        else //eSwId == MSG21XXA_SW_ID_UNDEFINED
+        {
+            DBG("eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG21XXA_SW_ID_UNDEFINED;
+            nUpdateBinMajor = 0;
+            nUpdateBinMinor = 0;    		        						
+        }
+    		        
+        DBG("eSwId=0x%x, nMajor=%d, nMinor=%d, nUpdateBinMajor=%d, nUpdateBinMinor=%d\n", eSwId, nMajor, nMinor, nUpdateBinMajor, nUpdateBinMinor);
+
+        if ((nUpdateBinMinor > nMinor && nIsCompareVersion == 1) || (nIsCompareVersion == 0))
+        {
+            if (eSwId < MSG21XXA_SW_ID_UNDEFINED && eSwId != 0xFFFF)
+            {
+                if (eSwId == MSG21XXA_SW_ID_XXXX)
+                {
+                    for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                    {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                        _DrvFwCtrlStoreFirmwareData(msg2xxx_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+#endif
+                    }
+                }
+                else if (eSwId == MSG21XXA_SW_ID_YYYY)
+                {
+                    for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                    {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                        _DrvFwCtrlStoreFirmwareData(msg2xxx_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+#endif
+                    }
+                }
+
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG("The sw id is invalid.\n");
+                DBG("Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG("The update bin version is older than or equal to the current firmware version on e-flash.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+    else
+    {
+        eSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_INFO);
+    		
+        DBG("Check firmware integrity failed\n");
+        DBG("eSwId=0x%x\n", eSwId);
+
+        if (eSwId < MSG21XXA_SW_ID_UNDEFINED && eSwId != 0xFFFF)
+        {
+            if (eSwId == MSG21XXA_SW_ID_XXXX)
+            {
+                for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg2xxx_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else if (eSwId == MSG21XXA_SW_ID_YYYY)
+            {
+                for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg2xxx_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG("The sw id is invalid.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DrvPlatformLyrEnableFingerTouchReport();
+}
+
+//-------------------------End of SW ID for MSG21XXA----------------------------//
+
+static void _DrvFwCtrlUpdateFirmwareBySwIdDoWork(struct work_struct *pWork)
+{
+    s32 nRetVal = 0;
+    
+    DBG("*** %s() _gUpdateRetryCount = %d ***\n", __func__, _gUpdateRetryCount);
+
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+    {
+        nRetVal = _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(g_FwData, EMEM_MAIN);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)    
+    {
+        nRetVal = _DrvFwCtrlMsg22xxUpdateFirmwareBySwId();
+    }
+    else
+    {
+        DBG("This chip type (%d) does not support update firmware by sw id\n", g_ChipType);
+
+        DrvPlatformLyrTouchDeviceResetHw(); 
+
+        DrvPlatformLyrEnableFingerTouchReport();
+
+        nRetVal = -1;
+        return;
+    }
+    
+    DBG("*** update firmware by sw id result = %d ***\n", nRetVal);
+    
+    if (nRetVal == 0)
+    {
+        DBG("update firmware by sw id success\n");
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        DrvPlatformLyrEnableFingerTouchReport();
+
+        if (g_ChipType == CHIP_TYPE_MSG22XX)    
+        {
+            _gIsUpdateInfoBlockFirst = 0;
+            _gIsUpdateFirmware = 0x00;
+        }
+    }
+    else //nRetVal == -1
+    {
+        _gUpdateRetryCount --;
+        if (_gUpdateRetryCount > 0)
+        {
+            DBG("_gUpdateRetryCount = %d\n", _gUpdateRetryCount);
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+        }
+        else
+        {
+            DBG("update firmware by sw id failed\n");
+
+            DrvPlatformLyrTouchDeviceResetHw();
+
+            DrvPlatformLyrEnableFingerTouchReport();
+
+            if (g_ChipType == CHIP_TYPE_MSG22XX)    
+            {
+                _gIsUpdateInfoBlockFirst = 0;
+                _gIsUpdateFirmware = 0x00;
+            }
+        }
+    }
+}
+
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
+
+static void _DrvFwCtrlReadInfoC33(void)
+{
+    u8 szDbBusTxData[5] = {0};
+    u16 nRegData = 0;
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u32 i;
+#endif 
+
+    DBG("*** %s() ***\n", __func__);
+    
+    mdelay(300);
+
+    // Stop Watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    RegSet16BitValue(0x3CE4, 0xA4AB);
+
+    RegSet16BitValue(0x1E04, 0x7d60);
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x829F);
+    mdelay(1);
+    
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x0F;
+    szDbBusTxData[2] = 0xE6;
+    szDbBusTxData[3] = 0x00;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, szDbBusTxData, 4);    
+    mdelay(100);
+
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x5B58);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x80; // read 128 bytes
+
+    for (i = 0; i < 8; i ++)
+    {
+        szDbBusTxData[1] = 0x80 + (((i*128)&0xff00)>>8);
+        szDbBusTxData[2] = (i*128)&0x00ff;
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+
+        mdelay(50);
+
+        // Receive info data
+        IicReadData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[i*128], 128);
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[1] = 0x80;
+    szDbBusTxData[2] = 0x00;
+    szDbBusTxData[3] = 0x04; // read 1024 bytes
+    szDbBusTxData[4] = 0x00;
+    
+    IicWriteData(SLAVE_I2C_ID_DWI2C, szDbBusTxData, 5);
+
+    mdelay(50);
+
+    // Receive info data
+    IicReadData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[0], 1024);
+#endif
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareC32(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u32 i, j;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u32 nCrcTemp;
+    u16 nRegData = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    /////////////////////////
+    // Erase  all
+    /////////////////////////
+    _DrvFwCtrlEraseEmemC32();
+    mdelay(1000); 
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+
+    // Reset watch dog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x1C70);
+
+    RegSet16BitValue(0x3CE4, 0xE38F);  // for all-blocks
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    for (i = 0; i < 33; i ++) // total  33 KB : 2 byte per R/W
+    {
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG("nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG("((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG("Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]);
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(szFwData[i][j], nCrcInfo);
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    // Write file done
+    RegSet16BitValue(0x3CE4, 0x1380);
+
+    mdelay(10); 
+    // Polling 0x3CE4 is 0x9432
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x9432);
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    // CRC Main from TP
+    nCrcMainTp = RegGet16BitValue(0x3C80);
+    nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+ 
+    // CRC Info from TP
+    nCrcInfoTp = RegGet16BitValue(0x3CA0);
+    nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+
+    DBG("nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n",
+               nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+    {
+        DBG("Update FAILED\n");
+
+        return -1;
+    }
+
+    DBG("Update SUCCESS\n");
+
+    return 0;
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareC33(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u8 szLifeCounter[2];
+    u32 i, j;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u32 nCrcTemp;
+    u16 nRegData = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    _DrvFwCtrlReadInfoC33();
+
+    if (_gDwIicInfoData[0] == 'M' && _gDwIicInfoData[1] == 'S' && _gDwIicInfoData[2] == 'T' && _gDwIicInfoData[3] == 'A' && _gDwIicInfoData[4] == 'R' && _gDwIicInfoData[5] == 'T' && _gDwIicInfoData[6] == 'P' && _gDwIicInfoData[7] == 'C')
+    {
+        _gDwIicInfoData[8] = szFwData[32][8];
+        _gDwIicInfoData[9] = szFwData[32][9];
+        _gDwIicInfoData[10] = szFwData[32][10];
+        _gDwIicInfoData[11] = szFwData[32][11];
+        // updata life counter
+        szLifeCounter[1] = ((((_gDwIicInfoData[13] << 8) | _gDwIicInfoData[12]) + 1) >> 8) & 0xFF;
+        szLifeCounter[0] = (((_gDwIicInfoData[13] << 8) | _gDwIicInfoData[12]) + 1) & 0xFF;
+        _gDwIicInfoData[12] = szLifeCounter[0];
+        _gDwIicInfoData[13] = szLifeCounter[1];
+        
+        RegSet16BitValue(0x3CE4, 0x78C5);
+        RegSet16BitValue(0x1E04, 0x7d60);
+        // TP SW reset
+        RegSet16BitValue(0x1E04, 0x829F);
+
+        mdelay(50);
+
+        // Polling 0x3CE4 is 0x2F43
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x2F43);
+
+        // Transmit lk info data
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[0], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+    }
+
+    // erase main
+    _DrvFwCtrlEraseEmemC33(EMEM_MAIN);
+    mdelay(1000);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x1C70);
+    }
+
+    switch (eEmemType)
+    {
+        case EMEM_ALL:
+            RegSet16BitValue(0x3CE4, 0xE38F);  // for all blocks
+            break;
+        case EMEM_MAIN:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for main block
+            break;
+        case EMEM_INFO:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for info block
+
+            RegSetLByteValue(0x0FE6, 0x01);
+
+            RegSetLByteValue(0x3CE4, 0xC5); 
+            RegSetLByteValue(0x3CE5, 0x78); 
+
+            RegSetLByteValue(0x1E04, 0x9F);
+            RegSetLByteValue(0x1E05, 0x82);
+
+            RegSetLByteValue(0x0FE6, 0x00);
+            mdelay(100);
+            break;
+    }
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    for (i = 0; i < 33; i ++) // total 33 KB : 2 byte per R/W
+    {
+        if (eEmemType == EMEM_INFO)
+        {
+            i = 32;
+        }
+
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG("nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG("((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG("Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]); // add for debug
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(_gDwIicInfoData[j], nCrcInfo);
+            }
+            
+            if (eEmemType == EMEM_MAIN)
+            {
+                break;
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // write file done and check crc
+        RegSet16BitValue(0x3CE4, 0x1380);
+    }
+    mdelay(10);
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // Polling 0x3CE4 is 0x9432
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x9432);
+    }
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // CRC Main from TP
+        nCrcMainTp = RegGet16BitValue(0x3C80);
+        nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+
+        // CRC Info from TP
+        nCrcInfoTp = RegGet16BitValue(0x3CA0);
+        nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+    }
+    DBG("nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n", nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+        {
+            DBG("Update FAILED\n");
+
+            return -1;
+        }
+    }
+    
+    DBG("Update SUCCESS\n");
+
+    return 0;
+}
+
+static s32 _DrvFwCtrlMsg22xxUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u32 i, index;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u32 nRemainSize, nBlockSize, nSize;
+    u16 nRegData = 0;
+    u8 szDbBusTxData[1024] = {0};
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u32 nSizePerWrite = 125;
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    u32 nSizePerWrite = 1021;
+#endif
+
+    DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(szFwData, _gOneDimenFwData);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    
+    DBG("Erase start\n");
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    if (eEmemType == EMEM_ALL) // 48KB + 512Byte
+    {
+        DBG("Erase all block\n");
+
+        // Clear pce
+        RegSetLByteValue(0x1618, 0x80);
+        mdelay(100);
+
+        // Chip erase
+        RegSet16BitValue(0x160E, BIT3);
+
+        DBG("Wait erase done flag\n");
+
+        do // Wait erase done flag
+        {
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            mdelay(50);
+        } while((nRegData & BIT1) != BIT1);
+    }
+    else if (eEmemType == EMEM_MAIN) // 48KB (32+8+8)
+    {
+        DBG("Erase main block\n");
+
+        for (i = 0; i < 3; i ++)
+        {
+            // Clear pce
+            RegSetLByteValue(0x1618, 0x80);
+            mdelay(10);
+
+            if (i == 0)
+            {
+                RegSet16BitValue(0x1600, 0x0000);
+            }
+            else if (i == 1)
+            {
+                RegSet16BitValue(0x1600, 0x8000);
+            }
+            else if (i == 2)
+            {
+                RegSet16BitValue(0x1600, 0xA000);
+            }
+
+            // Sector erase
+            RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+            DBG("Wait erase done flag\n");
+
+            do // Wait erase done flag
+            {
+                nRegData = RegGet16BitValue(0x1610); // Memory status
+                mdelay(50);
+            } while((nRegData & BIT1) != BIT1);
+        }   
+    }
+    else if (eEmemType == EMEM_INFO) // 512Byte
+    {
+        DBG("Erase info block\n");
+
+        // Clear pce
+        RegSetLByteValue(0x1618, 0x80);
+        mdelay(10);
+
+        RegSet16BitValue(0x1600, 0xC000);
+        
+        // Sector erase
+        RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+        DBG("Wait erase done flag\n");
+
+        do // Wait erase done flag
+        {
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            mdelay(50);
+        } while((nRegData & BIT1) != BIT1);
+    }
+    
+    DBG("Erase end\n");
+    
+    // Hold reset pin before program
+    RegSetLByteValue(0x1E06, 0x00);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_MAIN) // 48KB
+    {
+        DBG("Program main block start\n");
+		
+        // Program main block
+        RegSet16BitValue(0x161A, 0xABBA);
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+		
+        RegSet16BitValue(0x1600, 0x0000); // Set start address of main block
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+		
+        // Program start
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+		
+        szDbBusTxData[0] = 0x20;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+		
+        nRemainSize = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024; //48KB
+        index = 0;
+		    
+        while (nRemainSize > 0)
+        {
+            if (nRemainSize > nSizePerWrite)
+            {
+                nBlockSize = nSizePerWrite;
+            }
+            else
+            {
+                nBlockSize = nRemainSize;
+            }
+		
+            szDbBusTxData[0] = 0x10;
+            szDbBusTxData[1] = 0x16;
+            szDbBusTxData[2] = 0x02;
+		
+            nSize = 3;
+		
+            for (i = 0; i < nBlockSize; i ++)
+            {
+                szDbBusTxData[3+i] = _gOneDimenFwData[index*nSizePerWrite+i];
+                nSize ++; 
+            }
+            index ++;
+		
+            IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+		        
+            nRemainSize = nRemainSize - nBlockSize;
+        }
+		
+        // Program end
+        szDbBusTxData[0] = 0x21;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+		
+        nRegData = RegGet16BitValue(0x160C); 
+        RegSet16BitValue(0x160C, nRegData & (~0x01));      
+		
+        DBG("Wait main block write done flag\n");
+		
+        // Polling 0x1610 is 0x0002
+        do
+        {
+            nRegData = RegGet16BitValue(0x1610);
+            nRegData = nRegData & BIT1;
+            mdelay(10);
+		
+        } while (nRegData != BIT1); // Wait write done flag
+		
+        DBG("Program main block end\n");
+    }
+    
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_INFO) // 512 Byte
+    {
+        DBG("Program info block start\n");
+
+        // Program info block
+        RegSet16BitValue(0x161A, 0xABBA);
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xC000); // Set start address of info block
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+
+        // Program start
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+
+        szDbBusTxData[0] = 0x20;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+        nRemainSize = MSG22XX_FIRMWARE_INFO_BLOCK_SIZE; //512Byte
+        index = 0;
+    
+        while (nRemainSize > 0)
+        {
+            if (nRemainSize > nSizePerWrite)
+            {
+                nBlockSize = nSizePerWrite;
+            }
+            else
+            {
+                nBlockSize = nRemainSize;
+            }
+
+            szDbBusTxData[0] = 0x10;
+            szDbBusTxData[1] = 0x16;
+            szDbBusTxData[2] = 0x02;
+
+            nSize = 3;
+
+            for (i = 0; i < nBlockSize; i ++)
+            {
+                szDbBusTxData[3+i] = _gOneDimenFwData[(MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024)+(index*nSizePerWrite)+i];
+                nSize ++; 
+            }
+            index ++;
+
+            IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+        
+            nRemainSize = nRemainSize - nBlockSize;
+        }
+
+        // Program end
+        szDbBusTxData[0] = 0x21;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+        nRegData = RegGet16BitValue(0x160C); 
+        RegSet16BitValue(0x160C, nRegData & (~0x01));      
+
+        DBG("Wait info block write done flag\n");
+
+        // Polling 0x1610 is 0x0002
+        do
+        {
+            nRegData = RegGet16BitValue(0x1610);
+            nRegData = nRegData & BIT1;
+            mdelay(10);
+
+        } while (nRegData != BIT1); // Wait write done flag
+
+        DBG("Program info block end\n");
+    }
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_MAIN)
+    {
+        // Get CRC 32 from updated firmware bin file
+        nCrcMain  = _gOneDimenFwData[0xBFFF] << 24;
+        nCrcMain |= _gOneDimenFwData[0xBFFE] << 16;
+        nCrcMain |= _gOneDimenFwData[0xBFFD] << 8;
+        nCrcMain |= _gOneDimenFwData[0xBFFC];
+
+        // CRC Main from TP
+        DBG("Get Main CRC from TP\n");
+
+        nCrcMainTp = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+    
+        DBG("nCrcMain=0x%x, nCrcMainTp=0x%x\n", nCrcMain, nCrcMainTp);
+    }
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_INFO)
+    {
+        nCrcInfo  = _gOneDimenFwData[0xC1FF] << 24;
+        nCrcInfo |= _gOneDimenFwData[0xC1FE] << 16;
+        nCrcInfo |= _gOneDimenFwData[0xC1FD] << 8;
+        nCrcInfo |= _gOneDimenFwData[0xC1FC];
+
+        // CRC Info from TP
+        DBG("Get Info CRC from TP\n");
+
+        nCrcInfoTp = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+        DBG("nCrcInfo=0x%x, nCrcInfoTp=0x%x\n", nCrcInfo, nCrcInfoTp);
+    }
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if (eEmemType == EMEM_ALL)
+    {
+        if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+        {
+            DBG("Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        if (nCrcMainTp != nCrcMain)
+        {
+            DBG("Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        if (nCrcInfoTp != nCrcInfo)
+        {
+            DBG("Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    
+    DBG("Update SUCCESS\n");
+
+    return 0;
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareCash(u8 szFwData[][1024])
+{
+    DBG("*** %s() ***\n", __func__);
+
+    DBG("chip type = 0x%x\n", g_ChipType);
+    
+    if (g_ChipType == CHIP_TYPE_MSG21XXA) // (0x02)
+    {
+//        u16 nChipType;
+        u8 nChipVersion = 0;
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        // Erase TP Flash first
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        mdelay(300);
+    
+        // Stop MCU
+        RegSetLByteValue(0x0FE6, 0x01);
+
+        // Disable watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+    
+        /////////////////////////
+        // Difference between C2 and C3
+        /////////////////////////
+        // c2:MSG2133(1) c32:MSG2133A(2) c33:MSG2138A(2)
+        // check ic type
+//        nChipType = RegGet16BitValue(0x1ECC) & 0xFF;
+            
+        // check ic version
+        nChipVersion = RegGet16BitValue(0x3CEA) & 0xFF;
+
+        DBG("chip version = 0x%x\n", nChipVersion);
+
+        if (nChipVersion == 3)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+            return _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(szFwData, EMEM_MAIN);
+#else
+            return _DrvFwCtrlUpdateFirmwareC33(szFwData, EMEM_MAIN);
+#endif        
+        }
+        else
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+            return _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(szFwData, EMEM_MAIN);
+#else
+            return _DrvFwCtrlUpdateFirmwareC32(szFwData, EMEM_ALL);
+#endif        
+        }
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX) // (0x7A)
+    {
+//        _DrvFwCtrlMsg22xxGetTpVendorCode(_gTpVendorCode);
+        
+//        if (_gTpVendorCode[0] == 'C' && _gTpVendorCode[1] == 'N' && _gTpVendorCode[2] == 'T') // for specific TP vendor which store some important information in info block, only update firmware for main block, do not update firmware for info block.
+//        {
+//            return _DrvFwCtrlMsg22xxUpdateFirmware(szFwData, EMEM_MAIN);
+//        }
+//        else
+//        {
+            return _DrvFwCtrlMsg22xxUpdateFirmware(szFwData, EMEM_ALL);
+//        }
+    }
+    else // CHIP_TYPE_MSG21XX (0x01)
+    {
+        DBG("Can not update firmware. Catch-2 is no need to be maintained now.\n");
+        g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+        return -1;
+    }
+}
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+u8 DrvFwCtrlGetChipType(void)
+{
+    u8 nChipType = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    // Erase TP Flash first
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01);
+
+    // Disable watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+    
+    /////////////////////////
+    // Difference between C2 and C3
+    /////////////////////////
+    // c2:MSG2133(1) c32:MSG2133A(2) c33:MSG2138A(2)
+    // check ic type
+    nChipType = RegGet16BitValue(0x1ECC) & 0xFF;
+
+    if (nChipType != CHIP_TYPE_MSG21XX &&   // (0x01) 
+        nChipType != CHIP_TYPE_MSG21XXA &&  // (0x02) 
+        nChipType != CHIP_TYPE_MSG26XXM &&  // (0x03) 
+        nChipType != CHIP_TYPE_MSG22XX)     // (0x7A) 
+    {
+        nChipType = 0;
+    }
+
+    DBG("*** Chip Type = 0x%x ***\n", nChipType);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    return nChipType;
+}
+
+void DrvFwCtrlGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG21XX)
+    {
+        u8 szDbBusTxData[3] = {0};
+        u8 szDbBusRxData[4] = {0};
+
+        szDbBusTxData[0] = 0x53;
+        szDbBusTxData[1] = 0x00;
+
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {    
+            szDbBusTxData[2] = 0x2A;
+        }
+        else if (g_ChipType == CHIP_TYPE_MSG21XX)
+        {
+            szDbBusTxData[2] = 0x74;
+        }
+        else
+        {
+            szDbBusTxData[2] = 0x2A;
+        }
+
+        mutex_lock(&g_Mutex);
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+        mutex_unlock(&g_Mutex);
+
+        *pMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+        *pMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        u16 nRegData1, nRegData2;
+
+        mutex_lock(&g_Mutex);
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        mdelay(100);
+        
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        // Clear pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xBFF4); // Set start address for customer firmware version on main block
+    
+        // Enable burst mode
+//        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        // Set pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+        RegSetLByteValue(0x160E, 0x01); 
+
+        nRegData1 = RegGet16BitValue(0x1604);
+        nRegData2 = RegGet16BitValue(0x1606);
+
+        *pMajor = (((nRegData1 >> 8) & 0xFF) << 8) + (nRegData1 & 0xFF);
+        *pMinor = (((nRegData2 >> 8) & 0xFF) << 8) + (nRegData2 & 0xFF);
+
+        // Clear burst mode
+//        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+        mdelay(100);
+
+        mutex_unlock(&g_Mutex);
+    }
+
+    DBG("*** major = %d ***\n", *pMajor);
+    DBG("*** minor = %d ***\n", *pMinor);
+
+    if (*ppVersion == NULL)
+    {
+        *ppVersion = kzalloc(sizeof(u8)*6, GFP_KERNEL);
+    }
+    
+    sprintf(*ppVersion, "%03d%03d", *pMajor, *pMinor);
+}
+
+void DrvFwCtrlGetPlatformFirmwareVersion(u8 **ppVersion)
+{
+    u32 i;
+    u16 nRegData1, nRegData2;
+    u8 szDbBusRxData[12] = {0};
+
+    DBG("*** %s() ***\n", __func__);
+
+    mutex_lock(&g_Mutex);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX) // Only MSG22XX support platform firmware version
+    {
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        // Clear pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xC1F2); // Set start address for platform firmware version on info block(Actually, start reading from 0xC1F0)
+    
+        // Enable burst mode
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        // Set pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+        for (i = 0; i < 3; i ++)
+        {
+            RegSetLByteValue(0x160E, 0x01); 
+
+            nRegData1 = RegGet16BitValue(0x1604);
+            nRegData2 = RegGet16BitValue(0x1606);
+
+            szDbBusRxData[i*4+0] = (nRegData1 & 0xFF);
+            szDbBusRxData[i*4+1] = ((nRegData1 >> 8 ) & 0xFF);
+            
+//            DBG("szDbBusRxData[%d] = 0x%x , %c \n", i*4+0, szDbBusRxData[i*4+0], szDbBusRxData[i*4+0]); // add for debug
+//            DBG("szDbBusRxData[%d] = 0x%x , %c \n", i*4+1, szDbBusRxData[i*4+1], szDbBusRxData[i*4+1]); // add for debug
+            
+            szDbBusRxData[i*4+2] = (nRegData2 & 0xFF);
+            szDbBusRxData[i*4+3] = ((nRegData2 >> 8 ) & 0xFF);
+
+//            DBG("szDbBusRxData[%d] = 0x%x , %c \n", i*4+2, szDbBusRxData[i*4+2], szDbBusRxData[i*4+2]); // add for debug
+//            DBG("szDbBusRxData[%d] = 0x%x , %c \n", i*4+3, szDbBusRxData[i*4+3], szDbBusRxData[i*4+3]); // add for debug
+        }
+
+        // Clear burst mode
+        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*10, GFP_KERNEL);
+        }
+    
+        sprintf(*ppVersion, "%c%c%c%c%c%c%c%c%c%c", szDbBusRxData[2], szDbBusRxData[3], szDbBusRxData[4],
+            szDbBusRxData[5], szDbBusRxData[6], szDbBusRxData[7], szDbBusRxData[8], szDbBusRxData[9], szDbBusRxData[10], szDbBusRxData[11]);
+    }
+    else
+    {
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*10, GFP_KERNEL);
+        }
+    
+        sprintf(*ppVersion, "%s", "N/A");
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(100);
+
+    mutex_unlock(&g_Mutex);
+    
+    DBG("*** platform firmware version = %s ***\n", *ppVersion);
+}
+
+s32 DrvFwCtrlUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return _DrvFwCtrlUpdateFirmwareCash(szFwData);
+}	
+
+void DrvFwCtrlHandleFingerTouch(void)
+{
+    TouchInfo_t tInfo;
+    u32 i;
+    u8 nTouchKeyCode = 0;
+    static u32 nLastKeyCode = 0;
+    u8 *pPacket = NULL;
+    u16 nReportPacketLength = 0;
+
+//    DBG("*** %s() ***\n", __func__);
+    
+    memset(&tInfo, 0x0, sizeof(tInfo));
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+    {
+        DBG("FIRMWARE_MODE_DEMO_MODE\n");
+
+        nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+        pPacket = g_DemoModePacket;
+    }
+    else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE)
+    {
+        DBG("FIRMWARE_MODE_DEBUG_MODE\n");
+
+        if (g_FirmwareInfo.nLogModePacketHeader != 0x62)
+        {
+            DBG("WRONG DEBUG MODE HEADER : 0x%x\n", g_FirmwareInfo.nLogModePacketHeader);
+            return;
+        }
+
+        if (g_LogModePacket == NULL)
+        {
+            g_LogModePacket = kzalloc(sizeof(u8)*g_FirmwareInfo.nLogModePacketLength, GFP_KERNEL);
+        }
+        
+        nReportPacketLength = g_FirmwareInfo.nLogModePacketLength;
+        pPacket = g_LogModePacket;
+    }
+    else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE)
+    {
+        DBG("FIRMWARE_MODE_RAW_DATA_MODE\n");
+
+        if (g_FirmwareInfo.nLogModePacketHeader != 0x62)
+        {
+            DBG("WRONG RAW DATA MODE HEADER : 0x%x\n", g_FirmwareInfo.nLogModePacketHeader);
+            return;
+        }
+
+        if (g_LogModePacket == NULL)
+        {
+            g_LogModePacket = kzalloc(sizeof(u8)*g_FirmwareInfo.nLogModePacketLength, GFP_KERNEL);
+        }
+        
+        nReportPacketLength = g_FirmwareInfo.nLogModePacketLength;
+        pPacket = g_LogModePacket;
+    }
+    else
+    {
+        DBG("WRONG FIRMWARE MODE : 0x%x\n", g_FirmwareMode);
+        return;
+    }
+#else
+    DBG("FIRMWARE_MODE_DEMO_MODE\n");
+
+    nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+    pPacket = g_DemoModePacket;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        DBG("Set gesture wakeup packet length, g_ChipType=%d\n", g_ChipType);
+        
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            if (_gGestureWakeupPacket == NULL)
+            {
+                _gGestureWakeupPacket = kzalloc(sizeof(u8)*GESTURE_WAKEUP_PACKET_LENGTH, GFP_KERNEL);
+            }
+
+            nReportPacketLength = GESTURE_WAKEUP_PACKET_LENGTH;
+            pPacket = _gGestureWakeupPacket;
+        } 
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {
+            if (_gGestureWakeupPacket == NULL)
+            {
+                _gGestureWakeupPacket = kzalloc(sizeof(u8)*DEMO_MODE_PACKET_LENGTH, GFP_KERNEL);
+            }
+
+        		nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+            pPacket = _gGestureWakeupPacket;
+        }
+        else
+        {
+            DBG("This chip type does not support gesture wakeup.\n");
+            return;
+        }
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        u32 i = 0, rc;
+        
+        while (i < 5)
+        {
+            mdelay(50);
+
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+            
+            if (rc > 0)
+            {
+                break;
+            }
+            
+            i ++;
+        }
+    }
+    else
+    {
+        IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+    }
+#else
+    IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP   
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+    IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif
+    
+    if (0 == _DrvFwCtrlParsePacket(pPacket, nReportPacketLength, &tInfo))
+    {
+        //report...
+        if ((tInfo.nFingerNum) == 0)   //touch end
+        {
+            if (nLastKeyCode != 0)
+            {
+                DBG("key touch released\n");
+
+                input_report_key(g_InputDevice, BTN_TOUCH, 0);
+                input_report_key(g_InputDevice, nLastKeyCode, 0);
+                    
+                nLastKeyCode = 0; //clear key status..
+            }
+            else
+            {
+                DrvPlatformLyrFingerTouchReleased(0, 0);
+            }
+        }
+        else //touch on screen
+        {
+            if (tInfo.nTouchKeyCode != 0)
+            {
+#ifdef CONFIG_TP_HAVE_KEY
+                if (tInfo.nTouchKeyCode == 4) // TOUCH_KEY_HOME
+                {
+                    nTouchKeyCode = g_TpVirtualKey[1];           
+                }
+                else if (tInfo.nTouchKeyCode == 1) // TOUCH_KEY_MENU
+                {
+                    nTouchKeyCode = g_TpVirtualKey[0];
+                }           
+                else if (tInfo.nTouchKeyCode == 2) // TOUCH_KEY_BACK
+                {
+                    nTouchKeyCode = g_TpVirtualKey[2];
+                }           
+                else if (tInfo.nTouchKeyCode == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    nTouchKeyCode = g_TpVirtualKey[3];           
+                }
+
+                if (nLastKeyCode != nTouchKeyCode)
+                {
+                    DBG("key touch pressed\n");
+                    DBG("nTouchKeyCode = %d, nLastKeyCode = %d\n", nTouchKeyCode, nLastKeyCode);
+                    
+                    nLastKeyCode = nTouchKeyCode;
+
+                    input_report_key(g_InputDevice, BTN_TOUCH, 1);
+                    input_report_key(g_InputDevice, nTouchKeyCode, 1);
+                }
+#endif //CONFIG_TP_HAVE_KEY
+            }
+            else
+            {
+                DBG("tInfo->nFingerNum = %d...............\n", tInfo.nFingerNum);
+                
+                for (i = 0; i < tInfo.nFingerNum; i ++) 
+                {
+                    DrvPlatformLyrFingerTouchPressed(tInfo.tPoint[i].nX, tInfo.tPoint[i].nY, 0, 0);
+                }
+            }
+        }
+        
+        input_sync(g_InputDevice);
+    }
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+void DrvFwCtrlOpenGestureWakeup(u16 nMode)
+{
+    u8 szDbBusTxData[3] = {0};
+    u32 i = 0;
+    s32 rc;
+
+    DBG("*** %s() ***\n", __func__);
+
+    DBG("wakeup mode = 0x%x\n", nMode);
+
+    szDbBusTxData[0] = 0x58;
+    szDbBusTxData[1] = (nMode >> 8) & 0xFF;
+    szDbBusTxData[2] = nMode & 0xFF;
+
+    while (i < 5)
+    {
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        
+        if (rc > 0)
+        {
+            DBG("Enable gesture wakeup success\n");
+            break;
+        }
+        
+        i ++;
+    }
+    
+    if (i == 5)
+    {
+        DBG("Enable gesture wakeup failed\n");		
+    }
+/*
+    rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+    if (rc < 0)
+    {
+        DBG("Enable gesture wakeup failed\n");
+    }
+    else
+    {
+        DBG("Enable gesture wakeup success\n");
+    }
+*/    
+    g_GestureWakeupFlag = 1; // gesture wakeup is enabled
+}
+
+void DrvFwCtrlCloseGestureWakeup(void)
+{
+//    u8 szDbBusTxData[3] = {0};
+//    s32 rc;
+
+    DBG("*** %s() ***\n", __func__);
+/*   
+    szDbBusTxData[0] = 0x58;
+    szDbBusTxData[1] = 0x00;
+    szDbBusTxData[2] = 0x00;
+
+    rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+    if (rc < 0)
+    {
+        DBG("Disable gesture wakeup failed\n");
+    }
+    else
+    {
+        DBG("Disable gesture wakeup success\n");
+    }
+*/
+    g_GestureWakeupFlag = 0; // gesture wakeup is disabled
+}
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+u16 DrvFwCtrlChangeFirmwareMode(u16 nMode)
+{
+    u8 szDbBusTxData[2] = {0};
+
+    DBG("*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x02;
+    szDbBusTxData[1] = (u8)nMode;
+
+    mdelay(20);
+    
+    mutex_lock(&g_Mutex);
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 2);
+
+    mutex_unlock(&g_Mutex);
+
+    return nMode;
+}
+
+void DrvFwCtrlGetFirmwareInfo(FirmwareInfo_t *pInfo)
+{
+    u8 szDbBusTxData[1] = {0};
+    u8 szDbBusRxData[8] = {0};
+    
+    DBG("*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x01;
+
+    mutex_lock(&g_Mutex);
+    
+    mdelay(300);
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+    mdelay(20);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 8);
+
+    mutex_unlock(&g_Mutex);
+    
+    if ((szDbBusRxData[1] & 0x80) == 0x80)
+    {
+        pInfo->nIsCanChangeFirmwareMode = 0;	
+    }
+    else
+    {
+        pInfo->nIsCanChangeFirmwareMode = 1;	
+    }
+    
+    pInfo->nFirmwareMode = szDbBusRxData[1] & 0x7F;
+    pInfo->nLogModePacketHeader = szDbBusRxData[2];
+    pInfo->nLogModePacketLength = (szDbBusRxData[3]<<8) + szDbBusRxData[4];
+
+    DBG("pInfo->nFirmwareMode=0x%x, pInfo->nLogModePacketHeader=0x%x, pInfo->nLogModePacketLength=%d, pInfo->nIsCanChangeFirmwareMode=%d\n", pInfo->nFirmwareMode, pInfo->nLogModePacketHeader, pInfo->nLogModePacketLength, pInfo->nIsCanChangeFirmwareMode);
+}
+
+void DrvFwCtrlRestoreFirmwareModeToLogDataMode(void)
+{
+    FirmwareInfo_t tInfo;
+    
+    DBG("*** %s() ***\n", __func__);
+
+    memset(&tInfo, 0x0, sizeof(FirmwareInfo_t));
+
+    DrvFwCtrlGetFirmwareInfo(&tInfo);
+
+    DBG("g_FirmwareMode = 0x%x, tInfo.nFirmwareMode = 0x%x\n", g_FirmwareMode, tInfo.nFirmwareMode);
+
+    // Since reset_hw() will reset the firmware mode to demo mode, we must reset the firmware mode again after reset_hw().
+    if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && FIRMWARE_MODE_DEBUG_MODE != tInfo.nFirmwareMode)
+    {
+        g_FirmwareMode = DrvFwCtrlChangeFirmwareMode(FIRMWARE_MODE_DEBUG_MODE);
+    }
+    else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE && FIRMWARE_MODE_RAW_DATA_MODE != tInfo.nFirmwareMode)
+    {
+        g_FirmwareMode = DrvFwCtrlChangeFirmwareMode(FIRMWARE_MODE_RAW_DATA_MODE);
+    }
+    else
+    {
+        DBG("firmware mode is not restored\n");
+    }
+}
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+void DrvFwCtrlCheckFirmwareUpdateBySwId(void)
+{
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+    {
+        _DrvFwCtrlMsg21xxaCheckFirmwareUpdateBySwId();
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)    
+    {
+        _DrvFwCtrlMsg22xxCheckFirmwareUpdateBySwId();
+    }
+    else
+    {
+        DBG("This chip type (%d) does not support update firmware by sw id\n", g_ChipType);
+    }
+}	
+
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_self_fw_control.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_self_fw_control.h
new file mode 100644
index 0000000..d7cd0bf
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_self_fw_control.h
@@ -0,0 +1,154 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_self_fw_control.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_SELF_FW_CONTROL_H__
+#define __MSTAR_DRV_SELF_FW_CONTROL_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* COMPILE OPTION DEFINITION                                                */
+/*--------------------------------------------------------------------------*/
+
+//#define CONFIG_SWAP_X_Y
+
+//#define CONFIG_REVERSE_X
+//#define CONFIG_REVERSE_Y
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define DEMO_MODE_PACKET_LENGTH    (8)
+#define MAX_TOUCH_NUM           (2)     
+
+#define MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE (32) //32K
+#define MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE (1)  //1K
+#define MSG21XXA_FIRMWARE_WHOLE_SIZE (MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE+MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE) //33K
+
+#define MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE (48)  //48K
+#define MSG22XX_FIRMWARE_INFO_BLOCK_SIZE (512) //512Byte
+
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+#define FIRMWARE_MODE_DEMO_MODE      (0x00)
+#define FIRMWARE_MODE_DEBUG_MODE     (0x01)
+#define FIRMWARE_MODE_RAW_DATA_MODE  (0x02)
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+#define UPDATE_FIRMWARE_RETRY_COUNT (2)
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+typedef struct
+{
+    u16 nX;
+    u16 nY;
+} TouchPoint_t;
+
+typedef struct
+{
+    u8 nTouchKeyMode;
+    u8 nTouchKeyCode;
+    u8 nFingerNum;
+    TouchPoint_t tPoint[MAX_TOUCH_NUM];
+} TouchInfo_t;
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+typedef struct
+{
+    u8 nFirmwareMode;
+    u8 nLogModePacketHeader;
+    u16 nLogModePacketLength;
+    u8 nIsCanChangeFirmwareMode;
+} FirmwareInfo_t;
+
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+/*
+ * Note.
+ * The following is sw id enum definition for MSG22XX.
+ * 0x0000 and 0xFFFF are not allowed to be defined as SW ID.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum value depends on the TP vendor that you are using.
+ */
+typedef enum {
+    MSG22XX_SW_ID_XXXX = 0x0001,
+    MSG22XX_SW_ID_YYYY = 0x0002,  
+    MSG22XX_SW_ID_UNDEFINED
+} Msg22xxSwId_e;
+
+
+/*
+ * Note.
+ * The following is sw id enum definition for MSG21XXA.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum value depends on the TP vendor that you are using.
+ */
+typedef enum {
+    MSG21XXA_SW_ID_XXXX = 0,  
+    MSG21XXA_SW_ID_YYYY,
+    MSG21XXA_SW_ID_UNDEFINED
+} Msg21xxaSwId_e;
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern void DrvFwCtrlOpenGestureWakeup(u16 nMode);
+extern void DrvFwCtrlCloseGestureWakeup(void);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern u16 DrvFwCtrlChangeFirmwareMode(u16 nMode);        
+extern void DrvFwCtrlGetFirmwareInfo(FirmwareInfo_t *pInfo);
+extern void DrvFwCtrlRestoreFirmwareModeToLogDataMode(void);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+extern void DrvFwCtrlCheckFirmwareUpdateBySwId(void);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+extern u8 DrvFwCtrlGetChipType(void);
+extern void DrvFwCtrlGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion);
+extern void DrvFwCtrlGetPlatformFirmwareVersion(u8 **ppVersion);
+extern void DrvFwCtrlHandleFingerTouch(void);
+extern s32 DrvFwCtrlUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType);
+        
+#endif  /* __MSTAR_DRV_SELF_FW_CONTROL_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_utility_adaption.c b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_utility_adaption.c
new file mode 100644
index 0000000..a2eea38
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_utility_adaption.c
@@ -0,0 +1,406 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_utility_adaption.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+#include "mstar_drv_utility_adaption.h"
+
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Constant
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Variables
+////////////////////////////////////////////////////////////
+extern struct i2c_client *g_I2cClient;
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Implementation
+////////////////////////////////////////////////////////////
+
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+#include <linux/dma-mapping.h>
+#include <linux/mm_types.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/page.h>
+#include <linux/vmalloc.h>
+
+static unsigned char *I2CDMABuf_va = NULL;
+static volatile unsigned int I2CDMABuf_pa = NULL;
+
+void DmaAlloc(void)
+{
+    if (NULL == I2CDMABuf_va)
+    {
+        I2CDMABuf_va = (u8 *)dma_alloc_coherent(NULL, 4096, &I2CDMABuf_pa, GFP_KERNEL);
+    }
+    
+    if (NULL == I2CDMABuf_va)
+    {
+        DBG("DrvCommonDmaAlloc FAILED!");
+    }
+    else
+    {
+        DBG("DrvCommonDmaAlloc SUCCESS!");
+    }
+}
+
+void DmaFree(void)
+{
+    if (NULL != I2CDMABuf_va)
+    {
+        dma_free_coherent(NULL, 4096, I2CDMABuf_va, I2CDMABuf_pa);
+	      I2CDMABuf_va = NULL;
+	      I2CDMABuf_pa = 0;
+    }
+}
+#endif //CONFIG_ENABLE_DMA_IIC
+
+//------------------------------------------------------------------------------//
+
+u16 RegGet16BitValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+    u8 rx_data[2] = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data[0], 2);
+
+    return (rx_data[1] << 8 | rx_data[0]);
+}
+
+u8 RegGetLByteValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+    u8 rx_data = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data, 1);
+
+    return (rx_data);
+}
+
+u8 RegGetHByteValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, (nAddr & 0xFF) + 1};
+    u8 rx_data = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data, 1);
+
+    return (rx_data);
+}
+
+void RegSet16BitValue(u16 nAddr, u16 nData)
+{
+    u8 tx_data[5] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF, nData & 0xFF, nData >> 8};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 5);
+}
+
+void RegSetLByteValue(u16 nAddr, u8 nData)
+{
+    u8 tx_data[4] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF, nData};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 4);
+}
+
+void RegSetHByteValue(u16 nAddr, u8 nData)
+{
+    u8 tx_data[4] = {0x10, (nAddr >> 8) & 0xFF, (nAddr & 0xFF) + 1, nData};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 4);
+}
+
+void RegSet16BitValueOn(u16 nAddr, u16 nData) //Set bit on nData from 0 to 1
+{
+    u16 rData = RegGet16BitValue(nAddr);
+    rData |= nData;
+    RegSet16BitValue(nAddr, rData);
+}
+
+void RegSet16BitValueOff(u16 nAddr, u16 nData) //Set bit on nData from 1 to 0
+{
+    u16 rData = RegGet16BitValue(nAddr);
+    rData &= (~nData);
+    RegSet16BitValue(nAddr, rData);
+}
+
+void DbBusEnterSerialDebugMode(void)
+{
+    u8 data[5];
+
+    // Enter the Serial Debug Mode
+    data[0] = 0x53;
+    data[1] = 0x45;
+    data[2] = 0x52;
+    data[3] = 0x44;
+    data[4] = 0x42;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 5);
+}
+
+void DbBusExitSerialDebugMode(void)
+{
+    u8 data[1];
+
+    // Exit the Serial Debug Mode
+    data[0] = 0x45;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+    
+    // Delay some interval to guard the next transaction
+//    udelay(200);        // delay about 0.2ms
+}
+
+void DbBusIICUseBus(void)
+{
+    u8 data[1];
+
+    // IIC Use Bus
+    data[0] = 0x35;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusIICNotUseBus(void)
+{
+    u8 data[1];
+
+    // IIC Not Use Bus
+    data[0] = 0x34;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusIICReshape(void)
+{
+    u8 data[1];
+
+    // IIC Re-shape
+    data[0] = 0x71;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusStopMCU(void)
+{
+    u8 data[1];
+
+    // Stop the MCU
+    data[0] = 0x37;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusNotStopMCU(void)
+{
+    u8 data[1];
+
+    // Not Stop the MCU
+    data[0] = 0x36;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+s32 IicWriteData(u8 nSlaveId, u8* pBuf, u16 nSize)
+{
+    s32 rc = 0;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    struct i2c_msg msgs[] =
+    {
+        {
+            .addr = nSlaveId,
+            .flags = 0, // if read flag is undefined, then it means write flag.
+            .len = nSize,
+            .buf = pBuf,
+        },
+    };
+
+    /* If everything went ok (i.e. 1 msg transmitted), return #bytes
+       transmitted, else error code. */
+    if (g_I2cClient != NULL)
+    {
+        rc = i2c_transfer(g_I2cClient->adapter, msgs, 1);
+        if (rc < 0)
+        {
+            PRINTF_ERR("IicWriteData() error %d\n", rc);
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (g_I2cClient != NULL)
+    {
+        u8 nAddrBefore = g_I2cClient->addr;
+        g_I2cClient->addr = nSlaveId;
+//        g_I2cClient->addr = (g_I2cClient->addr & I2C_MASK_FLAG ) | (I2C_ENEXT_FLAG);
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+        if (nSize > 8 && NULL != I2CDMABuf_va)
+        {
+            s32 i = 0;
+	          
+            for (i = 0; i < nSize; i ++)
+            {
+                I2CDMABuf_va[i] = pBuf[i];
+            }
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag | I2C_DMA_FLAG;
+            rc = i2c_master_send(g_I2cClient, (unsigned char *)I2CDMABuf_pa, nSize);
+        }
+        else
+        {
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag & (~I2C_DMA_FLAG);	
+            rc = i2c_master_send(g_I2cClient, pBuf, nSize);
+        }
+#else
+        rc = i2c_master_send(g_I2cClient, pBuf, nSize);
+#endif //CONFIG_ENABLE_DMA_IIC
+        g_I2cClient->addr = nAddrBefore;
+
+        if (rc < 0)
+        {
+            PRINTF_ERR("IicWriteData() error %d, nSlaveId=%d, nSize=%d\n", rc, nSlaveId, nSize);
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#endif
+    
+    return rc;
+}
+
+s32 IicReadData(u8 nSlaveId, u8* pBuf, u16 nSize)
+{
+    s32 rc = 0;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    struct i2c_msg msgs[] =
+    {
+        {
+            .addr = nSlaveId,
+            .flags = I2C_M_RD, // read flag
+            .len = nSize,
+            .buf = pBuf,
+        },
+    };
+
+    /* If everything went ok (i.e. 1 msg transmitted), return #bytes
+       transmitted, else error code. */
+    if (g_I2cClient != NULL)
+    {
+        rc = i2c_transfer(g_I2cClient->adapter, msgs, 1);
+        if (rc < 0)
+        {
+            PRINTF_ERR("IicReadData() error %d\n", rc);
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (g_I2cClient != NULL)
+    {
+        u8 nAddrBefore = g_I2cClient->addr;
+        g_I2cClient->addr = nSlaveId;
+//        g_I2cClient->addr = (g_I2cClient->addr & I2C_MASK_FLAG) | (I2C_ENEXT_FLAG);
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+        if (nSize > 8 && NULL != I2CDMABuf_va)
+        {
+            s32 i = 0;
+        
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag | I2C_DMA_FLAG;
+            rc = i2c_master_recv(g_I2cClient, (unsigned char *)I2CDMABuf_pa, nSize);
+        
+            for (i = 0; i < nSize; i ++)
+            {
+                pBuf[i] = I2CDMABuf_va[i];
+            }
+        }
+        else
+        {
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag & (~I2C_DMA_FLAG);	
+            rc = i2c_master_recv(g_I2cClient, pBuf, nSize);
+        }
+#else
+        rc = i2c_master_recv(g_I2cClient, pBuf, nSize);
+#endif //CONFIG_ENABLE_DMA_IIC
+        g_I2cClient->addr = nAddrBefore;
+
+        if (rc < 0)
+        {
+            PRINTF_ERR("IicReadData() error %d, nSlaveId=%d, nSize=%d\n", rc, nSlaveId, nSize);
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#endif
+    
+    return rc;
+}
+
+void mstpMemSet(void *pDst, s8 nVal, u32 nSize)
+{
+    memset(pDst, nVal, nSize);
+}
+
+void mstpMemCopy(void *pDst, void *pSource, u32 nSize)
+{
+    memcpy(pDst, pSource, nSize);
+}
+
+void mstpDelay(u32 nTime)
+{
+    mdelay(nTime);
+}
+
+//------------------------------------------------------------------------------//
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_utility_adaption.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_utility_adaption.h
new file mode 100644
index 0000000..5e72956
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/mstar_drv_utility_adaption.h
@@ -0,0 +1,101 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_utility_adaption.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_UTILITY_ADAPTION_H__
+#define __MSTAR_DRV_UTILITY_ADAPTION_H__ (1)
+
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+
+#include "mstar_drv_common.h"
+
+////////////////////////////////////////////////////////////
+/// Constant
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Variables
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+#define BK_REG8_WL(addr,val)    ( RegSetLByteValue( addr, val ) )
+#define BK_REG8_WH(addr,val)    ( RegSetHByteValue( addr, val ) )
+#define BK_REG16_W(addr,val)    ( RegSet16BitValue( addr, val ) )
+#define BK_REG8_RL(addr)        ( RegGetLByteValue( addr ) )
+#define BK_REG8_RH(addr)        ( RegGetHByteValue( addr ) )
+#define BK_REG16_R(addr)        ( RegGet16BitValue( addr ) )
+
+#define PRINTF_EMERG(fmt, ...)  printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_ALERT(fmt, ...)  printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_CRIT(fmt, ...)   printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__) 
+#define PRINTF_ERR(fmt, ...)    printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_WARN(fmt, ...)   printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_NOTICE(fmt, ...) printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_INFO(fmt, ...)   printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_DEBUG(fmt, ...)  printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__) 
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+extern void DmaAlloc(void);
+extern void DmaFree(void);
+#endif //CONFIG_ENABLE_DMA_IIC
+extern u16  RegGet16BitValue(u16 nAddr);
+extern u8   RegGetLByteValue(u16 nAddr);
+extern u8   RegGetHByteValue(u16 nAddr);
+extern void RegSet16BitValue(u16 nAddr, u16 nData);
+extern void RegSetLByteValue(u16 nAddr, u8 nData);
+extern void RegSetHByteValue(u16 nAddr, u8 nData);
+extern void RegSet16BitValueOn(u16 nAddr, u16 nData);
+extern void RegSet16BitValueOff(u16 nAddr, u16 nData);
+extern void DbBusEnterSerialDebugMode(void);
+extern void DbBusExitSerialDebugMode(void);
+extern void DbBusIICUseBus(void);
+extern void DbBusIICNotUseBus(void);
+extern void DbBusIICReshape(void);
+extern void DbBusStopMCU(void);
+extern void DbBusNotStopMCU(void);
+extern s32 IicWriteData(u8 nSlaveId, u8* pBuf, u16 nSize);
+extern s32 IicReadData(u8 nSlaveId, u8* pBuf, u16 nSize);
+extern void mstpMemSet(void *pDst, s8 nVal, u32 nSize);
+extern void mstpMemCopy(void *pDst, void *pSource, u32 nSize);
+extern void mstpDelay(u32 nTime);
+
+#endif // __MSTAR_DRV_UTILITY_ADAPTION_H__
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/tpd_custom_ektf2k.h b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/tpd_custom_ektf2k.h
new file mode 100755
index 0000000..00b4cb3
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133_and_ektf2k/tpd_custom_ektf2k.h
@@ -0,0 +1,46 @@
+#ifndef TPD_CUSTOM_EKTF2K_H__
+#define TPD_CUSTOM_EKTF2K_H__
+
+#define ELAN_X_MAX      760 
+#define ELAN_Y_MAX      1280
+
+#define LCM_X_MAX      240 //simple_strtoul(LCM_WIDTH, NULL, 0)
+#define LCM_Y_MAX      320//simple_strtoul(LCM_HEIGHT, NULL, 0)
+
+//Elan Key's define
+#define ELAN_KEY_BACK		0x10
+#define ELAN_KEY_HOME		0x08
+#define ELAN_KEY_MENU		0x04
+#define ELAN_KEY_SEARCH 	0x11
+
+/////////////////////////////////////////////////////////
+#define I2C_NUM 2
+#define TPD_POWER_SOURCE_CUSTOM PMIC_APP_CAP_TOUCH_VDD	
+
+//#define SOFTKEY_AXIS_VER
+//#define ELAN_TEN_FINGERS
+//#define _DMA_MODE_
+
+#define ELAN_BUTTON
+#define LCT_VIRTUAL_KEY
+#define TPD_HAVE_BUTTON
+//#define ELAN_3K_IC_SOLUTION
+
+//#define NON_MTK_MODE	//I2C Support > 8bits Transfer
+
+//#define MTK_ELAN_DEBUG
+
+#ifdef ELAN_TEN_FINGERS
+#define PACKET_SIZE             44            /* support 10 fingers packet */
+#else
+#define PACKET_SIZE             8            	/* support 2 fingers packet  */
+//#define PACKET_SIZE            	18            /* support 5 fingers packet  */
+#endif
+
+#define ELAN_DEBUG
+
+#define TP_PROXIMITY_SENSOR_NEW //tp proximity
+
+#define IAP_PORTION                     //upgrade  FW
+#define ESD_CHECK
+#endif /* TOUCHPANEL_H__ */
-- 
1.9.1

