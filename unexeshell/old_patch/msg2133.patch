diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/msg2133_driver.c b/mediatek/custom/common/kernel/touchpanel/msg2133/msg2133_driver.c
index 1a56921..fadab7b 100755
--- a/mediatek/custom/common/kernel/touchpanel/msg2133/msg2133_driver.c
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/msg2133_driver.c
@@ -1,3 +1,4 @@
+//rework the mstar Touch driver
 #include "tpd.h"
 #include <linux/interrupt.h>
 #include <cust_eint.h>
@@ -8,66 +9,72 @@
 #include <linux/wait.h>
 #include <linux/time.h>
 #include <linux/delay.h>
+#include <linux/workqueue.h>
 
-#include "tpd_custom_msg2133.h"
+//#include <linux/hardware_self_adapt.h>
 
+//#include "tpd_custom_msg2133.h"
+#define MS_TS_MSG21XX_X_MAX 240
+#define MS_TS_MSG21XX_Y_MAX 320
+#define REPORT_PACKET_LENGTH 8
 #include <mach/mt_pm_ldo.h>
 #include <mach/mt_typedefs.h>
 #include <mach/mt_boot.h>
-#include <mach/mt_gpio.h>
 
 #include "cust_gpio_usage.h"
 
-//for dma mode
-#include <linux/dma-mapping.h>
-#include <linux/mm_types.h>
-#include <linux/mm.h>
-#include <asm/uaccess.h>
-#include <asm/page.h>
-#include <linux/vmalloc.h>
-
-
-
-#define __TPD_DEBUG__ 
-
-/*Ctp Power Off In Sleep ? */
-//#define TPD_CLOSE_POWER_IN_SLEEP
-
-/*************************************************************
-**msz xb.pang
-**
-**msg2133,msg2133a,msg2138a Firmware update data transfer select
-**
-**
-** if BB Chip == MT6575,MT7577 , please undef __MSG_DMA_MODE__
-**
-**
-** if BB Chip == MT6589,MT6572 , please define __MSG_DMA_MODE__
-**
-**
-**
-**
-*************************************************************/
-#define __MSG_DMA_MODE__
-
-#ifdef __MSG_DMA_MODE__
-	u8 *g_dma_buff_va = NULL;
-	u8 *g_dma_buff_pa = NULL;
+struct work_struct  fw_update;
+
+/*Open OR Close Debug Info*/
+static int  MSG2133A_debug_mask = 1;
+
+#define MSG2133A_DEBUG(x...) do {\
+    if (MSG2133A_debug_mask) \
+        printk(x);\
+    } while (0)
+module_param_named(MSG2133A_debug, MSG2133A_debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+#define MSG2133A_TAG                  "[MSG2133A]"
+#define MSG2133A_FUN(f)               MSG2133A_DEBUG(KERN_INFO MSG2133A_TAG"%s\n", __FUNCTION__)
+#define MSG2133A_ERR(fmt, args...)    MSG2133A_DEBUG(KERN_ERR  MSG2133A_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
+#define MSG2133A_LOG(fmt, args...)    MSG2133A_DEBUG(KERN_ERR MSG2133A_TAG"%s : "fmt,__FUNCTION__, ##args)
+#define MSG2133A_DBG(fmt, args...)    MSG2133A_DEBUG(KERN_ERR MSG2133A_TAG"%s : "fmt,__FUNCTION__,##args) 
+
+static char touch_info[50] = {0}; 
+#undef TPD_PROXIMITY
+
+#ifdef TPD_PROXIMITY	
+
+#define CTP_PROXIMITY_ESD_MEASURE 
+
+#include <linux/hwmsensor.h>
+#include <linux/hwmsen_dev.h>
+#include <linux/wakelock.h>
+
+#define APS_TAG                  "[ALS/PS] "
+#define APS_FUN(f)               MSG2133A_DEBUG(KERN_INFO APS_TAG"%s\n", __FUNCTION__)
+#define APS_ERR(fmt, args...)    MSG2133A_DEBUG(KERN_ERR  APS_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
+#define APS_LOG(fmt, args...)    MSG2133A_DEBUG(KERN_INFO APS_TAG"%s : "fmt,__FUNCTION__, ##args)
+#define APS_DBG(fmt, args...)    MSG2133A_DEBUG(KERN_DEBUG APS_TAG"%s : "fmt,__FUNCTION__,##args)   
+
+static DEFINE_MUTEX(msg2133_sensor_mutex);
+
+static int g_bPsSensorOpen = 0;
+static int g_nPsSensorDate = 1;
+static int g_bSuspend = 0;
+static struct wake_lock ps_lock;
+
+static int msg2133_enable_ps(int enable);
+static void tpd_initialize_ps_sensor_function();
 #endif
 
  
 extern struct tpd_device *tpd;
 
 /*Use For Get CTP Data By I2C*/ 
-struct i2c_client *msg_i2c_client = NULL;
-
-/*Use For Firmware Update By I2C*/
-//static struct i2c_client     *msg21xx_i2c_client = NULL;
+static struct i2c_client *i2c_client = NULL;
 
-//struct task_struct *thread = NULL;
- 
 static DECLARE_WAIT_QUEUE_HEAD(waiter);
-//static DEFINE_MUTEX(i2c_access);
 
 typedef struct
 {
@@ -92,20 +99,18 @@ static struct work_struct    msg21xx_wq;
 static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
 static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
 #endif
+ 
+static int __devinit tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
+static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info);
+static int __devexit tpd_remove(struct i2c_client *client);
+static int touch_event_handler(void *unused);
+
 
-#if 0
 extern void mt65xx_eint_unmask(unsigned int line);
 extern void mt65xx_eint_mask(unsigned int line);
 extern void mt65xx_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
 extern unsigned int mt65xx_eint_set_sens(unsigned int eint_num, unsigned int sens);
 extern void mt65xx_eint_registration(unsigned int eint_num, unsigned int is_deb_en, unsigned int pol, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-#endif
-
- 
-static int __devinit tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info);
-static int __devexit tpd_remove(struct i2c_client *client);
-static int touch_event_handler(void *unused);
  
 
 static int tpd_flag = 0;
@@ -118,14 +123,14 @@ static int p_point_num = 0;
 #define TPD_OK 0
 
  
- static const struct i2c_device_id msg2133_tpd_id[] = {{"msg2133",0},{}};
+ static const struct i2c_device_id msg2133_tpd_id[] = {{"msg2133a",0},{}};
 
- static struct i2c_board_info __initdata msg2133_i2c_tpd={ I2C_BOARD_INFO("msg2133", (0x26))};
+ static struct i2c_board_info __initdata msg2133_i2c_tpd={ I2C_BOARD_INFO("msg2133a", (0x26))};
  
  
  static struct i2c_driver tpd_i2c_driver = {
   .driver = {
-	 .name = "msg2133",//.name = TPD_DEVICE,
+	 .name = "msg2133a",//.name = TPD_DEVICE,
 //	 .owner = THIS_MODULE,
   },
   .probe = tpd_probe,
@@ -135,792 +140,437 @@ static int p_point_num = 0;
 //  .address_data = &addr_data,
  };
  //start for update firmware //msz   for update firmware 20121126
-#define __FIRMWARE_UPDATE__
-#define MSG2133_UPDATE
+ static void msg2133_reset()
+{
+	MSG2133A_FUN();
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
+	msleep(10);
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+	msleep(300);
+}
 
-//#ifdef MSG2133_UPDATE
+#define __FIRMWARE_UPDATE__
 #ifdef __FIRMWARE_UPDATE__
+//
+typedef enum
+{
+	EMEM_ALL = 0,
+	EMEM_MAIN,
+	EMEM_INFO,
+} EMEM_TYPE_t;
 
-#define MSG2133_TS_ADDR			0x26
-#define MSG2133_FW_ADDR			0x62
-#define MSG2133_FW_UPDATE_ADDR   	0x49
+//Macro
+#define	CTP_ID_MSG21XX		1
+#define	CTP_ID_MSG21XXA		2
 
-static struct i2c_client     *this_client = NULL;
-struct class *firmware_class;
-struct device *firmware_cmd_dev;
-static int update_switch = 0;
-static int FwDataCnt;
-static  char *fw_version;
-static unsigned char temp[94][1024];
-static u8 g_dwiic_info_data[1024];   // Buffer for info data
+//Verity
+static u8 curr_ic_type=CTP_ID_MSG21XXA;
+static unsigned short curr_ic_major=0;
+static unsigned short curr_ic_minor=0;
 
-#ifdef __MSG_DMA_MODE__
-static void msg_dma_alloct()
-{
-	g_dma_buff_va = (u8 *)dma_alloc_coherent(NULL, 4096, &g_dma_buff_pa, GFP_KERNEL);
-    if(!g_dma_buff_va)
-	{
-        TPD_DMESG("[DMA][Error] Allocate DMA I2C Buffer failed!\n");
-    }
-}
+typedef enum {
+    SWID_OFILM=0,  
+    SWID_EELY,
+    SWID_TRULY, 
+    SWID_NULL,
+} SWID_ENUM;
 
-static void msg_dma_release()
-{
-	if(g_dma_buff_va)
-	{
-     	dma_free_coherent(NULL, 4096, g_dma_buff_va, g_dma_buff_pa);
-        g_dma_buff_va = NULL;
-        g_dma_buff_pa = NULL;
-		TPD_DMESG("[DMA][release] Allocate DMA I2C Buffer release!\n");
-    }
-}
-#endif
 
+#define ENABLE_AUTO_UPDATA
 
-static void msg2133_device_power_on()
-{
-	#ifdef TPD_POWER_SOURCE_CUSTOM
-	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
-#else
-	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-#endif
-	TPD_DMESG("msg2133: power on\n");
-}
 
-static void msg2133_reset()
-{
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(10);
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(50);
-	TPD_DMESG(" msg2133 reset\n");
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(150);
+#define CTP_AUTHORITY 0664
 
-}
 
 
-/*static bool msg2133_i2c_read(char *pbt_buf, int dw_lenth)
-{
-    int ret;
-    MSG2133_DBG("The msg_i2c_client->addr=0x%x\n",i2c_client->addr);
-    ret = i2c_master_recv(this_client, pbt_buf, dw_lenth);
+static  char *fw_version;
+static u8 temp[94][1024];
+static int FwDataCnt;
+struct class *firmware_class;
+struct device *firmware_cmd_dev;
 
-    if(ret <= 0){
-        MSG2133_DBG("msg_i2c_read_interface error\n");
-        return false;
-    }
+#define N_BYTE_PER_TIME (8)
+#define UPDATE_TIMES (1024/N_BYTE_PER_TIME)
 
-    return true;
-}
+#if 0
+#define FW_ADDR_MSG21XX   (0xC4)
+#define FW_ADDR_MSG21XX_TP   (0x4C)
+#define FW_UPDATE_ADDR_MSG21XX   (0x92)
+#else
+#define FW_ADDR_MSG21XX   (0xC4>>1)
+#define FW_ADDR_MSG21XX_TP   (0x4C>>1)
+#define FW_UPDATE_ADDR_MSG21XX   (0x92>>1)
+#endif
 
-static bool msg2133_i2c_write(char *pbt_buf, int dw_lenth)
-{
-    int ret;
-    MSG2133_DBG("The msg_i2c_client->addr=0x%x\n",i2c_client->addr);
-    ret = i2c_master_send(this_client, pbt_buf, dw_lenth);
 
-    if(ret <= 0){
-        MSG2133_DBG("msg_i2c_read_interface error\n");
-        return false;
-    }
 
-    return true;
-}*/
 
-static void HalTscrCReadI2CSeq(u8 addr, u8* read_data, u16 size)
+//Function
+static void HalDisableIrq(void)
 {
-   //according to your platform.
-   	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = I2C_M_RD,
-			.len = size,
-			#ifdef __MSG_DMA_MODE__
-			.addr = addr & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = addr,
-			.buf = read_data,
-			#endif
-		},
-	};
-
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("HalTscrCReadI2CSeq error %d\n", rc);
-	}
-	#ifdef __MSG_DMA_MODE__
-	else
-	{
-		memcpy(read_data, g_dma_buff_va, size);
-	}
-	#endif
-	
+	mt65xx_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
 }
-
-static void HalTscrCDevWriteI2CSeq(u8 addr, u8* data, u16 size)
+/*enable irq*/
+static void HalEnableIrq(void)
 {
-    //according to your platform.
-   	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	memcpy(g_dma_buff_va, data, size);
-	#endif
-	
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = 0,
-			.len = size,
-			#ifdef __MSG_DMA_MODE__
-			.addr = addr & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = addr,
-			.buf = data,
-			#endif
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("HalTscrCDevWriteI2CSeq error %d,addr = %d\n", rc,addr);
-	}
+	mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
 }
-/*
-static bool msg2133_i2c_read(char *pbt_buf, int dw_lenth)
+/*reset the chip*/
+static void _HalTscrHWReset(void)
 {
+	msg2133_reset();
+}
+static void HalTscrCReadI2CSeq(u8 addr, u8* read_data, u16 size)
+{  
     int ret;
-    //    pr_ch("The msg_i2c_client->addr=0x%x\n",i2c_client->addr);
-    ret = i2c_master_recv(this_client, pbt_buf, dw_lenth);
-
+    i2c_client->addr = addr;
+    ret = i2c_master_recv(i2c_client, read_data, size);
+    i2c_client->addr = FW_ADDR_MSG21XX_TP;
+    
     if(ret <= 0)
     {
-        //pr_tp("msg_i2c_read_interface error\n");
-        return false;
-    }
-
-    return true;
+		MSG2133A_ERR("HalTscrCReadI2CSeq error %d,addr = %x,size=%d\n", ret,addr,size);
+	}
 }
 
-static bool msg2133_i2c_write(char *pbt_buf, int dw_lenth)
+static void HalTscrCDevWriteI2CSeq(u8 addr, u8* data, u16 size)
 {
     int ret;
-    //    pr_ch("The msg_i2c_client->addr=0x%x\n",i2c_client->addr);
-    ret = i2c_master_send(this_client, pbt_buf, dw_lenth);
+    i2c_client->addr = addr;
+    ret = i2c_master_send(i2c_client, data, size);
+    i2c_client->addr = FW_ADDR_MSG21XX_TP;
 
     if(ret <= 0)
     {
-        //pr_tp("msg_i2c_read_interface error\n");
-        return false;
-    }
-
-    return true;
-}
-*/
-static void i2c_read_msg2133(unsigned char *pbt_buf, int dw_lenth)
-{
-    //this_client->addr = MSG2133_FW_ADDR;
-	//i2c_master_recv(this_client, pbt_buf, dw_lenth);	//0xC5_8bit
-	//this_client->addr = MSG2133_TS_ADDR;
-	   	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			.flags = I2C_M_RD,
-			.len = dw_lenth,
-		#ifdef __MSG_DMA_MODE__
-			.addr = MSG2133_FW_ADDR & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-		#else
-			.addr = MSG2133_FW_ADDR,
-			.buf = pbt_buf,
-		#endif
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("i2c_read_msg2133 error %d,addr = %d\n", rc,MSG2133_FW_ADDR);
-	}
-	#ifdef __MSG_DMA_MODE__
-	else
-	{
-		memcpy(pbt_buf, g_dma_buff_va, dw_lenth);
+		MSG2133A_ERR("HalTscrCDevWriteI2CSeq error %d,addr = %x,data[0]=%x,size=%d\n", ret,addr,data[0],size);
 	}
-	#endif
-	
 }
 
-static void i2c_write_msg2133(unsigned char *pbt_buf, int dw_lenth)
+static void dbbusDWIICEnterSerialDebugMode(void)
 {
+    u8 data[5];
 
-	//this_client->addr = MSG2133_FW_ADDR;
-	//i2c_master_send(this_client, pbt_buf, dw_lenth);		//0xC4_8bit
-	//this_client->addr = MSG2133_TS_ADDR;
-	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	memcpy(g_dma_buff_va, pbt_buf, dw_lenth);
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = 0,
-			.len = dw_lenth,
-			#ifdef __MSG_DMA_MODE__
-			.addr = MSG2133_FW_ADDR & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = MSG2133_FW_ADDR,
-			.buf = pbt_buf,
-			#endif
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("i2c_write_msg2133 error %d,addr = %d\n", rc,MSG2133_FW_ADDR);
-	}
-}
-
-static void i2c_read_update_msg2133(unsigned char *pbt_buf, int dw_lenth)
-{	
-
-	//this_client->addr = MSG2133_FW_UPDATE_ADDR;
-	//i2c_master_recv(this_client, pbt_buf, dw_lenth);	//0x93_8bit
-	//this_client->addr = MSG2133_TS_ADDR;
-	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = I2C_M_RD,
-			.len = dw_lenth,
-			#ifdef __MSG_DMA_MODE__
-			.addr = MSG2133_FW_UPDATE_ADDR & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = MSG2133_FW_UPDATE_ADDR,
-			.buf = pbt_buf,
-			#endif
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("i2c_read_update_msg2133 error %d,addr = %d\n", rc,MSG2133_FW_ADDR);
-	}
-	#ifdef __MSG_DMA_MODE__
-	else
-	{
-		memcpy(pbt_buf, g_dma_buff_va, dw_lenth);
-	}
-	#endif
-}
-
-static void i2c_write_update_msg2133(unsigned char *pbt_buf, int dw_lenth)
-{	
-  //  this_client->addr = MSG2133_FW_UPDATE_ADDR;
-	//i2c_master_send(this_client, pbt_buf, dw_lenth);	//0x92_8bit
-	//this_client->addr = MSG2133_TS_ADDR;
-		//this_client->addr = MSG2133_TS_ADDR;
-	int rc;
-  	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	memcpy(g_dma_buff_va, pbt_buf, dw_lenth);
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = 0,
-			.len = dw_lenth,
-			#ifdef __MSG_DMA_MODE__
-			.addr = MSG2133_FW_UPDATE_ADDR & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = MSG2133_FW_UPDATE_ADDR,
-			.buf = pbt_buf,
-			#endif
-			
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("i2c_write_update_msg2133 error %d,addr = %d\n", rc,MSG2133_FW_ADDR);
-	}
-}
-
-
-
-void dbbusDWIICEnterSerialDebugMode(void)
-{
-    unsigned char data[5];
     // Enter the Serial Debug Mode
     data[0] = 0x53;
     data[1] = 0x45;
     data[2] = 0x52;
     data[3] = 0x44;
     data[4] = 0x42;
-    i2c_write_msg2133(data, 5);
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX, data, 5);
 }
 
-void dbbusDWIICStopMCU(void)
+static void dbbusDWIICStopMCU(void)
 {
-    unsigned char data[1];
+    u8 data[1];
+
     // Stop the MCU
     data[0] = 0x37;
-    i2c_write_msg2133(data, 1);
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX, data, 1);
 }
 
-void dbbusDWIICIICUseBus(void)
+static void dbbusDWIICIICUseBus(void)
 {
-    unsigned char data[1];
+    u8 data[1];
+
     // IIC Use Bus
     data[0] = 0x35;
-    i2c_write_msg2133(data, 1);
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX, data, 1);
 }
 
-void dbbusDWIICIICReshape(void)
+static void dbbusDWIICIICReshape(void)
 {
-    unsigned char data[1];
+    u8 data[1];
+
     // IIC Re-shape
     data[0] = 0x71;
-    i2c_write_msg2133(data, 1);
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX, data, 1);
 }
 
-void dbbusDWIICIICNotUseBus(void)
+static void dbbusDWIICIICNotUseBus(void)
 {
-    unsigned char data[1];
+    u8 data[1];
+
     // IIC Not Use Bus
     data[0] = 0x34;
-    i2c_write_msg2133(data, 1);
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX, data, 1);
 }
 
-void dbbusDWIICNotStopMCU(void)
+static void dbbusDWIICNotStopMCU(void)
 {
-    unsigned char data[1];
+    u8 data[1];
+
     // Not Stop the MCU
     data[0] = 0x36;
-    i2c_write_msg2133(data, 1);
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX, data, 1);
 }
 
-void dbbusDWIICExitSerialDebugMode(void)
+static void dbbusDWIICExitSerialDebugMode(void)
 {
-    unsigned char data[1];
+    u8 data[1];
+
     // Exit the Serial Debug Mode
     data[0] = 0x45;
-    i2c_write_msg2133(data, 1);
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX, data, 1);
+
     // Delay some interval to guard the next transaction
+    udelay ( 150);//200 );        // delay about 0.2ms
 }
 
-void drvISP_EntryIspMode(void)
+static void drvISP_EntryIspMode(void)
 {
-    unsigned char bWriteData[5] =
+    u8 bWriteData[5] =
     {
         0x4D, 0x53, 0x54, 0x41, 0x52
     };
-    i2c_write_update_msg2133(bWriteData, 5);
-    msleep(10);           // delay about 10ms
+    MSG2133A_FUN();
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, bWriteData, 5);
+    udelay ( 150 );//200 );        // delay about 0.1ms
 }
 
-void drvISP_WriteEnable(void)
+static u8 drvISP_Read(u8 n, u8* pDataToRead)    //First it needs send 0x11 to notify we want to get flash data back.
 {
-    unsigned char bWriteData[2] =
+    u8 Read_cmd = 0x11;
+    unsigned char dbbus_rx_data[2] = {0};
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &Read_cmd, 1);
+    //msctpc_LoopDelay ( 1 );        // delay about 100us*****
+    udelay( 800 );//200);
+    if (n == 1)
     {
-        0x10, 0x06
-    };
-    unsigned char bWriteData1 = 0x12;
-    i2c_write_update_msg2133(bWriteData, 2);
-    i2c_write_update_msg2133(&bWriteData1, 1);
+        HalTscrCReadI2CSeq(FW_UPDATE_ADDR_MSG21XX, &dbbus_rx_data[0], 2);
+        *pDataToRead = dbbus_rx_data[0];
+        MSG2133A_LOG("dbbus=%d,%d===drvISP_Read=====\n",dbbus_rx_data[0],dbbus_rx_data[1]);
+  	}
+    else
+    {
+        HalTscrCReadI2CSeq(FW_UPDATE_ADDR_MSG21XX, pDataToRead, n);
+    }
+
+    return 0;
 }
 
-unsigned char drvISP_Read(unsigned char n, unsigned char *pDataToRead)    //First it needs send 0x11 to notify we want to get flash data back.
+static void drvISP_WriteEnable(void)
 {
-    unsigned char Read_cmd = 0x11;
-    unsigned char i = 0;
-    unsigned char dbbus_rx_data[16] = {0};
-    i2c_write_update_msg2133(&Read_cmd, 1);
-    //if (n == 1)
+    u8 bWriteData[2] =
     {
-        i2c_read_update_msg2133(&dbbus_rx_data[0], n + 1);
+        0x10, 0x06
+    };
+    u8 bWriteData1 = 0x12;
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, bWriteData, 2);
+    udelay(150);//1.16
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1);
+}
 
-        for(i = 0; i < n; i++)
-        {
-            *(pDataToRead + i) = dbbus_rx_data[i + 1];
-        }
-    }
-    //else
-    {
-        //     i2c_read_update_msg2133(pDataToRead, n);
-    }
-    return 0;
+
+static void drvISP_ExitIspMode(void)
+{
+    u8 bWriteData = 0x24;
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData, 1);
+    udelay( 150 );//200);
 }
 
-unsigned char drvISP_ReadStatus(void)
+static u8 drvISP_ReadStatus(void)
 {
-    unsigned char bReadData = 0;
-    unsigned char bWriteData[2] =
+    u8 bReadData = 0;
+    u8 bWriteData[2] =
     {
         0x10, 0x05
     };
-    unsigned char bWriteData1 = 0x12;
-//    msleep(1);           // delay about 100us
-    i2c_write_update_msg2133(bWriteData, 2);
-//    msleep(1);           // delay about 100us
+    u8 bWriteData1 = 0x12;
+
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, bWriteData, 2);
+    //msctpc_LoopDelay ( 1 );        // delay about 100us*****
+    udelay(150);//200);
     drvISP_Read(1, &bReadData);
-//    msleep(10);           // delay about 10ms
-    i2c_write_update_msg2133(&bWriteData1, 1);
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1);
     return bReadData;
 }
 
 
-
-void drvISP_BlockErase(unsigned int addr)
+static void drvISP_BlockErase(u32 addr)
 {
-    unsigned char bWriteData[5] = { 0x00, 0x00, 0x00, 0x00, 0x00 };
-    unsigned char bWriteData1 = 0x12;
-    unsigned int timeOutCount=0;
-	
+    u8 bWriteData[5] = { 0x00, 0x00, 0x00, 0x00, 0x00 };
+    u8 bWriteData1 = 0x12;
+    MSG2133A_FUN();
+    u32 timeOutCount=0;
     drvISP_WriteEnable();
+
     //Enable write status register
     bWriteData[0] = 0x10;
     bWriteData[1] = 0x50;
-    i2c_write_update_msg2133(bWriteData, 2);
-    i2c_write_update_msg2133(&bWriteData1, 1);
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, bWriteData, 2);
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1);
+
     //Write Status
     bWriteData[0] = 0x10;
     bWriteData[1] = 0x01;
     bWriteData[2] = 0x00;
-    i2c_write_update_msg2133(bWriteData, 3);
-    i2c_write_update_msg2133(&bWriteData1, 1);
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, bWriteData, 3);
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1);
+
     //Write disable
     bWriteData[0] = 0x10;
     bWriteData[1] = 0x04;
-    i2c_write_update_msg2133(bWriteData, 2);
-    i2c_write_update_msg2133(&bWriteData1, 1);
-
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, bWriteData, 2);
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1);
+	//msctpc_LoopDelay ( 1 );        // delay about 100us*****
+	udelay(150);//200);
     timeOutCount=0;
-    msleep(1);           // delay about 100us
-    while((drvISP_ReadStatus() & 0x01) == 0x01)
-    {
-        timeOutCount++;
-	 if ( timeOutCount > 10000 ) 
-            break; /* around 1 sec timeout */
-    }
-
-    //pr_ch("The drvISP_ReadStatus3=%d\n", drvISP_ReadStatus());
+	while ( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+	{
+		timeOutCount++;
+		if ( timeOutCount >= 100000 ) break; /* around 1 sec timeout */
+	}
     drvISP_WriteEnable();
-    //pr_ch("The drvISP_ReadStatus4=%d\n", drvISP_ReadStatus());
+
     bWriteData[0] = 0x10;
-    bWriteData[1] = 0xC7;        //Block Erase
+    bWriteData[1] = 0xC7;//0xD8;        //Block Erase
     //bWriteData[2] = ((addr >> 16) & 0xFF) ;
     //bWriteData[3] = ((addr >> 8) & 0xFF) ;
-    // bWriteData[4] = (addr & 0xFF) ;
-    i2c_write_update_msg2133(bWriteData, 2);
-    //i2c_write_update_msg2133( &bWriteData, 5);
-    i2c_write_update_msg2133(&bWriteData1, 1);
-
-    timeOutCount=0;
-    msleep(1);           // delay about 100us
-    while((drvISP_ReadStatus() & 0x01) == 0x01)
-    {
-        timeOutCount++;
-	 if ( timeOutCount > 10000 ) 
-            break; /* around 1 sec timeout */
-    }
+    //bWriteData[4] = (addr & 0xFF) ;
+	HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, bWriteData, 2);
+    //HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData, 5);
+    HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1);
+		//msctpc_LoopDelay ( 1 );        // delay about 100us*****
+	udelay(150);//200);
+	timeOutCount=0;
+	while ( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+	{
+		timeOutCount++;
+		if ( timeOutCount >= 500000 ) break; /* around 5 sec timeout */
+	}
 }
 
-void drvISP_Program(unsigned short k, unsigned char *pDataToWrite)
+static void drvISP_Program(u16 k, u8* pDataToWrite)
 {
-    unsigned short i = 0;
-    unsigned short j = 0;
-    //U16 n = 0;
-    unsigned char TX_data[133];
-    unsigned char bWriteData1 = 0x12;
-    unsigned int addr = k * 1024;
-#if 1
-
-    for(j = 0; j < 8; j++)    //128*8 cycle
+    u16 i = 0;
+    u16 j = 0;
+    //u16 n = 0;
+    u8 TX_data[133];
+    u8 bWriteData1 = 0x12;
+    u32 addr = k * 1024;
+		u32 timeOutCount=0;
+    for (j = 0; j < 8; j++)   //128*8 cycle
     {
         TX_data[0] = 0x10;
         TX_data[1] = 0x02;// Page Program CMD
         TX_data[2] = (addr + 128 * j) >> 16;
         TX_data[3] = (addr + 128 * j) >> 8;
         TX_data[4] = (addr + 128 * j);
-
-        for(i = 0; i < 128; i++)
+        for (i = 0; i < 128; i++)
         {
             TX_data[5 + i] = pDataToWrite[j * 128 + i];
         }
-
-        while((drvISP_ReadStatus() & 0x01) == 0x01)
-        {
-            ;    //wait until not in write operation
-        }
-
+        //msctpc_LoopDelay ( 1 );        // delay about 100us*****
+        udelay(150);//200);
+       
+        timeOutCount=0;
+		while ( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+		{
+			timeOutCount++;
+			if ( timeOutCount >= 100000 ) break; /* around 1 sec timeout */
+		}
+  
         drvISP_WriteEnable();
-        i2c_write_update_msg2133( TX_data, 133);   //write 133 byte per cycle
-        i2c_write_update_msg2133(&bWriteData1, 1);
+        HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, TX_data, 133);   //write 133 byte per cycle
+        HalTscrCDevWriteI2CSeq(FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1);
     }
+}
 
-#else
-
-    for(j = 0; j < 512; j++)    //128*8 cycle
+static void drvISP_Verify ( u16 k, u8* pDataToVerify )
+{
+    u16 i = 0, j = 0;
+    u8 bWriteData[5] ={ 0x10, 0x03, 0, 0, 0 };
+    u8 RX_data[256];
+    u8 bWriteData1 = 0x12;
+    u32 addr = k * 1024;
+    u8 index = 0;
+    u32 timeOutCount;
+    for ( j = 0; j < 8; j++ ) //128*8 cycle
     {
-        TX_data[0] = 0x10;
-        TX_data[1] = 0x02;// Page Program CMD
-        TX_data[2] = (addr + 2 * j) >> 16;
-        TX_data[3] = (addr + 2 * j) >> 8;
-        TX_data[4] = (addr + 2 * j);
+        bWriteData[2] = ( u8 ) ( ( addr + j * 128 ) >> 16 );
+        bWriteData[3] = ( u8 ) ( ( addr + j * 128 ) >> 8 );
+        bWriteData[4] = ( u8 ) ( addr + j * 128 );
+        udelay ( 100 );        // delay about 100us*****
 
-        for(i = 0; i < 2; i++)
+        timeOutCount = 0;
+        while ( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
         {
-            TX_data[5 + i] = pDataToWrite[j * 2 + i];
+            timeOutCount++;
+            if ( timeOutCount >= 100000 ) break; /* around 1 sec timeout */
         }
 
-        while((drvISP_ReadStatus() & 0x01) == 0x01)
+        HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, bWriteData, 5 ); //write read flash addr
+        udelay ( 100 );        // delay about 100us*****
+        drvISP_Read ( 128, RX_data );
+        HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 ); //cmd end
+        for ( i = 0; i < 128; i++ ) //log out if verify error
         {
-            ;    //wait until not in write operation
+            if ( ( RX_data[i] != 0 ) && index < 10 )
+            {
+                index++;
+            }
+            if ( RX_data[i] != pDataToVerify[128 * j + i] )
+            {
+                MSG2133A_LOG ( "k=%d,j=%d,i=%d===============Update Firmware Error================", k, j, i );
+            }
         }
-
-        drvISP_WriteEnable();
-        i2c_write_update_msg2133(TX_data, 7);    //write 7 byte per cycle
-        i2c_write_update_msg2133(&bWriteData1, 1);
     }
-
-#endif
 }
 
-void drvISP_ExitIspMode(void)
+static void drvISP_ChipErase()
 {
-    unsigned char bWriteData = 0x24;
-    i2c_write_update_msg2133(&bWriteData, 1);
-}
-
-
-static ssize_t firmware_version_show(struct device *dev,
-                                     struct device_attribute *attr, char *buf)
-{
-	printk("tyd-tp: firmware_version_show\n");
-    TPD_DMESG("*** firmware_version_show fw_version = %s***\n", fw_version);
-    return sprintf(buf, "%s\n", fw_version);
-}
-
-static ssize_t firmware_version_store(struct device *dev,
-                                      struct device_attribute *attr, const char *buf, size_t size)
-{
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_alloct();
-	#endif
-    unsigned char dbbus_tx_data[3];
-    unsigned char dbbus_rx_data[4] ;
-    unsigned short major = 0, minor = 0;
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();
-    fw_version = kzalloc(sizeof(char), GFP_KERNEL);
-    TPD_DMESG("\n");
-	TPD_DMESG("tyd-tp: firmware_version_store\n");
-    //Get_Chip_Version();
-    dbbus_tx_data[0] = 0x53;
-    dbbus_tx_data[1] = 0x00;
-    dbbus_tx_data[2] = 0x2a;//0x74--msg2133a;  0x2A----msg2133a
-    //i2c_write(TOUCH_ADDR_MSG20XX, &dbbus_tx_data[0], 3);
-    //i2c_read(TOUCH_ADDR_MSG20XX, &dbbus_rx_data[0], 4);
-//    msg2133_i2c_write(&dbbus_tx_data[0], 3);
-//    msg2133_i2c_read(&dbbus_rx_data[0], 4);
-		HalTscrCDevWriteI2CSeq(this_client->addr, &dbbus_tx_data[0], 3);
-		HalTscrCReadI2CSeq(this_client->addr, &dbbus_rx_data[0], 4);
-    major = (dbbus_rx_data[1] << 8) + dbbus_rx_data[0];
-    minor = (dbbus_rx_data[3] << 8) + dbbus_rx_data[2];
-    TPD_DMESG("***major = %d ***\n", major);
-    TPD_DMESG("***minor = %d ***\n", minor);
-    sprintf(fw_version, "%03d%03d", major, minor);
-    TPD_DMESG("***fw_version = %s ***\n", fw_version);
-	
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_release();
-	#endif
-	
-    return size;
-}
-
-static ssize_t firmware_update_show(struct device *dev,
-                                    struct device_attribute *attr, char *buf)
-{
-	printk("tyd-tp: firmware_update_show\n");
-    return sprintf(buf, "%s\n", fw_version);
-}
-#define _FW_UPDATE_C3_
-
-#define FW_ADDR_MSG21XX   (0xC4>>1)
-#define FW_ADDR_MSG21XX_TP   (0x4C>>1)
-#define FW_UPDATE_ADDR_MSG21XX   (0x92>>1)
-#define TP_DEBUG	printk//(x)		//x
-#define DBUG	printk//(x) //x
+    u8 bWriteData[5] = { 0x00, 0x00, 0x00, 0x00, 0x00 };
+    u8 bWriteData1 = 0x12;
+    u32 timeOutCount = 0;
+    drvISP_WriteEnable();
 
-#ifdef _FW_UPDATE_C3_
+    //Enable write status register
+    bWriteData[0] = 0x10;
+    bWriteData[1] = 0x50;
+    HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, bWriteData, 2 );
+    HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
 
-u8  Fmr_Loader[1024];
-    u32 crc_tab[256];
+    //Write Status
+    bWriteData[0] = 0x10;
+    bWriteData[1] = 0x01;
+    bWriteData[2] = 0x00;
+    HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, bWriteData, 3 );
+    HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
 
-#define _HalTscrHWReset(...) msg2133_reset(__VA_ARGS__)
-//#define disable_irq(...) disable_irq_nosync(__VA_ARGS__)
+    //Write disable
+    bWriteData[0] = 0x10;
+    bWriteData[1] = 0x04;
+    HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, bWriteData, 2 );
+    HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+    udelay ( 100 );        // delay about 100us*****
+    timeOutCount = 0;
+    while ( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+    {
+        timeOutCount++;
+        if ( timeOutCount >= 100000 ) break; /* around 1 sec timeout */
+    }
+    drvISP_WriteEnable();
 
-static ssize_t firmware_update_c2(struct device *dev,struct device_attribute *attr, const char *buf, size_t size)
-{
-    unsigned char i;
-    unsigned char dbbus_tx_data[4];
-    unsigned char dbbus_rx_data[2] = {0};
-    update_switch = 1;
-    //drvISP_EntryIspMode();
-    //drvISP_BlockErase(0x00000);
-    //M by cheehwa _HalTscrHWReset();
+    bWriteData[0] = 0x10;
+    bWriteData[1] = 0xC7;
 
-    //
-  //  disable_irq_nosync(this_client->irq);
-	
-	msg2133_reset();
-    //msctpc_LoopDelay ( 100 );        // delay about 100ms*****
-    // Enable slave's ISP ECO mode
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();
-    //pr_ch("dbbusDWIICIICReshape\n");
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x08;
-    dbbus_tx_data[2] = 0x0c;
-    dbbus_tx_data[3] = 0x08;
-    // Disable the Watchdog
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Get_Chip_Version();
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x11;
-    dbbus_tx_data[2] = 0xE2;
-    dbbus_tx_data[3] = 0x00;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x60;
-    dbbus_tx_data[3] = 0x55;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //pr_ch("update\n");
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x61;
-    dbbus_tx_data[3] = 0xAA;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Stop MCU
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x0F;
-    dbbus_tx_data[2] = 0xE6;
-    dbbus_tx_data[3] = 0x01;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Enable SPI Pad
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x02;
-    i2c_write_msg2133(dbbus_tx_data, 3);
-    i2c_read_msg2133(&dbbus_rx_data[0], 2);
-    //pr_tp("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = (dbbus_rx_data[0] | 0x20);  //Set Bit 5
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x25;
-    i2c_write_msg2133(dbbus_tx_data, 3);
-    dbbus_rx_data[0] = 0;
-    dbbus_rx_data[1] = 0;
-    i2c_read_msg2133(&dbbus_rx_data[0], 2);
-    //pr_tp("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = dbbus_rx_data[0] & 0xFC;  //Clear Bit 1,0
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    /*
-    //------------
-    // ISP Speed Change to 400K
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x11;
-    dbbus_tx_data[2] = 0xE2;
-    i2c_write_msg2133( dbbus_tx_data, 3);
-    i2c_read_msg2133( &dbbus_rx_data[3], 1);
-    //pr_tp("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = dbbus_tx_data[3]&0xf7;  //Clear Bit3
-    i2c_write_msg2133( dbbus_tx_data, 4);
-    */
-    //WP overwrite
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x0E;
-    dbbus_tx_data[3] = 0x02;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //set pin high
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x10;
-    dbbus_tx_data[3] = 0x08;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbusDWIICIICNotUseBus();
-    dbbusDWIICNotStopMCU();
-    dbbusDWIICExitSerialDebugMode();
-    ///////////////////////////////////////
-    // Start to load firmware
-    ///////////////////////////////////////
-    drvISP_EntryIspMode();
-    TPD_DMESG("entryisp\n");
-    drvISP_BlockErase(0x00000);
-    //msleep(1000);
-    TPD_DMESG("FwVersion=2");
-
-    for(i = 0; i < 94; i++)    // total  94 KB : 1 byte per R/W
+    HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, bWriteData, 2 );
+    HalTscrCDevWriteI2CSeq ( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+    udelay ( 100 );        // delay about 100us*****
+    timeOutCount = 0;
+    while ( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
     {
-        //msleep(1);//delay_100us
-        TPD_DMESG("drvISP_Program\n");
-        drvISP_Program(i, temp[i]);    // program to slave's flash
-        //pr_ch("drvISP_Verify\n");
-        //drvISP_Verify ( i, temp[i] ); //verify data
+        timeOutCount++;
+        if ( timeOutCount >= 500000 ) break; /* around 5 sec timeout */
     }
-
-    //MSG2133_DBG("update OK\n");
-    drvISP_ExitIspMode();
-    FwDataCnt = 0;
-    msg2133_reset();
-    TPD_DMESG("update OK\n");
-    update_switch = 0;
-    //
-    enable_irq(this_client->irq);
-    return size;
 }
 
 static u32 Reflect ( u32 ref, char ch ) //unsigned int Reflect(unsigned int ref, char ch)
@@ -939,7 +589,7 @@ static u32 Reflect ( u32 ref, char ch ) //unsigned int Reflect(unsigned int ref,
     return value;
 }
 
-u32 Get_CRC ( u32 text, u32 prevCRC, u32 *crc32_table )
+static u32 Get_CRC ( u32 text, u32 prevCRC, u32 *crc32_table )
 {
     u32  ulCRC = prevCRC;
 	ulCRC = ( ulCRC >> 8 ) ^ crc32_table[ ( ulCRC & 0xFF ) ^ text];
@@ -961,136 +611,218 @@ static void Init_CRC32_Table ( u32 *crc32_table )
     }
 }
 
-typedef enum
-{
-	EMEM_ALL = 0,
-	EMEM_MAIN,
-	EMEM_INFO,
-} EMEM_TYPE_t;
+
+#define I2C_TIMING_DBBUS   (50)
 
 static void drvDB_WriteReg8Bit ( u8 bank, u8 addr, u8 data )
 {
     u8 tx_data[4] = {0x10, bank, addr, data};
+    u16 i2c_timing = i2c_client->timing;
+
+    i2c_client->timing = I2C_TIMING_DBBUS;
     HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 4 );
+    i2c_client->timing = i2c_timing;
+    mdelay(5);
 }
 
 static void drvDB_WriteReg ( u8 bank, u8 addr, u16 data )
 {
     u8 tx_data[5] = {0x10, bank, addr, data & 0xFF, data >> 8};
+    u16 i2c_timing = i2c_client->timing;
+
+    i2c_client->timing = I2C_TIMING_DBBUS;	
     HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 5 );
+    i2c_client->timing = i2c_timing;
+    mdelay(5);
 }
 
 static unsigned short drvDB_ReadReg ( u8 bank, u8 addr )
 {
     u8 tx_data[3] = {0x10, bank, addr};
     u8 rx_data[2] = {0};
+    u16 i2c_timing = i2c_client->timing;
 
+    i2c_client->timing = I2C_TIMING_DBBUS;
     HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 3 );
+    mdelay(5);
     HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &rx_data[0], 2 );
+    mdelay(5);
+    i2c_client->timing = i2c_timing;
     return ( rx_data[1] << 8 | rx_data[0] );
 }
 
-static int drvTP_erase_emem_c32 ( void )
+
+static int drvTP_erase_emem_c33 ( EMEM_TYPE_t emem_type )
 {
-    /////////////////////////
-    //Erase  all
-    /////////////////////////
-    
-    //enter gpio mode
-    drvDB_WriteReg ( 0x16, 0x1E, 0xBEAF );
-
-    // before gpio mode, set the control pin as the orginal status
-    drvDB_WriteReg ( 0x16, 0x08, 0x0000 );
-    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
-    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
-
-    // ptrim = 1, h'04[2]
-    drvDB_WriteReg8Bit ( 0x16, 0x08, 0x04 );
-    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
-    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
-
-    // ptm = 6, h'04[12:14] = b'110
-    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x60 );
-    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
-
-    // pmasi = 1, h'04[6]
-    drvDB_WriteReg8Bit ( 0x16, 0x08, 0x44 );
-    // pce = 1, h'04[11]
-    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x68 );
-    // perase = 1, h'04[7]
-    drvDB_WriteReg8Bit ( 0x16, 0x08, 0xC4 );
-    // pnvstr = 1, h'04[5]
-    drvDB_WriteReg8Bit ( 0x16, 0x08, 0xE4 );
-    // pwe = 1, h'04[9]
-    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x6A );
-    // trigger gpio load
-    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
+    MSG2133A_DBG("ERASE EMEM = %x\n",emem_type);
+    // stop mcu
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0001 );
+
+    //disable watch dog
+    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
+    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
+
+    // set PROGRAM password
+    drvDB_WriteReg8Bit ( 0x16, 0x1A, 0xBA );
+    drvDB_WriteReg8Bit ( 0x16, 0x1B, 0xAB );
+
+    //proto.MstarWriteReg(F1.loopDevice, 0x1618, 0x80);
+    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x80 );
+
+   
+
+    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x40 );
+
+    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x80 );
+
+    // erase trigger
+    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x04 ); //erase main
 
     return ( 1 );
 }
 
-static ssize_t firmware_update_c32 ( struct device *dev, struct device_attribute *attr,
-                                     const char *buf, size_t size,  EMEM_TYPE_t emem_type )
+
+static void drvTP_write_info_dwiic_c33 ( void )
 {
-    u8  dbbus_tx_data[4];
-    u8  dbbus_rx_data[2] = {0};
-      // Buffer for slave's firmware
+    u8 i;
+    u16 reg_data=0;
+
+    _HalTscrHWReset();
+
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+    mdelay ( 100 );
+	
+    //Stop MCU
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0001 );
+	
+    // Stop Watchdog
+    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
+    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
+
+    //CMD	
+    drvDB_WriteReg ( 0x3C, 0xE4, 0x78C5 );
+	
+    drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
+	
+    // TP SW reset
+    drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
+
+    //MCU run	
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0000 );
+
+
+    //polling 0x3CE4 is 0x2F43
+    do
+    {
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+
+    }
+    while ( reg_data != 0x2F43 );
+    MSG2133A_DBG("start info. update.\n");
+
+    for(i=0;i<UPDATE_TIMES;i++)
+    {
+        HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[32]+i*N_BYTE_PER_TIME, N_BYTE_PER_TIME );
+    }
+	
+    //polling 0x3CE4 is 0xD0BC
+    do
+    {
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }
+    while ( reg_data != 0xD0BC );
+    MSG2133A_DBG("info. update finish.\n");
+ }
 
-    u32 i, j, k;
-    u32 crc_main, crc_main_tp;
+static ssize_t firmware_update_c33 ( struct device *dev, struct device_attribute *attr,
+                                     const char *buf, size_t size, EMEM_TYPE_t emem_type )
+{
+    u32 i, j;
+    u32 crc_tab[256];
+    u32 crc_main, crc_main_tp,crc_temp;
     u32 crc_info, crc_info_tp;
     u16 reg_data = 0;
 
     crc_main = 0xffffffff;
     crc_info = 0xffffffff;
 
-#if 1
-    /////////////////////////
-    // Erase  all
-    /////////////////////////
-    drvTP_erase_emem_c32();
-    mdelay ( 1000 ); //MCR_CLBK_DEBUG_DELAY ( 1000, MCU_LOOP_DELAY_COUNT_MS );
-
-    //ResetSlave();
     _HalTscrHWReset();
-    //drvDB_EnterDBBUS();
+
     dbbusDWIICEnterSerialDebugMode();
     dbbusDWIICStopMCU();
     dbbusDWIICIICUseBus();
     dbbusDWIICIICReshape();
-    mdelay ( 300 );
+	
+    //erase main
+    drvTP_erase_emem_c33 ( EMEM_MAIN );
+    MSG2133A_DBG("[21xxA]:EMEM ERASE FINISH!\n");
+    mdelay ( 100 );
 
-    // Reset Watchdog
-    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
-    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
 
     /////////////////////////
     // Program
     /////////////////////////
+    _HalTscrHWReset();
 
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+	
     //polling 0x3CE4 is 0x1C70
-    do
+    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
     {
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        do
+        {
+            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        }
+        while ( reg_data != 0x1C70 );
+	MSG2133A_DBG("[21xxA]:EMEM UPDATE -> polling 0x3CE4 is 0x1C70\n");
     }
-    while ( reg_data != 0x1C70 );
 
+    switch ( emem_type )
+    {
+        case EMEM_ALL:
+            drvDB_WriteReg ( 0x3C, 0xE4, 0xE38F );  // for all-blocks
+            break;
+        case EMEM_MAIN:
+            drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for main block
+            break;
+        case EMEM_INFO:
+            drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for info block
+
+            drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x01 );
+
+            drvDB_WriteReg8Bit ( 0x3C, 0xE4, 0xC5 ); //
+            drvDB_WriteReg8Bit ( 0x3C, 0xE5, 0x78 ); //
 
-    drvDB_WriteReg ( 0x3C, 0xE4, 0xE38F );  // for all-blocks
+            drvDB_WriteReg8Bit ( 0x1E, 0x04, 0x9F );
+            drvDB_WriteReg8Bit ( 0x1E, 0x05, 0x82 );
 
-    //polling 0x3CE4 is 0x2F43
+            drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x00 );
+            mdelay ( 100 );
+            break;
+    }
+
+    // polling 0x3CE4 is 0x2F43
     do
     {
         reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
     }
     while ( reg_data != 0x2F43 );
-
-
-    //calculate CRC 32
+    MSG2133A_DBG("[21xxA]:EMEM UPDATE -> polling 0x3CE4 is 0x2F43\n");
+	
+    // calculate CRC 32
     Init_CRC32_Table ( &crc_tab[0] );
 
-    for ( i = 0; i < 33; i++ ) // total  33 KB : 2 byte per R/W
+    for ( i = 0; i < 32; i++ ) // total  33 KB : 2 byte per R/W
     {
+        if ( emem_type == EMEM_INFO )
+			i = 32;
+
         if ( i < 32 )   //emem_main
         {
             if ( i == 31 )
@@ -1103,6 +835,17 @@ static ssize_t firmware_update_c32 ( struct device *dev, struct device_attribute
                     //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
                     crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
                 }
+
+                crc_temp=crc_main;
+		  crc_temp=crc_temp ^ 0xffffffff;
+
+		  for(j=0;j<4;j++)
+		  {
+		  /**************************modify by sam 20131224**************************/
+		  	temp[i][1023-j]=(crc_temp>>8*j)&0xFF;
+		  /**************************end of modify***********************************/
+			MSG2133A_DBG("Upate crc32 into bin buffer temp[%d][%d]=%x\n",i,(1020+j),temp[i][1020+j]);
+		  }
             }
             else
             {
@@ -1113,1216 +856,1317 @@ static ssize_t firmware_update_c32 ( struct device *dev, struct device_attribute
                 }
             }
         }
-        else  // emem_info
+	 #if(0)
+        else  //emem_info
         {
             for ( j = 0; j < 1024; j++ )
             {
                 //crc_info=Get_CRC(Fmr_Loader[j],crc_info,&crc_tab[0]);
-                crc_info = Get_CRC ( temp[i][j], crc_info, &crc_tab[0] );
+                crc_info = Get_CRC ( g_dwiic_info_data[j], crc_info, &crc_tab[0] );
             }
+            if ( emem_type == EMEM_MAIN ) break;
         }
-
         //drvDWIIC_MasterTransmit( DWIIC_MODE_DWIIC_ID, 1024, Fmr_Loader );
-        //HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i], 1024 );
-		for(k=0; k<8; k++)
+        #endif
+
+        u32 n = 0;
+        for(n=0;n<UPDATE_TIMES;n++)
         {
-        	//HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[i*128], 128 );
-        	HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &temp[i][k*128], 128 );
-			TPD_DMESG ( "firmware_update_c32---g_dwiic_info_data[i*128]: %d\n", i );
-			mdelay(50);
+           // MSG2133A_DBG("i=%d,n=%d",i,n);
+            HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i]+n*N_BYTE_PER_TIME, N_BYTE_PER_TIME );
         }
+
         // polling 0x3CE4 is 0xD0BC
         do
         {
             reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
         }
         while ( reg_data != 0xD0BC );
-
+        MSG2133A_DBG("[21xxA]:EMEM UPDATE -> polling 0x3CE4 is 0xD0BC, CNT=%d\n",i);
+		
         drvDB_WriteReg ( 0x3C, 0xE4, 0x2F43 );
     }
+	
+    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+    {
+        // write file done and check crc
+        drvDB_WriteReg ( 0x3C, 0xE4, 0x1380 );
+    }
 
-    //write file done
-    drvDB_WriteReg ( 0x3C, 0xE4, 0x1380 );
-
-    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
-    // polling 0x3CE4 is 0x9432
-    do
+    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
     {
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        // polling 0x3CE4 is 0x9432
+        do
+        {
+            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        }while ( reg_data != 0x9432 );
+        MSG2133A_DBG("EMEM UPDATE -> polling 0x3CE4 is 0x9432\n");
     }
-    while ( reg_data != 0x9432 );
 
     crc_main = crc_main ^ 0xffffffff;
     crc_info = crc_info ^ 0xffffffff;
 
-    // CRC Main from TP
-    crc_main_tp = drvDB_ReadReg ( 0x3C, 0x80 );
-    crc_main_tp = ( crc_main_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
- 
-    //CRC Info from TP
-    crc_info_tp = drvDB_ReadReg ( 0x3C, 0xA0 );
-    crc_info_tp = ( crc_info_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0xA2 );
-
-    TPD_DMESG ( "crc_main=0x%x, crc_info=0x%x, crc_main_tp=0x%x, crc_info_tp=0x%x\n",
-               crc_main, crc_info, crc_main_tp, crc_info_tp );
-
-    //drvDB_ExitDBBUS();
-    if ( ( crc_main_tp != crc_main ) || ( crc_info_tp != crc_info ) )
+    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
     {
-        TPD_DMESG ( "update FAILED\n" );
-		_HalTscrHWReset();
-        FwDataCnt = 0;
-    	enable_irq(this_client->irq);		
-        return ( 0 );
+        // CRC Main from TP
+        crc_main_tp = drvDB_ReadReg ( 0x3C, 0x80 );
+        crc_main_tp = ( crc_main_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
+        MSG2133A_DBG ( "crc_main=0x%x, crc_main_tp=0x%x, \n",crc_main, crc_main_tp);
+	 if ( crc_main_tp == crc_main )
+	 {
+	      MSG2133A_DBG ( "CRC32 IS CORRECT! \n");
+             MSG2133A_DBG ( "TP UPDATE FINISH! \n");
+	 }
+	 else
+	 {
+	      MSG2133A_DBG ( "update fail~~~ \n");
+	      MSG2133A_DBG ( "main crc error! \n");
+	 }
+		
+        // CRC Info from TP
+        if( emem_type == EMEM_ALL )
+        {
+	        crc_info_tp = drvDB_ReadReg ( 0x3C, 0xA0 );
+	        crc_info_tp = ( crc_info_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0xA2 );
+		 MSG2133A_DBG ( "crc_info=0x%x, crc_info_tp=0x%x, \n",crc_info, crc_info_tp);
+		 if ( crc_info_tp != crc_info )
+		 {
+		      MSG2133A_DBG ( "update fail~~~ \n");
+		      MSG2133A_DBG ( "info crc error! \n");
+		 }
+        }
     }
 
-    TPD_DMESG ( "update OK\n" );
-	_HalTscrHWReset();
-    FwDataCnt = 0;
-	enable_irq(this_client->irq);
-
+    _HalTscrHWReset();
     return size;
-#endif
 }
 
-static int drvTP_erase_emem_c33 ( EMEM_TYPE_t emem_type )
+static ssize_t firmware_update_show ( struct device *dev,
+                                      struct device_attribute *attr, char *buf )
 {
-    // stop mcu
-    drvDB_WriteReg ( 0x0F, 0xE6, 0x0001 );
-
-    //disable watch dog
-    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
-    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
+    return sprintf ( buf, "%s\n", fw_version );
+}
 
-    // set PROGRAM password
-    drvDB_WriteReg8Bit ( 0x16, 0x1A, 0xBA );
-    drvDB_WriteReg8Bit ( 0x16, 0x1B, 0xAB );
-
-    //proto.MstarWriteReg(F1.loopDevice, 0x1618, 0x80);
-    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x80 );
-
-    if ( emem_type == EMEM_ALL )
-    {
-        drvDB_WriteReg8Bit ( 0x16, 0x08, 0x10 ); //mark
-    }
-
-    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x40 );
-    mdelay ( 10 );
-
-    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x80 );
-
-    // erase trigger
-    if ( emem_type == EMEM_MAIN )
-    {
-        drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x04 ); //erase main
-    }
-    else
-    {
-        drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x08 ); //erase all block
-    }
-
-    return ( 1 );
+static ssize_t firmware_update_store ( struct device *dev,
+                                       struct device_attribute *attr, const char *buf, size_t size )
+{	
+	return firmware_update_c33 ( dev, attr, buf, size, EMEM_MAIN );
 }
+static DEVICE_ATTR(update, CTP_AUTHORITY, firmware_update_show, firmware_update_store);
 
-static int drvTP_read_emem_dbbus_c33 ( EMEM_TYPE_t emem_type, u16 addr, size_t size, u8 *p, size_t set_pce_high )
+static ssize_t firmware_version_show(struct device *dev,
+                                     struct device_attribute *attr, char *buf)
 {
-    u32 i;
-
-    // Set the starting address ( must before enabling burst mode and enter riu mode )
-    drvDB_WriteReg ( 0x16, 0x00, addr );
-
-    // Enable the burst mode ( must before enter riu mode )
-    drvDB_WriteReg ( 0x16, 0x0C, drvDB_ReadReg ( 0x16, 0x0C ) | 0x0001 );
-
-    // Set the RIU password
-    drvDB_WriteReg ( 0x16, 0x1A, 0xABBA );
-
-    // Enable the information block if pifren is HIGH
-    if ( emem_type == EMEM_INFO )
-    {
-        // Clear the PCE
-        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0080 );
-        mdelay ( 10 );
-
-        // Set the PIFREN to be HIGH
-        drvDB_WriteReg ( 0x16, 0x08, 0x0010 );
-    }
+    MSG2133A_DBG("*** firmware_version_show fw_version = %s***\n", fw_version);
+    return sprintf(buf, "%s\n", fw_version);
+}
 
-    // Set the PCE to be HIGH
-    drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
-    mdelay ( 10 );
+static ssize_t firmware_version_store(struct device *dev,
+                                      struct device_attribute *attr, const char *buf, size_t size)
+{
+    unsigned char dbbus_tx_data[3];
+    unsigned char dbbus_rx_data[4] ;
+    unsigned short major=0, minor=0;
+   
+/*
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
 
-    // Wait pce becomes 1 ( read data ready )
-    while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
+*/
+    fw_version = kzalloc(sizeof(char), GFP_KERNEL);
 
-    for ( i = 0; i < size; i += 4 )
+    //Get_Chip_Version();
+    dbbus_tx_data[0] = 0x53;
+    dbbus_tx_data[1] = 0x00;
+    if(curr_ic_type==CTP_ID_MSG21XXA)
     {
-        // Fire the FASTREAD command
-        drvDB_WriteReg ( 0x16, 0x0E, drvDB_ReadReg ( 0x16, 0x0E ) | 0x0001 );
-
-        // Wait the operation is done
-        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0001 ) != 0x0001 );
-
-        p[i + 0] = drvDB_ReadReg ( 0x16, 0x04 ) & 0xFF;
-        p[i + 1] = ( drvDB_ReadReg ( 0x16, 0x04 ) >> 8 ) & 0xFF;
-        p[i + 2] = drvDB_ReadReg ( 0x16, 0x06 ) & 0xFF;
-        p[i + 3] = ( drvDB_ReadReg ( 0x16, 0x06 ) >> 8 ) & 0xFF;
+    dbbus_tx_data[2] = 0x2A;
     }
-
-    // Disable the burst mode
-    drvDB_WriteReg ( 0x16, 0x0C, drvDB_ReadReg ( 0x16, 0x0C ) & ( ~0x0001 ) );
-
-    // Clear the starting address
-    drvDB_WriteReg ( 0x16, 0x00, 0x0000 );
-
-    //Always return to main block
-    if ( emem_type == EMEM_INFO )
+    else if(curr_ic_type==CTP_ID_MSG21XX)
     {
-        // Clear the PCE before change block
-        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0080 );
-        mdelay ( 10 );
-        // Set the PIFREN to be LOW
-        drvDB_WriteReg ( 0x16, 0x08, drvDB_ReadReg ( 0x16, 0x08 ) & ( ~0x0010 ) );
-
-        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
-        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
+        dbbus_tx_data[2] = 0x74;
     }
-
-    // Clear the RIU password
-    drvDB_WriteReg ( 0x16, 0x1A, 0x0000 );
-
-    if ( set_pce_high )
+    else
     {
-        // Set the PCE to be HIGH before jumping back to e-flash codes
-        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
-        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
+        MSG2133A_DBG("***ic_type = %d ***\n", dbbus_tx_data[2]);
+        dbbus_tx_data[2] = 0x2A;
     }
-
-    return ( 1 );
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX_TP, &dbbus_tx_data[0], 3);
+    HalTscrCReadI2CSeq(FW_ADDR_MSG21XX_TP, &dbbus_rx_data[0], 4);
+
+    major = (dbbus_rx_data[1]<<8)+dbbus_rx_data[0];
+    minor = (dbbus_rx_data[3]<<8)+dbbus_rx_data[2];
+    curr_ic_major = major;
+    curr_ic_minor = minor;
+
+    MSG2133A_DBG("***major = %d ***\n", major);
+    MSG2133A_DBG("***minor = %d ***\n", minor);
+    sprintf(fw_version,"%03d%03d", major, minor);
+    //MSG2133A_DBG(printk("***fw_version = %s ***\n", fw_version);)
+   
+    return size;
 }
+static DEVICE_ATTR(version, CTP_AUTHORITY, firmware_version_show, firmware_version_store);
 
-
-static int drvTP_read_info_dwiic_c33 ( void )
+static ssize_t firmware_data_show(struct device *dev,
+                                  struct device_attribute *attr, char *buf)
 {
-    u8  dwiic_tx_data[5];
-    u8  dwiic_rx_data[4];
-    u16 reg_data=0;
-    mdelay ( 300 );
-
-    // Stop Watchdog
-    TPD_DMESG ("drvTP_read_info_dwiic_c33---1 \n");
-    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
-    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---2 \n");
-
-    drvDB_WriteReg ( 0x3C, 0xE4, 0xA4AB );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---3 \n");
-
-	drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---4 \n");
-
-    // TP SW reset
-    drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
-	mdelay ( 100 );
-    dwiic_tx_data[0] = 0x10;
-    dwiic_tx_data[1] = 0x0F;
-    dwiic_tx_data[2] = 0xE6;
-    dwiic_tx_data[3] = 0x00;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dwiic_tx_data, 4 );	
-    mdelay ( 100 );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---5 \n");
-
-    do{
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-    }
-    while ( reg_data != 0x5B58 );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---6 \n");
-
-    dwiic_tx_data[0] = 0x72;
-    dwiic_tx_data[1] = 0x80;
-    dwiic_tx_data[2] = 0x00;
-    dwiic_tx_data[3] = 0x04;
-    dwiic_tx_data[4] = 0x00;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , dwiic_tx_data, 5 );
-
-    mdelay ( 50 );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---7 \n");
-
-    // recive info data
-    
-    for(reg_data=0;reg_data<8;reg_data++)
-    {
-		TPD_DMESG ("drvTP_read_info_dwiic_c33---8---ADDR \n");
-		 dwiic_tx_data[1] = 0x80+(((reg_data*128)&0xff00)>>8);            // address High
-         dwiic_tx_data[2] = (reg_data*128)&0x00ff;                                   // address low
-         HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , dwiic_tx_data, 5 );
-         mdelay (10 );
-		 TPD_DMESG ("drvTP_read_info_dwiic_c33---8---READ START\n");
-    	// recive info data
-         HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX_TP, &g_dwiic_info_data[reg_data*128], 128);
-		mdelay (200 );
-		TPD_DMESG ("drvTP_read_info_dwiic_c33---8---READ END \n");
-    }
-
-	
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---8 \n");
-
-    return ( 1 );
+    return FwDataCnt;
 }
 
-static int drvTP_info_updata_C33 ( u16 start_index, u8 *data, u16 size )
+static ssize_t firmware_data_store(struct device *dev,
+                                   struct device_attribute *attr, const char *buf, size_t size)
 {
-    // size != 0, start_index+size !> 1024
-    u16 i;
-    for ( i = 0; i < size; i++ )
-    {
-        g_dwiic_info_data[start_index] = * ( data + i );
-        start_index++;
-    }
-    return ( 1 );
+    memcpy(temp[FwDataCnt], buf, 1024);
+    FwDataCnt++;
+    return size;
 }
+static DEVICE_ATTR(data, CTP_AUTHORITY, firmware_data_show, firmware_data_store);
+#endif  
+//end for update firmware
 
-static ssize_t firmware_update_c33 ( struct device *dev, struct device_attribute *attr,
-                                     const char *buf, size_t size, EMEM_TYPE_t emem_type )
-{
-    u8  dbbus_tx_data[4];
-    u8  dbbus_rx_data[2] = {0};
-    u8  life_counter[2];
-    u32 i, j, k;
-    u32 crc_main, crc_main_tp;
-    u32 crc_info, crc_info_tp;
-  
-    int update_pass = 1;
-    u16 reg_data = 0;
+ static u8 Calculate_8BitsChecksum( u8 *msg, s32 s32Length )
+ {
+	 s32 s32Checksum = 0;
+	 s32 i;
+ 
+	 for( i = 0 ; i < s32Length; i++ )
+	 {
+		 s32Checksum += msg[i];
+	 }
+ 
+	 return ( u8 )( ( -s32Checksum ) & 0xFF );
+ }
 
-    crc_main = 0xffffffff;
-    crc_info = 0xffffffff;
+ static int tpd_touchinfo(TouchScreenInfo_t *touchData)
+ {
+	static int pre_event_is_key = 0;
+    u8 val[8] = {0};
+    u8 Checksum = 0;
+    u8 i;
+    u32 delta_x = 0, delta_y = 0;
+    u32 u32X = 0;
+    u32 u32Y = 0;
+    
 
-    drvTP_read_info_dwiic_c33();
-	
-    if ( g_dwiic_info_data[0] == 'M' && g_dwiic_info_data[1] == 'S' && g_dwiic_info_data[2] == 'T' && g_dwiic_info_data[3] == 'A' && g_dwiic_info_data[4] == 'R' && g_dwiic_info_data[5] == 'T' && g_dwiic_info_data[6] == 'P' && g_dwiic_info_data[7] == 'C' )
-    {
-        // updata FW Version
-        //drvTP_info_updata_C33 ( 8, &temp[32][8], 5 );
-
-		g_dwiic_info_data[8]=temp[32][8];
-		g_dwiic_info_data[9]=temp[32][9];
-		g_dwiic_info_data[10]=temp[32][10];
-		g_dwiic_info_data[11]=temp[32][11];
-        // updata life counter
-        life_counter[1] = (( ( (g_dwiic_info_data[13] << 8 ) | g_dwiic_info_data[12]) + 1 ) >> 8 ) & 0xFF;
-        life_counter[0] = ( ( (g_dwiic_info_data[13] << 8 ) | g_dwiic_info_data[12]) + 1 ) & 0xFF;
-		g_dwiic_info_data[12]=life_counter[0];
-		g_dwiic_info_data[13]=life_counter[1];
-		TPD_DMESG ( "life_counter[0]=%d life_counter[1]=%d\n",life_counter[0],life_counter[1] );
-        //drvTP_info_updata_C33 ( 10, &life_counter[0], 3 );
-        drvDB_WriteReg ( 0x3C, 0xE4, 0x78C5 );
-		drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
-        // TP SW reset
-        drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
-
-        mdelay ( 50 );
-
-        //polling 0x3CE4 is 0x2F43
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    TPD_DEBUG(KERN_ERR "[msg2133a]==tpd_touchinfo() \n");
+#ifdef TPD_PROXIMITY
+		int err;
+		hwm_sensor_data sensor_data;
+#endif
+#ifdef SWAP_X_Y
+    int tempx;
+    int tempy;
+#endif
 
-        }
-        while ( reg_data != 0x2F43 );
+    /*Get Touch Raw Data*/
+    i2c_master_recv( i2c_client, &val[0], REPORT_PACKET_LENGTH );
+    MSG2133A_DBG("[tpd_touchinfo]--val[0]:%x, REPORT_PACKET_LENGTH:%x \n",val[0], REPORT_PACKET_LENGTH);
+    Checksum = Calculate_8BitsChecksum( &val[0], 7 ); //calculate checksum
+    MSG2133A_DBG("[tpd_touchinfo]--Checksum:%x, val[7]:%x, val[0]:%x \n",Checksum, val[7], val[0]);
 
-        // transmit lk info data---xb.pang for 1024
-        //HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[0], 1024 );
-		for(i=0;i<8;i++)
-        {
-        	HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[i*128], 128 );
-			TPD_DMESG ( "HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[%*128], 128 ); \n", i);
-			mdelay(50);
-        }
-        //polling 0x3CE4 is 0xD0BC
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-        }
-        while ( reg_data != 0xD0BC );
+    if( ( Checksum == val[7] ) && ( val[0] == 0x52 ) ) //check the checksum  of packet
+    {
+	    #ifdef TPD_PROXIMITY
+			if((val[5] == 0x80)||(val[5] == 0x40))
+			{
+			   printk(TPD_DEVICE"TP_PROXIMITY g_bPsSensorOpen = %d,g_nPsSensorDate=%d\n",g_bPsSensorOpen,g_nPsSensorDate );		  
+			   if(val[5] == 0x80) // close Panel
+			   	{
+					if((g_bPsSensorOpen == 1) /*&& (g_nPsSensorDate == 1)*/)
+					{
+						mutex_lock(&msg2133_sensor_mutex);
+						g_nPsSensorDate = 0;
+						mutex_unlock(&msg2133_sensor_mutex);
+					}
+			   	}
+			    else// Open Panel
+			    {
+					if(/*(g_bPsSensorOpen == 1) && */(g_nPsSensorDate == 0))
+					{
+						mutex_lock(&msg2133_sensor_mutex);
+						g_nPsSensorDate = 1;
+						mutex_unlock(&msg2133_sensor_mutex);
+					}
+			    }
+				sensor_data.values[0] = g_nPsSensorDate;
+				sensor_data.value_divide = 1;
+				sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;				
+				if ((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
+				{
+					printk(" Proximity call hwmsen_get_interrupt_data failed= %d\n", err);	
+				}	
+				return 0;
+									
+			}
+			#ifdef CTP_PROXIMITY_ESD_MEASURE
+			else if(val[5] == 0xC0) 
+			{			
+				if(g_bPsSensorOpen == 1)
+				{
+					msg2133_enable_ps(1);
+				}
+				return 0;
+			}
+			#endif
+			else
+		#endif
+		    {
+		        u32X = ( ( ( val[1] & 0xF0 ) << 4 ) | val[2] );   //parse the packet to coordinates
+		        u32Y = ( ( ( val[1] & 0x0F ) << 8 ) | val[3] );
+
+		        delta_x = ( ( ( val[4] & 0xF0 ) << 4 ) | val[5] );
+		        delta_y = ( ( ( val[4] & 0x0F ) << 8 ) | val[6] );
+				MSG2133A_DBG("[tpd_touchinfo]--u32X:%d, u32Y:%d, delta_x:%d, delta_y:%d \n",u32X, u32Y,delta_x, delta_y);
+
+				#ifdef SWAP_X_Y
+		        tempy = u32X;
+		        tempx = u32Y;
+		        u32X = tempx;
+		        u32Y = tempy;
+
+		        tempy = delta_x;
+		        tempx = delta_y;
+		        delta_x = tempx;
+		        delta_y = tempy;
+				#endif
+
+				#ifdef REVERSE_X
+		        u32X = 2047 - u32X;
+		        delta_x = 4095 - delta_x;
+				#endif
+
+				#ifdef REVERSE_Y
+		        u32Y = 2047 - u32Y;
+		        delta_y = 4095 - delta_y;
+				#endif
+
+				MSG2133A_DBG("[tpd_touchinfo]--u32X:%d, u32Y:%d, delta_x:%d, delta_y:%d \n",u32X, u32Y,delta_x, delta_y);
+
+		        if( ( val[1] == 0xFF ) && ( val[2] == 0xFF ) && ( val[3] == 0xFF ) && ( val[4] == 0xFF ) && ( val[6] == 0xFF ) )
+		        {  
+		        	touchData->Point[0].X = 0; // final X coordinate
+		            touchData->Point[0].Y = 0; // final Y coordinate
+
+		            if( ( val[5] == 0x0 ) || ( val[5] == 0xFF ) )
+		            {
+		            	// key release or touch release                
+		                touchData->nTouchKeyCode = 0; //TouchKeyMode
+		                touchData->nFingerNum = 0; //touch end
+						touchData->nTouchKeyMode = 0; //TouchKeyMode
+						pre_event_is_key = 0;
+		            }
+		            else
+		            {
+		            	// Key event
+		            	touchData->nFingerNum = 1;
+		                touchData->nTouchKeyCode = val[5]; //TouchKeyCode
+		            	touchData->nTouchKeyMode = 1; //TouchKeyMode
+		            	pre_event_is_key = 1;
+		            }
+		        }
+		        else
+		        {
+		        	// Touch event
+		            touchData->nTouchKeyMode = 0; 
+					pre_event_is_key = 0;
+
+		            if(
+						#ifdef REVERSE_X
+		                ( delta_x == 4095 )
+						#else
+		                ( delta_x == 0 )
+						#endif
+		                &&
+						#ifdef REVERSE_Y
+		                ( delta_y == 4095 )
+						#else
+		                ( delta_y == 0 )
+						#endif
+		            )
+		            {
+		            	// one touch
+		                touchData->nFingerNum = 1;
+		                touchData->Point[0].X = ( u32X * (MS_TS_MSG21XX_X_MAX-1) ) / 2047;
+		                touchData->Point[0].Y = ( u32Y * (MS_TS_MSG21XX_Y_MAX-1) ) / 2047;
+			#if 0
+				touchData->Point[0].X = MS_TS_MSG21XX_X_MAX - touchData->Point[0].X ;
+				touchData->Point[0].Y = MS_TS_MSG21XX_Y_MAX - touchData->Point[0].Y;
+			#endif
 
-    }
+						MSG2133A_DBG("[tpd_touchinfo]--FingerNum = 1 \n");
+		            }
+		            else
+		            {
+		            	// dual touch
+		                u32 x2, y2;
 
-    //erase main
-    drvTP_erase_emem_c33 ( EMEM_MAIN );
-    mdelay ( 1000 );
+		                touchData->nFingerNum = 2; //two touch
 
-    //ResetSlave();
-    _HalTscrHWReset();
+		                /* Finger 1 */
+		                touchData->Point[0].X = ( u32X * (MS_TS_MSG21XX_X_MAX-1) ) / 2047;
+		                touchData->Point[0].Y = ( u32Y * (MS_TS_MSG21XX_Y_MAX-1) ) / 2047;
 
-    //drvDB_EnterDBBUS();
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();
-    mdelay ( 300 );
+			#if 0
+				touchData->Point[0].X = MS_TS_MSG21XX_X_MAX - touchData->Point[0].X ;
+				touchData->Point[0].Y = MS_TS_MSG21XX_Y_MAX - touchData->Point[0].Y;
+			#endif
 
-    /////////////////////////
-    // Program
-    /////////////////////////
 
-    //polling 0x3CE4 is 0x1C70
-    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-        }
-        while ( reg_data != 0x1C70 );
-    }
+		                /* Finger 2 */
+		                if( delta_x > 2048 )    //transform the unsigh value to sign value
+		                {
+		                    delta_x -= 4096;
+		                }
+		                if( delta_y > 2048 )
+		                {
+		                    delta_y -= 4096;
+		                }
+
+		                x2 = ( u32 )( u32X + delta_x );
+		                y2 = ( u32 )( u32Y + delta_y );
+
+		                touchData->Point[1].X = ( x2 * (MS_TS_MSG21XX_X_MAX-1) ) / 2047;
+		                touchData->Point[1].Y = ( y2 * (MS_TS_MSG21XX_Y_MAX-1) ) / 2047;
+			#if 0
+				touchData->Point[1].X = MS_TS_MSG21XX_X_MAX - touchData->Point[1].X ;
+				touchData->Point[1].Y = MS_TS_MSG21XX_Y_MAX - touchData->Point[1].Y;
+			#endif
 
-    switch ( emem_type )
+						
+						MSG2133A_DBG("[tpd_touchinfo]--FingerNum = 2 \n");
+		            }
+		        }
+		    }
+    }
+    else
     {
-        case EMEM_ALL:
-            drvDB_WriteReg ( 0x3C, 0xE4, 0xE38F );  // for all-blocks
-            break;
-        case EMEM_MAIN:
-            drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for main block
-            break;
-        case EMEM_INFO:
-            drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for info block
+		#if 0    
+        DBG("Packet error 0x%x, 0x%x, 0x%x", val[0], val[1], val[2]);
+        DBG("             0x%x, 0x%x, 0x%x", val[3], val[4], val[5]);
+        DBG("             0x%x, 0x%x, 0x%x", val[6], val[7], Checksum);
+		#endif		
+        MSG2133A_DBG( "err status in tp\n" );
+		return 0;
+    }
 
-            drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x01 );
+    //enable_irq( msg21xx_irq );
+  
+	 return true;
 
-            drvDB_WriteReg8Bit ( 0x3C, 0xE4, 0xC5 ); //
-            drvDB_WriteReg8Bit ( 0x3C, 0xE5, 0x78 ); //
+ };
+static  void tpd_down(int x, int y, int p) {
+ 	
+	 // input_report_abs(tpd->dev, ABS_PRESSURE, p);
+	  input_report_key(tpd->dev, BTN_TOUCH, 1);
+	  input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 25);
+	  input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
+	  input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
 
-            drvDB_WriteReg8Bit ( 0x1E, 0x04, 0x9F );
-            drvDB_WriteReg8Bit ( 0x1E, 0x05, 0x82 );
+	  /* track id Start 0 */
+		//input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
+	  input_mt_sync(tpd->dev);
+	  if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+	  {   
+		tpd_button(x, y, 1);  
+	  }
+	  TPD_EM_PRINT(x, y, x, y, p-1, 1);
+  }
+ 
+ static void tpd_up(int x, int y,int *count) {
 
-            drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x00 );
-            mdelay ( 100 );
-            break;
-    }
+	  input_report_key(tpd->dev, BTN_TOUCH, 0);
+	  input_mt_sync(tpd->dev);
+	  TPD_EM_PRINT(x, y, x, y, 0, 0);
+		  
+	  if(FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+	  {   
+	  	 TPD_DEBUG(KERN_ERR "[msg2133a]--tpd_up-BOOT MODE--X:%d, Y:%d; \n", x, y);
+		 tpd_button(x, y, 0); 
+	  } 		  
+ 
+  }
 
-    // polling 0x3CE4 is 0x2F43
-    do
-    {
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-    }
-    while ( reg_data != 0x2F43 );
+#if(0)
+ static void tpd_key(int key_code, int key_val)
+ {
+ 	input_report_key(tpd->kpd, key_code, key_val);
+	TPD_DEBUG(KERN_ERR "[msg2133a] key_code = %d(%d)\n", key_code, key_val);
+ }
+ 
+ static void tpd_check_key(int *key, int *is_down)
+ {
+ 	static int pre_key = 0;
+	int cur_key;
+	 
+	 if (*key == 1)	cur_key = KEY_MENU;
+	 else if (*key == 2)	cur_key = KEY_HOMEPAGE;
+	 else if (*key == 4)	cur_key = KEY_BACK;
+	 else cur_key = 0;
+	 
+	 if ((pre_key != 0) && (cur_key != pre_key))
+	 {
+	 	// current key is different from previous key, then need to send key up
+	 	cur_key = pre_key;
+		pre_key = 0;
+		*is_down = 0;
+	 }
+	 else 
+	 {
+	 	pre_key = cur_key;
+	 	*is_down = 1;
+	 }
+	 
+	 *key = cur_key;
 
-    // calculate CRC 32
-    Init_CRC32_Table ( &crc_tab[0] );
+ }
+#endif
 
-    for ( i = 0; i < 33; i++ ) // total  33 KB : 2 byte per R/W
-    {
-        if ( emem_type == EMEM_INFO )
-			i = 32;
+ 
+ static int touch_event_handler(void *unused)
+ {
+  
+    TouchScreenInfo_t touchData;
+	u8 touchkeycode = 0;
+	static u32 preKeyStatus = 0;
+	int i=0;
+	touchData.nFingerNum = 0;
+	touchData.nTouchKeyMode =0;
+	touchData.nTouchKeyCode =0;
+	 
+	if (tpd_touchinfo(&touchData)) 
+	{
+	 
+		MSG2133A_DBG( "[msg2133a]--KeyMode:%d, KeyCode:%d, FingerNum =%d \n", touchData.nTouchKeyMode, touchData.nTouchKeyCode, touchData.nFingerNum );
+	 
+		//key event
+		if( touchData.nTouchKeyMode )
+		{
+		#if(0)
+			int key_code = touchData.nTouchKeyCode; 
+			int key_val;
 
-        if ( i < 32 )   //emem_main
-        {
-            if ( i == 31 )
-            {
-                temp[i][1014] = 0x5A; //Fmr_Loader[1014]=0x5A;
-                temp[i][1015] = 0xA5; //Fmr_Loader[1015]=0xA5;
+			tpd_check_key(&key_code, &key_val);
+			
+	    	tpd_key(key_code, key_val);
+			input_sync(tpd->kpd);
+		#endif
 
-                for ( j = 0; j < 1016; j++ )
-                {
-                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
-                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
-                }
-            }
-            else
-            {
-                for ( j = 0; j < 1024; j++ )
-                {
-                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
-                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
-                }
-            }
-        }
-        else  //emem_info
-        {
-            for ( j = 0; j < 1024; j++ )
-            {
-                //crc_info=Get_CRC(Fmr_Loader[j],crc_info,&crc_tab[0]);
-                crc_info = Get_CRC ( g_dwiic_info_data[j], crc_info, &crc_tab[0] );
-            }
-            if ( emem_type == EMEM_MAIN ) break;
-        }
+	    	//key mode change virtual key mode
+			touchData.nFingerNum = 1;
+			if( touchData.nTouchKeyCode == 2 )
+			{
+				//touchkeycode = KEY_MENU;
+				//touchData.Point[0].X = 40;
+				//touchData.Point[0].Y = 517;
+				touchData.Point[0].X = 400;
+				touchData.Point[0].Y = 820;
+			}
+			if( touchData.nTouchKeyCode ==4 )
+			{
+				//touchkeycode = KEY_HOMEPAGE ;
+				//touchData.Point[0].X = 120;
+				//touchData.Point[0].Y = 517;
+				touchData.Point[0].X = 240;
+				touchData.Point[0].Y = 820;
 
-        //drvDWIIC_MasterTransmit( DWIIC_MODE_DWIIC_ID, 1024, Fmr_Loader );
-        //HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i], 1024 );
-		for(k=0; k<8; k++)
-        {
-        	HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &temp[i][k*128], 128 );
-			TPD_DMESG ( "temp[i] \n");
-			mdelay(50);
-        }
-        // polling 0x3CE4 is 0xD0BC
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-        }
-        while ( reg_data != 0xD0BC );
+			}
+			if( touchData.nTouchKeyCode == 1 )
+			{
+				//touchkeycode = KEY_BACK;
+				//touchData.Point[0].X = 200;
+				//touchData.Point[0].Y = 517;
+				touchData.Point[0].X = 80;
+				touchData.Point[0].Y = 820;
 
-        drvDB_WriteReg ( 0x3C, 0xE4, 0x2F43 );
-    }
+			}
+			/*if( touchData.nTouchKeyCode == 8 )
+			{
+				//touchkeycode = KEY_SEARCH;
+				touchData.Point[0].X = 200;
+				touchData.Point[0].Y = 517;
 
-    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        // write file done and check crc
-        drvDB_WriteReg ( 0x3C, 0xE4, 0x1380 );
-    }
-    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
+			}*/
 
-    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        // polling 0x3CE4 is 0x9432
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-			TPD_DMESG("polling \n");
-        }while ( reg_data != 0x9432 );
-    }
+		}
+		//Touch event
+		if( ( touchData.nFingerNum ) == 0 ) //touch end
+		{
+			MSG2133A_LOG("------UP------ \n");
+			MSG2133A_LOG( "[msg2133a]---X:%d, Y:%d; \n", touchData.Point[0].X, touchData.Point[0].Y);
+			tpd_up(touchData.Point[0].X, touchData.Point[0].Y, 0);
+			input_sync( tpd->dev );
+		}
+		else //touch on screen
+		{
+			MSG2133A_LOG("------DOWN------ \n");
+			for( i = 0; i < ( (int)touchData.nFingerNum ); i++ )
+			{
+			    tpd_down(touchData.Point[i].X, touchData.Point[i].Y, 1);
+			    MSG2133A_LOG( "[msg2133a]---X:%d, Y:%d; i=%d \n", touchData.Point[i].X, touchData.Point[i].Y, i);
+			}
+			input_sync( tpd->dev );
+		}
+	}
 
-    crc_main = crc_main ^ 0xffffffff;
-    crc_info = crc_info ^ 0xffffffff;
+TPD_EVENT_END:
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
+	return 0;
+ }
+ 
+ static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info) 
+ {
+	 strcpy(info->type, TPD_DEVICE);	
+	 return 0;
+ }
+ 
+ static void tpd_eint_interrupt_handler(void)
+ {
+ 	 TPD_DEBUG_PRINT_INT;
+	 mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+	 schedule_work( &msg21xx_wq );
+ }
 
-    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        // CRC Main from TP
-        crc_main_tp = drvDB_ReadReg ( 0x3C, 0x80 );
-        crc_main_tp = ( crc_main_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
+#if LCT_ADD_TP_VERSION
+#define CTP_PROC_FILE "ctp_version"
+static struct proc_dir_entry *g_ctp_proc = NULL;
+static int g_major = 0;
+static int g_minor = 0;
 
-        // CRC Info from TP
-        crc_info_tp = drvDB_ReadReg ( 0x3C, 0xA0 );
-        crc_info_tp = ( crc_info_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0xA2 );
-    }
-    TPD_DMESG ( "crc_main=0x%x, crc_info=0x%x, crc_main_tp=0x%x, crc_info_tp=0x%x\n",
-               crc_main, crc_info, crc_main_tp, crc_info_tp );
+static int ctp_proc_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
 
-    //drvDB_ExitDBBUS();
+	int cnt= 0;
+	printk("Enter ctp_proc_read.\n");
+	if(off != 0)
+		return 0;
+	cnt = sprintf(page, "vid:0x%04x,firmware:0x%04x\n",g_major, g_minor);
+	
+	*eof = 1;
+	printk("vid:0x%04x,firmware:0x%04x\n",g_major, g_minor);
+	printk("Leave ctp_proc_read. cnt = %d\n", cnt);
+	return cnt;
+}
+#endif
 
-    update_pass = 1;
-	if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        if ( crc_main_tp != crc_main )
-            update_pass = 0;
+static void _GetMainFwVersion(void)
+{
+    u8 smbus_tx_data[3]={0};
+    u8 smbus_rx_data[4]={0};
 
-        if ( crc_info_tp != crc_info )
-            update_pass = 0;
+    smbus_tx_data[0] = 0x53;
+    smbus_tx_data[1] = 0x00;
+     if(curr_ic_type==CTP_ID_MSG21XXA)
+    {
+        smbus_tx_data[2] = 0x2A;
     }
-
-    if ( !update_pass )
+    else if(curr_ic_type==CTP_ID_MSG21XX)
+    {
+        smbus_tx_data[2] = 0x74;
+    }
+    else
     {
-        TPD_DMESG ( "update FAILED\n" );
-		_HalTscrHWReset();
-        FwDataCnt = 0;
-    	enable_irq(this_client->irq);
-        return ( 0 );
+        MSG2133A_LOG("***ic_type = %d ***\n", smbus_tx_data[2]);
+        smbus_tx_data[2] = 0x2A;
     }
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX_TP, &smbus_tx_data[0], 3);
+    mdelay(100);
+    HalTscrCReadI2CSeq(FW_ADDR_MSG21XX_TP, &smbus_rx_data[0], 4);
 
-    TPD_DMESG ( "update OK\n" );
-	_HalTscrHWReset();
-    FwDataCnt = 0;
-    enable_irq(this_client->irq);
-    return size;
+    curr_ic_major = (smbus_rx_data[1]<<8)+smbus_rx_data[0];
+    curr_ic_minor = (smbus_rx_data[3]<<8)+smbus_rx_data[2];
+
+    MSG2133A_LOG("***FW Version major = %d ***\n", curr_ic_major);
+    MSG2133A_LOG("***FW Version minor = %d ***\n", curr_ic_minor);
 }
 
-static ssize_t firmware_update_store ( struct device *dev,
-                                       struct device_attribute *attr, const char *buf, size_t size )
+#ifdef	ENABLE_AUTO_UPDATA
+static u32 _CalMainCRC32(void)
 {
-    u8 i;
-    u8 dbbus_tx_data[4];
-    unsigned char dbbus_rx_data[2] = {0};
-	//disable_irq(this_client->irq);
-#ifdef __MSG_DMA_MODE__
-	msg_dma_alloct();
-#endif
+    u32 ret=0;
+    u16  reg_data=0;
+
     _HalTscrHWReset();
 
-    // Erase TP Flash first
     dbbusDWIICEnterSerialDebugMode();
     dbbusDWIICStopMCU();
     dbbusDWIICIICUseBus();
     dbbusDWIICIICReshape();
-    mdelay ( 300 );
-
-    // Disable the Watchdog
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x60;
-    dbbus_tx_data[3] = 0x55;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x61;
-    dbbus_tx_data[3] = 0xAA;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
-    // Stop MCU
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x0F;
-    dbbus_tx_data[2] = 0xE6;
-    dbbus_tx_data[3] = 0x01;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
-    /////////////////////////
-    // Difference between C2 and C3
-    /////////////////////////
-	// c2:2133 c32:2133a(2) c33:2138
-    //check id
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0xCC;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
-    HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
-    if ( dbbus_rx_data[0] == 2 )//update for 21XXA
-    {
-        // check version
-        dbbus_tx_data[0] = 0x10;
-        dbbus_tx_data[1] = 0x3C;
-        dbbus_tx_data[2] = 0xEA;
-        HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
-        HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
-        TPD_DMESG ( "dbbus_rx version[0]=0x%x", dbbus_rx_data[0] );
-
-        if ( dbbus_rx_data[0] == 3 )//update for 21XXA u03
-		{
-             firmware_update_c33 ( dev, attr, buf, size, EMEM_MAIN );
-		}
-        else//update for 21XXA U02
-		{
-             firmware_update_c32 ( dev, attr, buf, size, EMEM_ALL );
-        }
-    }
-    else//update for 21XX
-    {
-         firmware_update_c2 ( dev, attr, buf, size );
-    } 
-
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_release();
-	#endif
+    mdelay ( 100 );
 
-	return 1;
-}
-#endif //endif _FW_UPDATE_C3_
+    //Stop MCU
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0001 );
+	
+    // Stop Watchdog
+    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
+    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
+  
+    //cmd
+    drvDB_WriteReg ( 0x3C, 0xE4, 0xDF4C ); 
+    drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
+    // TP SW reset
+    drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
 
-static ssize_t firmware_data_show(struct device *dev,
-                                  struct device_attribute *attr, char *buf)
-{
-	TPD_DMESG("tyd-tp: firmware_data_show\n");
-    return FwDataCnt;
-}
+    //MCU run 	
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0000 );
 
-static ssize_t firmware_data_store(struct device *dev,
-                                   struct device_attribute *attr, const char *buf, size_t size)
-{
-    int i;
-    TPD_DMESG("***FwDataCnt = %d ***\n", FwDataCnt);
-	TPD_DMESG("tyd-tp: firmware_data_store\n");
-   // for(i = 0; i < 1024; i++)
+    //polling 0x3CE4	
+    do
     {
-        memcpy(temp[FwDataCnt], buf, 1024);
-    }
-
-    FwDataCnt++;
-    return size;
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }while ( reg_data != 0x9432 );
+        
+    // Cal CRC Main from TP
+    ret = drvDB_ReadReg ( 0x3C, 0x80 );
+    ret = ( ret << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
+    
+    MSG2133A_LOG("[21xxA]:Current main crc32=0x%x\n",ret);
+    return (ret);
 }
 
-static ssize_t firmware_clear_show(struct device *dev,
-                                   struct device_attribute *attr, char *buf)
+static u32 _ReadBinConfig ( void )
 {
-    unsigned short k = 0, i = 0, j = 0;
-    unsigned char bWriteData[5] =
-    {
-        0x10, 0x03, 0, 0, 0
-    };
-    unsigned char RX_data[256];
-    unsigned char bWriteData1 = 0x12;
-    unsigned int addr = 0;
-    TPD_DMESG("\n");
-	TPD_DMESG("tyd-tp: firmware_clear_show\n");
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_alloct();
-	#endif
-    for(k = 0; k < 94; i++)    // total  94 KB : 1 byte per R/W
-    {
-        addr = k * 1024;
-
-        for(j = 0; j < 8; j++)    //128*8 cycle
-        {
-            bWriteData[2] = (unsigned char)((addr + j * 128) >> 16);
-            bWriteData[3] = (unsigned char)((addr + j * 128) >> 8);
-            bWriteData[4] = (unsigned char)(addr + j * 128);
-
-            while((drvISP_ReadStatus() & 0x01) == 0x01)
-            {
-                ;    //wait until not in write operation
-            }
-
-            i2c_write_update_msg2133(bWriteData, 5);     //write read flash addr
-            drvISP_Read(128, RX_data);
-            i2c_write_update_msg2133(&bWriteData1, 1);    //cmd end
+    u8 i;
+    u32 ret=0;
+    u8  dbbus_tx_data[5]={0};
+    u8  dbbus_rx_data[4]={0};
+    u16 reg_data=0;
 
-            for(i = 0; i < 128; i++)    //log out if verify error{
-                if(RX_data[i] != 0xFF){
-                    TPD_DMESG("k=%d,j=%d,i=%d===============erase not clean================", k, j, i);
-                }
-            }
-     }
-    TPD_DMESG("read finish\n");
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_release();
-	#endif
-    return sprintf(buf, "%s\n", fw_version);
-}
+    _HalTscrHWReset();
 
-static ssize_t firmware_clear_store(struct device *dev,
-                                    struct device_attribute *attr, const char *buf, size_t size)
-{
-    unsigned char dbbus_tx_data[4];
-    unsigned char dbbus_rx_data[2] = {0};
-    //msctpc_LoopDelay ( 100 );        // delay about 100ms*****
-    // Enable slave's ISP ECO mode
-    /*
     dbbusDWIICEnterSerialDebugMode();
     dbbusDWIICStopMCU();
     dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();*/
-    #ifdef __MSG_DMA_MODE__
-	msg_dma_alloct();
-	#endif
-    TPD_DMESG("\n");
-	TPD_DMESG("tyd-tp: firmware_clear_store\n");
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x08;
-    dbbus_tx_data[2] = 0x0c;
-    dbbus_tx_data[3] = 0x08;
-    // Disable the Watchdog
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Get_Chip_Version();
-    //FwVersion  = 2;
-    //if (FwVersion  == 2)
-    {
-        dbbus_tx_data[0] = 0x10;
-        dbbus_tx_data[1] = 0x11;
-        dbbus_tx_data[2] = 0xE2;
-        dbbus_tx_data[3] = 0x00;
-        i2c_write_msg2133(dbbus_tx_data, 4);
-    }
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x60;
-    dbbus_tx_data[3] = 0x55;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x61;
-    dbbus_tx_data[3] = 0xAA;
-    i2c_write_msg2133(dbbus_tx_data, 4);
+    dbbusDWIICIICReshape();
+    mdelay ( 100 );
+	
     //Stop MCU
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x0F;
-    dbbus_tx_data[2] = 0xE6;
-    dbbus_tx_data[3] = 0x01;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Enable SPI Pad
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x02;
-    i2c_write_msg2133(dbbus_tx_data, 3);
-    i2c_read_msg2133(&dbbus_rx_data[0], 2);
-    TPD_DMESG("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = (dbbus_rx_data[0] | 0x20);  //Set Bit 5
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x25;
-    i2c_write_msg2133(dbbus_tx_data, 3);
-    dbbus_rx_data[0] = 0;
-    dbbus_rx_data[1] = 0;
-    i2c_read_msg2133(&dbbus_rx_data[0], 2);
-    TPD_DMESG("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = dbbus_rx_data[2] & 0xFC;  //Clear Bit 1,0
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //WP overwrite
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x0E;
-    dbbus_tx_data[3] = 0x02;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //set pin high
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x10;
-    dbbus_tx_data[3] = 0x08;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbusDWIICIICNotUseBus();
-    dbbusDWIICNotStopMCU();
-    dbbusDWIICExitSerialDebugMode();
-    ///////////////////////////////////////
-    // Start to load firmware
-    ///////////////////////////////////////
-    drvISP_EntryIspMode();
-    TPD_DMESG("chip erase+\n");
-    drvISP_BlockErase(0x00000);
-    TPD_DMESG("chip erase-\n");
-    drvISP_ExitIspMode();
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_release();
-	#endif
-    return size;
-}
-
-static DEVICE_ATTR(version, 0777, firmware_version_show, firmware_version_store);
-static DEVICE_ATTR(update, 0777, firmware_update_show, firmware_update_store);
-static DEVICE_ATTR(data, 0777, firmware_data_show, firmware_data_store);
-static DEVICE_ATTR(clear, 0777, firmware_clear_show, firmware_clear_store);
-
-void msg2133_init_class()
-{
-	firmware_class = class_create(THIS_MODULE,"ms-touchscreen-msg20xx" );//client->name
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0001 );
+	
+    // Stop Watchdog
+    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
+    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
 
-	if(IS_ERR(firmware_class))
-		pr_err("Failed to create class(firmware)!\n");
+    //cmd	
+    drvDB_WriteReg ( 0x3C, 0xE4, 0xA4AB );
+    drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
 
-	firmware_cmd_dev = device_create(firmware_class,
-	                                     NULL, 0, NULL, "device");//device
+    // TP SW reset
+    drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
 
-	if(IS_ERR(firmware_cmd_dev))
-		pr_err("Failed to create device(firmware_cmd_dev)!\n");
-		
-	// version /sys/class/mtk-tpd/device/version
-	if(device_create_file(firmware_cmd_dev, &dev_attr_version) < 0)
-		pr_err("Failed to create device file(%s)!\n", dev_attr_version.attr.name);
+    //MCU run	
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0000 );
 
-	// update /sys/class/mtk-tpd/device/update
-	if(device_create_file(firmware_cmd_dev, &dev_attr_update) < 0)
-		pr_err("Failed to create device file(%s)!\n", dev_attr_update.attr.name);
+   //polling 0x3CE4
+    do
+    {
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }
+    while ( reg_data != 0x5B58 );
 
-	// data /sys/class/mtk-tpd/device/data
-	if(device_create_file(firmware_cmd_dev, &dev_attr_data) < 0)
-		pr_err("Failed to create device file(%s)!\n", dev_attr_data.attr.name);
+    dbbus_tx_data[0] = 0x72;
+    dbbus_tx_data[1] = 0x7F;
+    dbbus_tx_data[2] = 0xFC;
+    dbbus_tx_data[3] = 0x00;
+    dbbus_tx_data[4] = 0x04;
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &dbbus_tx_data[0], 5 );
+    // recive info data
+    HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX_TP, &dbbus_rx_data[0], 4 );
 
-	// clear /sys/class/mtk-tpd/device/clear
-	if(device_create_file(firmware_cmd_dev, &dev_attr_clear) < 0)
-		pr_err("Failed to create device file(%s)!\n", dev_attr_clear.attr.name);
+    for(i=0;i<4;i++)
+    {
+        MSG2133A_DBG("[21xxA]:Bin Config dbbus_rx_data[%d]=%x\n",i,dbbus_rx_data[i]);
+    }
+/**************************modify by sam 20131224**************************/
+    ret=dbbus_rx_data[0];
+    ret=(ret<<8)|dbbus_rx_data[1];
+    ret=(ret<<8)|dbbus_rx_data[2];
+    ret=(ret<<8)|dbbus_rx_data[3];
+/**************************end of modify************************************/
+    MSG2133A_LOG("[21xxA]:crc32 from bin config=%x\n",ret);
+    return (ret);
 }
 
-#endif //endif __FIRMWARE_UPDATE__ MSG2133_UPDATE
+static u16 _GetVendorID ( EMEM_TYPE_t emem_type )
+{
+    u8 i;
+    u16 ret=0;
+    u8  dbbus_tx_data[5]={0};
+    u8  dbbus_rx_data[4]={0};
+    u16 reg_data=0;
+    u16 addr_id;
 
-//end for update firmware
+    _HalTscrHWReset();
 
- static u8 Calculate_8BitsChecksum( u8 *msg, s32 s32Length )
- {
-	 s32 s32Checksum = 0;
-	 s32 i;
- 
-	 for( i = 0 ; i < s32Length; i++ )
-	 {
-		 s32Checksum += msg[i];
-	 }
- 
-	 return ( u8 )( ( -s32Checksum ) & 0xFF );
- }
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+    mdelay ( 100 );
+	
+    //Stop MCU
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0001 );
+	
+    // Stop Watchdog
+    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
+    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
 
- static int tpd_touchinfo(TouchScreenInfo_t *touchData)
- {
+    //cmd	
+    drvDB_WriteReg ( 0x3C, 0xE4, 0xA4AB );
+    drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
 
-    u8 val[8] = {0};
-    u8 Checksum = 0;
-    u8 i;
-    u32 delta_x = 0, delta_y = 0;
-    u32 u32X = 0;
-    u32 u32Y = 0;
-    
+    // TP SW reset
+    drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
 
-    TPD_DEBUG(KERN_ERR "[msg2133]==tpd_touchinfo() \n");
+    //MCU run	
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0000 );
 
+   //polling 0x3CE4
+    do
+    {
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }
+    while ( reg_data != 0x5B58 );
 
-#ifdef SWAP_X_Y
-    int tempx;
-    int tempy;
-#endif
+    if(emem_type == EMEM_MAIN)
+    {
+        addr_id = 0x7F55;
+    }
+    else if(emem_type == EMEM_INFO)
+    {
+        addr_id = 0x8300;
+    }
 
-    /*Get Touch Raw Data*/
-    i2c_master_recv( msg_i2c_client, &val[0], REPORT_PACKET_LENGTH );
-    TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--val[0]:%x, REPORT_PACKET_LENGTH:%x \n",val[0], REPORT_PACKET_LENGTH);
-    Checksum = Calculate_8BitsChecksum( &val[0], 7 ); //calculate checksum
-    TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--Checksum:%x, val[7]:%x, val[0]:%x \n",Checksum, val[7], val[0]);
+    dbbus_tx_data[0] = 0x72;
+    dbbus_tx_data[1] = (addr_id>>8)&0xFF;
+    dbbus_tx_data[2] = addr_id&0xFF;
+    dbbus_tx_data[3] = 0x00;
+    dbbus_tx_data[4] = 0x04;
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &dbbus_tx_data[0], 5 );
+    // recive info data
+    HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX_TP, &dbbus_rx_data[0], 4 );
 
-    if( ( Checksum == val[7] ) && ( val[0] == 0x52 ) ) //check the checksum  of packet
+    for(i=0;i<4;i++)
     {
-        u32X = ( ( ( val[1] & 0xF0 ) << 4 ) | val[2] );   //parse the packet to coordinates
-        u32Y = ( ( ( val[1] & 0x0F ) << 8 ) | val[3] );
-
-        delta_x = ( ( ( val[4] & 0xF0 ) << 4 ) | val[5] );
-        delta_y = ( ( ( val[4] & 0x0F ) << 8 ) | val[6] );
-		TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--u32X:%d, u32Y:%d, delta_x:%d, delta_y:%d \n",u32X, u32Y,delta_x, delta_y);
+        MSG2133A_DBG("[21xxA]:Vendor id dbbus_rx_data[%d]=0x%x,%d\n",i,dbbus_rx_data[i],(dbbus_rx_data[i]-0x30));
+    }
 
-#ifdef SWAP_X_Y
-        tempy = u32X;
-        tempx = u32Y;
-        u32X = tempx;
-        u32Y = tempy;
-
-        tempy = delta_x;
-        tempx = delta_y;
-        delta_x = tempx;
-        delta_y = tempy;
-#endif
-#ifdef REVERSE_X
-        u32X = 2047 - u32X;
-        delta_x = 4095 - delta_x;
+#if(0)
+    ret=dbbus_rx_data[3];
+    ret=(ret<<8)|dbbus_rx_data[2];
+    ret=(ret<<8)|dbbus_rx_data[1];
+    ret=(ret<<8)|dbbus_rx_data[0];
 #endif
-#ifdef REVERSE_Y
-        u32Y = 2047 - u32Y;
-        delta_y = 4095 - delta_y;
-#endif
-
-		TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--u32X:%d, u32Y:%d, delta_x:%d, delta_y:%d \n",u32X, u32Y,delta_x, delta_y);
 
-        if( ( val[1] == 0xFF ) && ( val[2] == 0xFF ) && ( val[3] == 0xFF ) && ( val[4] == 0xFF ) && ( val[6] == 0xFF ) )
-        {  
-            touchData->Point[0].X = 0; // final X coordinate
-            touchData->Point[0].Y = 0; // final Y coordinate
-
-            if( ( val[5] == 0x0 ) || ( val[5] == 0xFF ) )
-            {
-                touchData->nFingerNum = 0; //touch end
-                touchData->nTouchKeyCode = 0; //TouchKeyMode
-                touchData->nTouchKeyMode = 0; //TouchKeyMode
-            }
-            else
-            {
-                touchData->nTouchKeyMode = 1; //TouchKeyMode
-                touchData->nTouchKeyCode = val[5]; //TouchKeyCode
-                touchData->nFingerNum = 1;
-            }
-        }
-        else
-        {
-            touchData->nTouchKeyMode = 0; //Touch on screen...
-
-            if(
-#ifdef REVERSE_X
-                ( delta_x == 4095 )
-#else
-                ( delta_x == 0 )
-#endif
-                &&
-#ifdef REVERSE_Y
-                ( delta_y == 4095 )
-#else
-                ( delta_y == 0 )
-#endif
-            )
-            {
-                touchData->nFingerNum = 1; //one touch
-                touchData->Point[0].X = ( u32X * MS_TS_MSG21XX_X_MAX ) / 2048;
-                touchData->Point[0].Y = ( u32Y * MS_TS_MSG21XX_Y_MAX ) / 2048;
-				TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--FingerNum = 1 \n");
-				TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--touchData->Point[0].X = %d,  touchData->Point[0].Y = %d \n",touchData->Point[0].X,touchData->Point[0].Y);
-            }
-            else
-            {
-                u32 x2, y2;
+    #ifdef UPDATE_MODE_B
+    if(emem_type==EMEM_MAIN && dbbus_rx_data[0]==0x54 && dbbus_rx_data[1]==0x50 && dbbus_rx_data[2]==0x56)
+    {
+        flag_update_mode_b=1;
+        ret=curr_ic_major;
+	 MSG2133A_LOG("[21xxA]:OLD RULE,TURN ON UPDATE_MODE_B--1\n");   //pass
+    }
+    #endif
+	
+    if((dbbus_rx_data[0]>=0x30 && dbbus_rx_data[0]<=0x39)
+    &&(dbbus_rx_data[1]>=0x30 && dbbus_rx_data[1]<=0x39)
+    &&(dbbus_rx_data[2]>=0x31 && dbbus_rx_data[2]<=0x39))  
+    {
+    	ret=(dbbus_rx_data[0]-0x30)*100+(dbbus_rx_data[1]-0x30)*10+(dbbus_rx_data[2]-0x30);
+    }
 
-                touchData->nFingerNum = 2; //two touch
 
-                /* Finger 1 */
-                touchData->Point[0].X = ( u32X * MS_TS_MSG21XX_X_MAX ) / 2048;
-                touchData->Point[0].Y = ( u32Y * MS_TS_MSG21XX_Y_MAX ) / 2048;
+    if(emem_type == EMEM_MAIN)
+    {
+        MSG2133A_LOG("[21xxA]:Vendor id from main block=%d\n",ret);
+    }
+    else if(emem_type == EMEM_INFO)
+    {
+        MSG2133A_LOG("[21xxA]:Vendor id from info. block=%d\n",ret);
+    }
+	
+    return (ret);
+}
 
-                /* Finger 2 */
-                if( delta_x > 2048 )    //transform the unsigh value to sign value
-                {
-                    delta_x -= 4096;
-                }
-                if( delta_y > 2048 )
-                {
-                    delta_y -= 4096;
-                }
+static u8 _CheckFwIntegrity(void)
+{
+    u8 ret=0;
+    u32 cal_crc32, bin_conf_crc32;
 
-                x2 = ( u32 )( u32X + delta_x );
-                y2 = ( u32 )( u32Y + delta_y );
+    cal_crc32=_CalMainCRC32();
+    bin_conf_crc32=_ReadBinConfig();
 
-                touchData->Point[1].X = ( x2 * MS_TS_MSG21XX_X_MAX ) / 2048;
-                touchData->Point[1].Y = ( y2 * MS_TS_MSG21XX_Y_MAX ) / 2048;
-				TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--FingerNum = 2 \n");
-            }
-        }
+    if((cal_crc32==bin_conf_crc32)&&(curr_ic_major+curr_ic_minor)>0)
+    {
+         ret=1;
+    }	
 
-       
-    }
-    else
+    #ifdef UPDATE_MODE_B
+    if((0==bin_conf_crc32)&&(curr_ic_major+curr_ic_minor)>0)
     {
-        //DBG("Packet error 0x%x, 0x%x, 0x%x", val[0], val[1], val[2]);
-        //DBG("             0x%x, 0x%x, 0x%x", val[3], val[4], val[5]);
-        //DBG("             0x%x, 0x%x, 0x%x", val[6], val[7], Checksum);
-        TPD_DEBUG( KERN_ERR "err status in tp\n" );
-    }
+         flag_update_mode_b=1;
+	  MSG2133A_LOG("[21xxA]:NO CRC32 IN BIN CFG,TURN ON UPDATE_MODE_B--0\n");	 
+    }	
+    #endif
 
-    //enable_irq( msg21xx_irq );
-  ///
-	 return true;
+    return (ret);
+}
 
- };
- 
- static  void tpd_down(int x, int y, int p) {
- 	
-	 // input_report_abs(tpd->dev, ABS_PRESSURE, p);
-	  input_report_key(tpd->dev, BTN_TOUCH, 1);
-	  input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 25);
-	  input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-	  input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
+#endif
 
-	  /* track id Start 0 */
-		//input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
-	  input_mt_sync(tpd->dev);
-	  if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-	  {   
-		tpd_button(x, y, 1);  
-	  }
-	  if(y > TPD_RES_Y) //virtual key debounce to avoid android ANR issue
-	  {
-		  msleep(50);
-		  TPD_DEBUG("D virtual key \n");
-	  }
-	  TPD_EM_PRINT(x, y, x, y, p-1, 1);
-  }
-  
- static  void tpd_up(int x, int y,int *count) {
 
-	  input_report_key(tpd->dev, BTN_TOUCH, 0);
-	  input_mt_sync(tpd->dev);
-	  TPD_EM_PRINT(x, y, x, y, 0, 0);
-		  
-	  if(FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-	  {   
-	  	 TPD_DEBUG(KERN_ERR "[msg2133]--tpd_up-BOOT MODE--X:%d, Y:%d; \n", x, y);
-		 tpd_button(x, y, 0); 
-	  } 		  
- 
-  }
+#ifdef TPD_PROXIMITY
+static int msg2133_enable_ps(int enable)
+{
+	u8 ps_store_data[4];
 
- static int touch_event_handler(void *unused)
- {
-  
-    TouchScreenInfo_t touchData;
-	u8 touchkeycode = 0;
-	static u32 preKeyStatus = 0;
-	int i=0;
- 
-    TPD_DEBUG(KERN_ERR "[msg2133]touch_event_handler() do while \n");
+	mutex_lock(&msg2133_sensor_mutex);
 
-	touchData.nFingerNum = 0;
-	TPD_DEBUG(KERN_ERR "[msg2133]touch_event_handler() do while \n");
-	 
-	if (tpd_touchinfo(&touchData)) 
+	printk("msg2133 do enable: %d, current state: %d\n", enable, g_bPsSensorOpen);
+	if(enable == 1)
 	{
-	 
-		TPD_DEBUG(KERN_ERR "[msg2133]--KeyMode:%d, KeyCode:%d, FingerNum =%d \n", touchData.nTouchKeyMode, touchData.nTouchKeyCode, touchData.nFingerNum );
-	 
-		//key...
-		if( touchData.nTouchKeyMode )
+		//if(g_bPsSensorOpen == 0)
 		{
-	    	//key mode change virtual key mode
-			touchData.nFingerNum = 1;
-			if( touchData.nTouchKeyCode == 1 )
-			{
-				//touchkeycode = KEY_MENU;
-				touchData.Point[0].X = 80;
-				touchData.Point[0].Y = 850;
-			}
-			if( touchData.nTouchKeyCode == 2 )
-			{
-				//touchkeycode = KEY_HOMEPAGE ;
-				touchData.Point[0].X = 240;
-				touchData.Point[0].Y = 850;
+			ps_store_data[0] = 0x52;
+			ps_store_data[1] = 0x00;
+            if(curr_ic_type==CTP_ID_MSG21XXA)
+            {
+                ps_store_data[2] = 0x4a;
+            }
+            else if(curr_ic_type==CTP_ID_MSG21XX)
+            {
+                ps_store_data[2] = 0x62;
+            }
+            else
+            {
+                ps_store_data[2] = 0x4a;
+            }
+			ps_store_data[3] = 0xa0;		
+			printk("msg2133 do enable: %d, current state: %d\n", enable, g_bPsSensorOpen);
+			HalTscrCDevWriteI2CSeq(0x26, &ps_store_data[0], 4);
+			g_bPsSensorOpen = 1;
+		}
+	}
+	else
+	{	
+		//if(g_bPsSensorOpen == 1)
+		{
+			ps_store_data[0] = 0x52;
+			ps_store_data[1] = 0x00;
+			if(curr_ic_type==CTP_ID_MSG21XXA)
+            {
+                ps_store_data[2] = 0x4a;
+            }
+            else if(curr_ic_type==CTP_ID_MSG21XX)
+            {
+                ps_store_data[2] = 0x62;
+            }
+            else
+            {
+                ps_store_data[2] = 0x4a;
+            }
+			ps_store_data[3] = 0xa1;
+			HalTscrCDevWriteI2CSeq(0x26, &ps_store_data[0], 4);	
+			g_bPsSensorOpen = 0;			
+		}
+		g_nPsSensorDate = 1;
+	}
+	mutex_unlock(&msg2133_sensor_mutex);
+	return 0;
+}
 
-			}
-			if( touchData.nTouchKeyCode == 4 )
-			{
-				//touchkeycode = KEY_BACK;
-				touchData.Point[0].X = 400;
-				touchData.Point[0].Y = 850;
+int msg2133_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
+		void* buff_out, int size_out, int* actualout)
+{
+	int err = 0;
+	int value;
+	hwm_sensor_data* sensor_data;
 
-			}
-			if( touchData.nTouchKeyCode == 8 )
+	APS_FUN(f);
+	//delete debug log
+	switch (command)
+	{
+		case SENSOR_DELAY:
+			if((buff_in == NULL) || (size_in < sizeof(int)))
 			{
-				//touchkeycode = KEY_SEARCH;
-				//touchData.Point[0].X = 560;
-				//touchData.Point[0].Y = 850;
-
+				APS_ERR("Set delay parameter error!\n");
+				err = -EINVAL;
 			}
-					
-		}
-				//report
-		{
-	 
-			if( ( touchData.nFingerNum ) == 0 ) //touch end
+			// Do nothing
+			break;
+
+		case SENSOR_ENABLE:
+			if((buff_in == NULL) || (size_in < sizeof(int)))
 			{
-				TPD_DEBUG("------UP------ \n");
-				TPD_DEBUG(KERN_ERR "[msg2133]---X:%d, Y:%d; \n", touchData.Point[0].X, touchData.Point[0].Y);
-				tpd_up(touchData.Point[0].X, touchData.Point[0].Y, 0);
-				input_sync( tpd->dev );
+				APS_ERR("Enable sensor parameter error!\n");
+				err = -EINVAL;
 			}
-			else //touch on screen
-			{
-	 
-				for( i = 0; i < ( (int)touchData.nFingerNum ); i++ )
+			else
+			{				
+				value = *(int *)buff_in;
+				if(value)
 				{
-				    TPD_DEBUG("------DOWN------ \n");
-					tpd_down(touchData.Point[i].X, touchData.Point[i].Y, 1);
-					TPD_DEBUG(KERN_ERR "[msg2133]---X:%d, Y:%d; i=%d \n", touchData.Point[i].X, touchData.Point[i].Y, i);
+					printk("msg2133_ps_operate++++++++1\n");
+					wake_lock(&ps_lock);		//wujinyou
+					if(err = msg2133_enable_ps(1))
+					{
+						APS_ERR("enable ps fail: %d\n", err); 
+						return -1;
+					}
+					g_bPsSensorOpen = 1;
+				}
+				else
+				{
+					printk("msg2133_ps_operate++++++++0\n");
+					wake_unlock(&ps_lock);		//wujinyou
+					if(err = msg2133_enable_ps(0))
+					{
+						APS_ERR("disable ps fail: %d\n", err); 
+						return -1;
+					}
+					g_bPsSensorOpen = 0;
 				}
-	 
-				input_sync( tpd->dev );
 			}
-		}//end if(touchData->nTouchKeyMode)
-	 
+			break;
+
+		case SENSOR_GET_DATA:
+			printk("msg2133_ps get date: %d\n", g_nPsSensorDate);
+			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
+			{
+				APS_ERR("get sensor data parameter error!\n");
+				err = -EINVAL;
+			}
+			else
+			{
+				sensor_data = (hwm_sensor_data *)buff_out;	
+				sensor_data->values[0] = g_nPsSensorDate;
+				sensor_data->value_divide = 1;
+				sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;			
 			}
+			break;
+		default:
+			APS_ERR("proxmy sensor operate function no this parameter %d!\n", command);
+			err = -1;
+			break;
+	}
+	
+	return err;
+}
 
-     mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
-	 return 0;
- }
- 
- static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info) 
- {
-	 strcpy(info->type, TPD_DEVICE);	
-	  return 0;
- }
- 
- static void tpd_eint_interrupt_handler(void)
- {
-	 mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-	 schedule_work( &msg21xx_wq );
- }
+
+static void tpd_initialize_ps_sensor_function()
+{
+	//delete debug log
+	struct hwmsen_object obj_ps = {0};
+	int err = 0;
+	
+	g_nPsSensorDate = 1;
+
+	obj_ps.self = NULL;	// no use
+	obj_ps.polling = 0;
+	obj_ps.sensor_operate = msg2133_ps_operate;
+
+	wake_lock_init(&ps_lock,WAKE_LOCK_SUSPEND,"ps wakelock"); 
+		
+	if(err = hwmsen_attach(ID_PROXIMITY, &obj_ps))
+	{
+		TPD_DEBUG("attach fail = %d\n", err);
+		return;
+	}
+}
+#endif
+
+/******************************************************************************
+Function:       get_touch_module_name
+Description:   get TOUCH module name
+Input:         panel id
+Return:         panel name
+Others:         NA
+******************************************************************************/
+static char * get_touch_module_name(unsigned short module_id)
+{
+	switch(module_id)
+	{
+		case SWID_TRULY:
+			return "TRULY";
+		case SWID_OFILM:
+			return "OFILM";
+	       default:
+			return "unknow";
+	}
+}
+
+static void fw_and_config_upgrade(struct work_struct *fw_upgrade)
+{
+ 	MSG2133A_LOG("Enter  Auto Upgrade\n");
+	firmware_update_store(NULL, NULL, NULL, 0);
+}
 
  static int __devinit tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
  {	 
- 
 	int retval = TPD_OK;
 	char data;
 	u8 report_rate=0;
 	int err=0;
 	int reset_count = 0;
 
-	msg_i2c_client = client;
-	//msg21xx_i2c_client = client;
-	this_client = client;
-	/*reset I2C clock*/
-    //i2c_client->timing = 0;
-    
-   INIT_WORK( &msg21xx_wq, touch_event_handler );
-//power on, need confirm with SA
-#ifdef TPD_POWER_SOURCE_CUSTOM
-	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
-#else
-	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-#endif
-#ifdef TPD_POWER_SOURCE_1800
-	hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
-#endif 
-
+	i2c_client = client;
 
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	 
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-	hwPowerOn(TPD_POWER_SOURCE,VOL_2800,"TP");
-	msleep(100);
-#else
-
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(10);
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(50);
-	TPD_DMESG(" msg2133 reset\n");
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(50);
 	
-#endif
+	hw_product_type board_id;
+	board_id=get_hardware_product_version();
+	
 	
+	
+	char* module_name = NULL;
+	int i = 0;
+	
+	
+   	INIT_WORK( &msg21xx_wq, touch_event_handler );
+
+	hwPowerOn(MT6323_POWER_LDO_VGP1, VOL_2800, "TP");
 
+		
+	if(board_id == HW_ULC01_VER_A)
+		{
+			hwPowerOn(MT6323_POWER_LDO_VGP2, VOL_1800, "TP");
+		}		
+	else{
+			hwPowerOn(MT6323_POWER_LDO_VGP3, VOL_1800, "TP");
+		}
+		
+
+	// Reset panel
+	msg2133_reset();
+
+       // Configure interrupt pin
 	mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
-    mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
+	mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
    	mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_ENABLE);
-    mt_set_gpio_pull_select(GPIO_CTP_EINT_PIN, GPIO_PULL_DOWN);
-		
+    	mt_set_gpio_pull_select(GPIO_CTP_EINT_PIN, GPIO_PULL_DOWN);
 
-    msleep(10);
+    	msleep(10);
 
-	//mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
-	//mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
-	mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_TYPE, tpd_eint_interrupt_handler, 1);
+	mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
+	mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
+	mt65xx_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_EN, CUST_EINT_TOUCH_PANEL_POLARITY, tpd_eint_interrupt_handler, 1); 
 	msleep(50);
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-	msleep(200);
-/*
-	 char dbbus_tx_data[3];
-	 char dbbus_rx_data[2]; 
-	 dbbusDWIICEnterSerialDebugMode();
-	 dbbusDWIICStopMCU();
-	 dbbusDWIICIICUseBus();
-	 dbbusDWIICIICReshape();
-	 dbbus_tx_data[0] = 0x10;
-	 dbbus_tx_data[1] = 0x3A;
-	 dbbus_tx_data[2] = 0x08; 
-	 dbbus_rx_data[0]=0xFF;
-	 dbbus_rx_data[1]=0xFF; 
-	 HalTscrCDevWriteI2CSeq(0XC4, &dbbus_tx_data[0], 3);
-	 HalTscrCReadI2CSeq(0XC4, &dbbus_rx_data[0], 2);
-	 dbbusDWIICIICNotUseBus();
-	 dbbusDWIICNotStopMCU();
-	 dbbusDWIICExitSerialDebugMode();
-
-	 if(dbbus_rx_data[0]==0||dbbus_rx_data[0]==0xff)
+	mt65xx_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+	msleep(200);	
+	
+    	tpd_load_status = 1;
+    	
+ #ifdef __FIRMWARE_UPDATE__
+	firmware_class = class_create(THIS_MODULE, "ms-touchscreen-msg20xx");
+    	if(IS_ERR(firmware_class))
+       	 pr_err("Failed to create class(firmware)!\n");
+    	firmware_cmd_dev = device_create(firmware_class,
+       	                              NULL, 0, NULL, "device");
+    	if (IS_ERR(firmware_cmd_dev))
+        	pr_err("Failed to create device(firmware_cmd_dev)!\n");
+
+    	// version
+    	if (device_create_file(firmware_cmd_dev, &dev_attr_version) < 0)
+        	pr_err("Failed to create device file(%s)!\n", dev_attr_version.attr.name);
+    	// update
+    	if (device_create_file(firmware_cmd_dev, &dev_attr_update) < 0)
+        	pr_err("Failed to create device file(%s)!\n", dev_attr_update.attr.name);
+    	// data
+    	if (device_create_file(firmware_cmd_dev, &dev_attr_data) < 0)
+        	pr_err("Failed to create device file(%s)!\n", dev_attr_data.attr.name);
+	// clear
+ 	//   if (device_create_file(firmware_cmd_dev, &dev_attr_clear) < 0)
+ 	//       pr_err("Failed to create device file(%s)!\n", dev_attr_clear.attr.name);
+
+	dev_set_drvdata(firmware_cmd_dev, NULL);
+
+	
+    HalDisableIrq();
+    curr_ic_type = CTP_ID_MSG21XXA;
+    _GetMainFwVersion();
+	
+    #ifdef	ENABLE_AUTO_UPDATA
+    u8 update_flag=1;
+    #ifdef UPDATE_INFO_BLK
+    u8 update_info=0;
+    #endif 
+    u16 update_bin_major=0;
+    u16 update_bin_minor=0;
+    SWID_ENUM sw_id=SWID_NULL;
+	    
+    if(_CheckFwIntegrity())
+    {
+	  //get vendor id from main block.
+	  sw_id=_GetVendorID(EMEM_MAIN);
+	  
+	 if(sw_id == SWID_TRULY) //truly
 	 {
-		 return -1;//	
+		update_bin_major = MSG21XX_truly_update_bin[0x7f4f]<<8|MSG21XX_truly_update_bin[0x7f4e];
+		update_bin_minor = MSG21XX_truly_update_bin[0x7f51]<<8|MSG21XX_truly_update_bin[0x7f50];
 	 }
+	 else if(sw_id == SWID_OFILM)
+	 { //MSG21XX_ofilm_update_bin
+	 	update_bin_major = MSG21XX_ofilm_update_bin[0x7f4f]<<8|MSG21XX_ofilm_update_bin[0x7f4e];
+		update_bin_minor = MSG21XX_ofilm_update_bin[0x7f51]<<8|MSG21XX_ofilm_update_bin[0x7f50];
+	 }
+	 else
+	 {
+	     //NO Vendor ID 
+	     sw_id=SWID_NULL;
+	     update_flag=0;
+	     update_bin_major=0;
+	     update_bin_minor=0;
+	     MSG2133A_LOG("MAIN VENDOR ID ERROR!!\n");
+        #ifdef UPDATE_MODE_A
+	     update_flag=1;
+	     #ifdef UPDATE_INFO_BLK
+            update_info=1;
+	     #endif
+            sw_id=SWID_FORCED;
+        #endif
+	 }
+	 MSG2133A_LOG("sw_id=%d,update_bin_major=%d,update_bin_minor=%d,curr_ic_major=%d,curr_ic_minor=%d\n",sw_id,update_bin_major,update_bin_minor,curr_ic_major,curr_ic_minor);
+	 //check upgrading 
+	 if(update_bin_minor>curr_ic_minor && sw_id<SWID_NULL )
+	 {
+	 	MSG2133A_LOG("TP FW WILL UPGRADE TO V%x.%x\n",update_bin_major,update_bin_minor);
+		if(sw_id == SWID_TRULY) //truly
+		 {
+			for (i = 0; i < 33; i++)
+			{
+				firmware_data_store(NULL, NULL, &(MSG21XX_truly_update_bin[i*1024]), 0);
+			}
+		 }
+		 else if(sw_id == SWID_OFILM) //truly
+		 {
+			for (i = 0; i < 33; i++)
+			{
+				firmware_data_store(NULL, NULL, &(MSG21XX_ofilm_update_bin[i*1024]), 0);
+			}
+		 }
+	 }
+	 else  //normal boot up process
+	 {
+             update_flag=0;
+	      MSG2133A_LOG("ENTER NORMAL BOOT-UP PROCESS!\n");
+	 }
+    }
+    else
+    {
+        //get vendor id from info. block
+    
+        sw_id=_GetVendorID(EMEM_INFO);
+		
+	 if(sw_id==SWID_TRULY) //truly
+	 {
+		update_bin_major=MSG21XX_truly_update_bin[0x7f4f]<<8|MSG21XX_truly_update_bin[0x7f4e];
+		update_bin_minor=MSG21XX_truly_update_bin[0x7f51]<<8|MSG21XX_truly_update_bin[0x7f50];
+	 }
+	 else if(sw_id == SWID_OFILM)
+	 { //MSG21XX_ofilm_update_bin
+	 	update_bin_major = MSG21XX_ofilm_update_bin[0x7f4f]<<8|MSG21XX_ofilm_update_bin[0x7f4e];
+		update_bin_minor = MSG21XX_ofilm_update_bin[0x7f51]<<8|MSG21XX_ofilm_update_bin[0x7f50];
+	 }
+	 else
+	 {
+	     //NO Vendor ID 
+	     sw_id=SWID_NULL;
+	     update_flag=0;
+	     update_bin_major=0;
+	     update_bin_minor=0;
+	     MSG2133A_LOG("INFO BLOCK ERROR,DO NOT UPGRADE!!!\n");
+	 }
+
+	 if(sw_id<SWID_NULL)
+	 {
+        	    MSG2133A_LOG("CHECK FW INTEGRITY FAIL,SELECT VENDOR ID FROM INFO. BLOCK,SW_ID=%d\n",sw_id);   //pass
+	 }
+
+
+	 //transfer data
+	 if(sw_id == SWID_TRULY) //truly
+	 {
+		for (i = 0; i < 33; i++)
+		{
+			firmware_data_store(NULL, NULL, &(MSG21XX_truly_update_bin[i*1024]), 0);
+		}
+	 }
+	 else if(sw_id == SWID_OFILM) //truly
+	 {
+		for (i = 0; i < 33; i++)
+		{
+			firmware_data_store(NULL, NULL, &(MSG21XX_ofilm_update_bin[i*1024]), 0);
+		}
+	 }
+    }
 
-	*/
-    if((i2c_smbus_read_i2c_block_data(msg_i2c_client, 0x00, 1, &data))< 0)
+    _HalTscrHWReset();
+    //update	
+    if(update_flag==1)
+    {
+       #ifdef UPDATE_INFO_BLK
+	if(update_info==1)
 	{
-		TPD_DMESG("I2C transfer error, line: %d\n", __LINE__);
-		return -1; 
+	    drvTP_write_info_dwiic_c33();  
 	}
-	
-    tpd_load_status = 1;
+	#endif
 
-	TPD_DMESG("msg2133 Touch Panel Device Probe %s\n", (retval < TPD_OK) ? "FAIL" : "PASS");
-	
-	TPD_DEBUG("msg2133--frameware upgrade \n");
+	INIT_WORK(&fw_update, fw_and_config_upgrade);
+	schedule_work(&fw_update);
+	   
+    	//firmware_update_store(NULL, NULL, NULL, 0);
 
-    /*frameware upgrade*/	
-#ifdef __FIRMWARE_UPDATE__
-		firmware_class = class_create( THIS_MODULE, "ms-touchscreen-msg20xx" );
-		if( IS_ERR( firmware_class ) )
-			pr_err( "Failed to create class(firmware)!\n" );
-		firmware_cmd_dev = device_create( firmware_class,
-										  NULL, 0, NULL, "device" );
-		if( IS_ERR( firmware_cmd_dev ) )
-			pr_err( "Failed to create device(firmware_cmd_dev)!\n" );
+	//mdelay(60);
+
+	//_GetMainFwVersion();
+    }
+#endif
+
+    //_HalTscrHWReset();
+    FwDataCnt = 0;
+    HalEnableIrq();
 	
-		// version
-		if( device_create_file( firmware_cmd_dev, &dev_attr_version ) < 0 )
-			pr_err( "Failed to create device file(%s)!\n", dev_attr_version.attr.name );
-		// update
-		if( device_create_file( firmware_cmd_dev, &dev_attr_update ) < 0 )
-			pr_err( "Failed to create device file(%s)!\n", dev_attr_update.attr.name );
-		// data
-		if( device_create_file( firmware_cmd_dev, &dev_attr_data ) < 0 )
-			pr_err( "Failed to create device file(%s)!\n", dev_attr_data.attr.name );
-		// clear
-		if( device_create_file( firmware_cmd_dev, &dev_attr_clear ) < 0 )
-			pr_err( "Failed to create device file(%s)!\n", dev_attr_clear.attr.name );
+#endif 
+        
+
+#ifdef LCT_ADD_TP_VERSION
+
+	// get fw version
+		unsigned char dbbus_tx_data[3];
+		unsigned char dbbus_rx_data[4] ;
+		unsigned short major=0, minor=0;
 	
-		dev_set_drvdata( firmware_cmd_dev, NULL );
+	//	Get_Chip_Version();
+		dbbus_tx_data[0] = 0x53;
+		dbbus_tx_data[1] = 0x00;
+		dbbus_tx_data[2] = 0x74;
+		HalTscrCDevWriteI2CSeq(0x4C, &dbbus_tx_data[0], 3);
+		HalTscrCReadI2CSeq(0x4C, &dbbus_rx_data[0], 4);
+		g_major = (dbbus_rx_data[1]<<8)+dbbus_rx_data[0];
+		g_minor = (dbbus_rx_data[3]<<8)+dbbus_rx_data[2];
+	// end get fw
+
+		g_ctp_proc = create_proc_entry(CTP_PROC_FILE, 0444, NULL);
+		if (g_ctp_proc == NULL) {
+			printk("create_proc_entry failed\n");
+		} else {
+			g_ctp_proc->read_proc = ctp_proc_read;
+			g_ctp_proc->write_proc = NULL;
+			//g_ctp_proc->owner = THIS_MODULE;
+			printk("create_proc_entry success\n");
+		}
 #endif
 
+
+	//module_name = get_touch_module_name(sw_id);
+	//sprintf(touch_info,"MSTAR_%s.%d",module_name,curr_ic_minor);
+	//set_id_value(TP_ID, touch_info);
+
+#ifdef TPD_PROXIMITY
+	tpd_initialize_ps_sensor_function();
+#endif
+	//delete debug log
    return 0;
    
  }
@@ -2373,6 +2217,15 @@ void msg2133_init_class()
  {
  
    TPD_DMESG("TPD wake up\n");
+#if 0//def TPD_PROXIMITY
+	if(g_bPsSensorOpen == 0 && (!g_bSuspend))
+	{
+		TPD_DMESG("msg sensor resume in calling tp no need to resume\n");
+		return 0;
+	}
+	g_bSuspend = 0;
+#endif
+   
 #ifdef TPD_CLOSE_POWER_IN_SLEEP	
 	hwPowerOn(TPD_POWER_SOURCE,VOL_2800,"TP");
 #endif
@@ -2392,11 +2245,27 @@ void msg2133_init_class()
 	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
 	TPD_DMESG("TPD wake up done\n");
 	
+#ifdef TPD_PROXIMITY
+	if(g_bPsSensorOpen == 1)
+	{
+		TPD_DMESG("msg sensor resume in calling  \n");
+		msg2133_enable_ps(1);// CTP Proximity function open command  again ;
+	}
+#endif	
  }
 
  static void tpd_suspend( struct early_suspend *h )
  {
  	
+#ifdef TPD_PROXIMITY
+	if(g_bPsSensorOpen == 1)//if(g_nPsSensorDate == 0)
+	{
+		TPD_DMESG("msg suspend in calling tp no need to suspend\n");
+		return 0;
+	}
+	g_bSuspend = 1;
+#endif
+ 	
 	TPD_DMESG("TPD enter sleep\n");
 	mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
 	
@@ -2428,7 +2297,7 @@ void msg2133_init_class()
  /* called when loaded into kernel */
  static int __init tpd_driver_init(void) {
 	 TPD_DEBUG("MediaTek MSG2133 touch panel driver init\n");
-	   i2c_register_board_info(0, &msg2133_i2c_tpd, 1);
+	   i2c_register_board_info(TPD_I2C_NUMBER, &msg2133_i2c_tpd, 1);
 		 if(tpd_driver_add(&tpd_device_driver) < 0)
 			 TPD_DMESG("add MSG2133 driver failed\n");
 	 return 0;
@@ -2443,4 +2312,3 @@ void msg2133_init_class()
  module_init(tpd_driver_init);
  module_exit(tpd_driver_exit);
 
-
