From 5d4851e3211e75d14682835460fc61ff6758e08e Mon Sep 17 00:00:00 2001
From: "haolong.zhang" <haolong.zhang@ck-telecom.com>
Date: Tue, 14 Oct 2014 14:31:29 +0800
Subject: [PATCH] mstar_driver_FAE_step_one.patch

Change-Id: Iac0f271063f0e64011c33234d3d3120d4691cd54
---
 mediatek/config/ckt95_lw_kk/ProjectConfig.mk       |    2 +-
 .../kernel/touchpanel/msg2133/msg2133_driver.c     | 2446 ------------
 .../kernel/touchpanel/msg2133/mstar_drv_common.c   |  152 +
 .../kernel/touchpanel/msg2133/mstar_drv_common.h   |  320 ++
 .../msg2133/mstar_drv_ic_fw_porting_layer.c        |  195 +
 .../msg2133/mstar_drv_ic_fw_porting_layer.h        |   90 +
 .../kernel/touchpanel/msg2133/mstar_drv_main.c     |  987 +++++
 .../kernel/touchpanel/msg2133/mstar_drv_main.h     |   89 +
 .../kernel/touchpanel/msg2133/mstar_drv_mtk.c      |  275 ++
 .../msg2133/mstar_drv_platform_interface.c         |  147 +
 .../msg2133/mstar_drv_platform_interface.h         |   47 +
 .../msg2133/mstar_drv_platform_porting_layer.c     |  598 +++
 .../msg2133/mstar_drv_platform_porting_layer.h     |  155 +
 .../touchpanel/msg2133/mstar_drv_self_fw_control.c | 3974 ++++++++++++++++++++
 .../touchpanel/msg2133/mstar_drv_self_fw_control.h |  154 +
 .../msg2133/mstar_drv_utility_adaption.c           |  406 ++
 .../msg2133/mstar_drv_utility_adaption.h           |  101 +
 17 files changed, 7691 insertions(+), 2447 deletions(-)
 delete mode 100755 mediatek/custom/common/kernel/touchpanel/msg2133/msg2133_driver.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_common.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_common.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_ic_fw_porting_layer.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_ic_fw_porting_layer.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_main.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_main.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_mtk.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_interface.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_interface.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_porting_layer.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_porting_layer.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_self_fw_control.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_self_fw_control.h
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_utility_adaption.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_utility_adaption.h

diff --git a/mediatek/config/ckt95_lw_kk/ProjectConfig.mk b/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
index 8d7d391..0f154a2 100755
--- a/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
+++ b/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
@@ -169,7 +169,7 @@ CUSTOM_KERNEL_SUB_IMGSENSOR=
 CUSTOM_KERNEL_SUB_LENS=
 
 # touch driver  need to report correct touch axes
-CUSTOM_KERNEL_TOUCHPANEL=ektf2k  #GT9XX_hotknot
+CUSTOM_KERNEL_TOUCHPANEL=msg2133  #GT9XX_hotknot
 
 # Configuration for USB PHY
 CUSTOM_KERNEL_USB=mt6577
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/msg2133_driver.c b/mediatek/custom/common/kernel/touchpanel/msg2133/msg2133_driver.c
deleted file mode 100755
index 1a56921..0000000
--- a/mediatek/custom/common/kernel/touchpanel/msg2133/msg2133_driver.c
+++ /dev/null
@@ -1,2446 +0,0 @@
-#include "tpd.h"
-#include <linux/interrupt.h>
-#include <cust_eint.h>
-#include <linux/i2c.h>
-#include <linux/sched.h>
-#include <linux/kthread.h>
-#include <linux/rtpm_prio.h>
-#include <linux/wait.h>
-#include <linux/time.h>
-#include <linux/delay.h>
-
-#include "tpd_custom_msg2133.h"
-
-#include <mach/mt_pm_ldo.h>
-#include <mach/mt_typedefs.h>
-#include <mach/mt_boot.h>
-#include <mach/mt_gpio.h>
-
-#include "cust_gpio_usage.h"
-
-//for dma mode
-#include <linux/dma-mapping.h>
-#include <linux/mm_types.h>
-#include <linux/mm.h>
-#include <asm/uaccess.h>
-#include <asm/page.h>
-#include <linux/vmalloc.h>
-
-
-
-#define __TPD_DEBUG__ 
-
-/*Ctp Power Off In Sleep ? */
-//#define TPD_CLOSE_POWER_IN_SLEEP
-
-/*************************************************************
-**msz xb.pang
-**
-**msg2133,msg2133a,msg2138a Firmware update data transfer select
-**
-**
-** if BB Chip == MT6575,MT7577 , please undef __MSG_DMA_MODE__
-**
-**
-** if BB Chip == MT6589,MT6572 , please define __MSG_DMA_MODE__
-**
-**
-**
-**
-*************************************************************/
-#define __MSG_DMA_MODE__
-
-#ifdef __MSG_DMA_MODE__
-	u8 *g_dma_buff_va = NULL;
-	u8 *g_dma_buff_pa = NULL;
-#endif
-
- 
-extern struct tpd_device *tpd;
-
-/*Use For Get CTP Data By I2C*/ 
-struct i2c_client *msg_i2c_client = NULL;
-
-/*Use For Firmware Update By I2C*/
-//static struct i2c_client     *msg21xx_i2c_client = NULL;
-
-//struct task_struct *thread = NULL;
- 
-static DECLARE_WAIT_QUEUE_HEAD(waiter);
-//static DEFINE_MUTEX(i2c_access);
-
-typedef struct
-{
-    u16 X;
-    u16 Y;
-} TouchPoint_t;
-
-/*CTP Data Package*/
-typedef struct
-{
-    u8 nTouchKeyMode;
-    u8 nTouchKeyCode;
-    u8 nFingerNum;
-    TouchPoint_t Point[MAX_TOUCH_FINGER];
-} TouchScreenInfo_t;
-
- 
-static void tpd_eint_interrupt_handler(void);
-static struct work_struct    msg21xx_wq;
-
-#ifdef TPD_HAVE_BUTTON 
-static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
-static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
-#endif
-
-#if 0
-extern void mt65xx_eint_unmask(unsigned int line);
-extern void mt65xx_eint_mask(unsigned int line);
-extern void mt65xx_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
-extern unsigned int mt65xx_eint_set_sens(unsigned int eint_num, unsigned int sens);
-extern void mt65xx_eint_registration(unsigned int eint_num, unsigned int is_deb_en, unsigned int pol, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-#endif
-
- 
-static int __devinit tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
-static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info);
-static int __devexit tpd_remove(struct i2c_client *client);
-static int touch_event_handler(void *unused);
- 
-
-static int tpd_flag = 0;
-static int tpd_halt=0;
-static int point_num = 0;
-static int p_point_num = 0;
-
-
-
-#define TPD_OK 0
-
- 
- static const struct i2c_device_id msg2133_tpd_id[] = {{"msg2133",0},{}};
-
- static struct i2c_board_info __initdata msg2133_i2c_tpd={ I2C_BOARD_INFO("msg2133", (0x26))};
- 
- 
- static struct i2c_driver tpd_i2c_driver = {
-  .driver = {
-	 .name = "msg2133",//.name = TPD_DEVICE,
-//	 .owner = THIS_MODULE,
-  },
-  .probe = tpd_probe,
-  .remove = __devexit_p(tpd_remove),
-  .id_table = msg2133_tpd_id,
-  .detect = tpd_detect,
-//  .address_data = &addr_data,
- };
- //start for update firmware //msz   for update firmware 20121126
-#define __FIRMWARE_UPDATE__
-#define MSG2133_UPDATE
-
-//#ifdef MSG2133_UPDATE
-#ifdef __FIRMWARE_UPDATE__
-
-#define MSG2133_TS_ADDR			0x26
-#define MSG2133_FW_ADDR			0x62
-#define MSG2133_FW_UPDATE_ADDR   	0x49
-
-static struct i2c_client     *this_client = NULL;
-struct class *firmware_class;
-struct device *firmware_cmd_dev;
-static int update_switch = 0;
-static int FwDataCnt;
-static  char *fw_version;
-static unsigned char temp[94][1024];
-static u8 g_dwiic_info_data[1024];   // Buffer for info data
-
-#ifdef __MSG_DMA_MODE__
-static void msg_dma_alloct()
-{
-	g_dma_buff_va = (u8 *)dma_alloc_coherent(NULL, 4096, &g_dma_buff_pa, GFP_KERNEL);
-    if(!g_dma_buff_va)
-	{
-        TPD_DMESG("[DMA][Error] Allocate DMA I2C Buffer failed!\n");
-    }
-}
-
-static void msg_dma_release()
-{
-	if(g_dma_buff_va)
-	{
-     	dma_free_coherent(NULL, 4096, g_dma_buff_va, g_dma_buff_pa);
-        g_dma_buff_va = NULL;
-        g_dma_buff_pa = NULL;
-		TPD_DMESG("[DMA][release] Allocate DMA I2C Buffer release!\n");
-    }
-}
-#endif
-
-
-static void msg2133_device_power_on()
-{
-	#ifdef TPD_POWER_SOURCE_CUSTOM
-	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
-#else
-	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-#endif
-	TPD_DMESG("msg2133: power on\n");
-}
-
-static void msg2133_reset()
-{
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(10);
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(50);
-	TPD_DMESG(" msg2133 reset\n");
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(150);
-
-}
-
-
-/*static bool msg2133_i2c_read(char *pbt_buf, int dw_lenth)
-{
-    int ret;
-    MSG2133_DBG("The msg_i2c_client->addr=0x%x\n",i2c_client->addr);
-    ret = i2c_master_recv(this_client, pbt_buf, dw_lenth);
-
-    if(ret <= 0){
-        MSG2133_DBG("msg_i2c_read_interface error\n");
-        return false;
-    }
-
-    return true;
-}
-
-static bool msg2133_i2c_write(char *pbt_buf, int dw_lenth)
-{
-    int ret;
-    MSG2133_DBG("The msg_i2c_client->addr=0x%x\n",i2c_client->addr);
-    ret = i2c_master_send(this_client, pbt_buf, dw_lenth);
-
-    if(ret <= 0){
-        MSG2133_DBG("msg_i2c_read_interface error\n");
-        return false;
-    }
-
-    return true;
-}*/
-
-static void HalTscrCReadI2CSeq(u8 addr, u8* read_data, u16 size)
-{
-   //according to your platform.
-   	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = I2C_M_RD,
-			.len = size,
-			#ifdef __MSG_DMA_MODE__
-			.addr = addr & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = addr,
-			.buf = read_data,
-			#endif
-		},
-	};
-
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("HalTscrCReadI2CSeq error %d\n", rc);
-	}
-	#ifdef __MSG_DMA_MODE__
-	else
-	{
-		memcpy(read_data, g_dma_buff_va, size);
-	}
-	#endif
-	
-}
-
-static void HalTscrCDevWriteI2CSeq(u8 addr, u8* data, u16 size)
-{
-    //according to your platform.
-   	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	memcpy(g_dma_buff_va, data, size);
-	#endif
-	
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = 0,
-			.len = size,
-			#ifdef __MSG_DMA_MODE__
-			.addr = addr & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = addr,
-			.buf = data,
-			#endif
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("HalTscrCDevWriteI2CSeq error %d,addr = %d\n", rc,addr);
-	}
-}
-/*
-static bool msg2133_i2c_read(char *pbt_buf, int dw_lenth)
-{
-    int ret;
-    //    pr_ch("The msg_i2c_client->addr=0x%x\n",i2c_client->addr);
-    ret = i2c_master_recv(this_client, pbt_buf, dw_lenth);
-
-    if(ret <= 0)
-    {
-        //pr_tp("msg_i2c_read_interface error\n");
-        return false;
-    }
-
-    return true;
-}
-
-static bool msg2133_i2c_write(char *pbt_buf, int dw_lenth)
-{
-    int ret;
-    //    pr_ch("The msg_i2c_client->addr=0x%x\n",i2c_client->addr);
-    ret = i2c_master_send(this_client, pbt_buf, dw_lenth);
-
-    if(ret <= 0)
-    {
-        //pr_tp("msg_i2c_read_interface error\n");
-        return false;
-    }
-
-    return true;
-}
-*/
-static void i2c_read_msg2133(unsigned char *pbt_buf, int dw_lenth)
-{
-    //this_client->addr = MSG2133_FW_ADDR;
-	//i2c_master_recv(this_client, pbt_buf, dw_lenth);	//0xC5_8bit
-	//this_client->addr = MSG2133_TS_ADDR;
-	   	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			.flags = I2C_M_RD,
-			.len = dw_lenth,
-		#ifdef __MSG_DMA_MODE__
-			.addr = MSG2133_FW_ADDR & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-		#else
-			.addr = MSG2133_FW_ADDR,
-			.buf = pbt_buf,
-		#endif
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("i2c_read_msg2133 error %d,addr = %d\n", rc,MSG2133_FW_ADDR);
-	}
-	#ifdef __MSG_DMA_MODE__
-	else
-	{
-		memcpy(pbt_buf, g_dma_buff_va, dw_lenth);
-	}
-	#endif
-	
-}
-
-static void i2c_write_msg2133(unsigned char *pbt_buf, int dw_lenth)
-{
-
-	//this_client->addr = MSG2133_FW_ADDR;
-	//i2c_master_send(this_client, pbt_buf, dw_lenth);		//0xC4_8bit
-	//this_client->addr = MSG2133_TS_ADDR;
-	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	memcpy(g_dma_buff_va, pbt_buf, dw_lenth);
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = 0,
-			.len = dw_lenth,
-			#ifdef __MSG_DMA_MODE__
-			.addr = MSG2133_FW_ADDR & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = MSG2133_FW_ADDR,
-			.buf = pbt_buf,
-			#endif
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("i2c_write_msg2133 error %d,addr = %d\n", rc,MSG2133_FW_ADDR);
-	}
-}
-
-static void i2c_read_update_msg2133(unsigned char *pbt_buf, int dw_lenth)
-{	
-
-	//this_client->addr = MSG2133_FW_UPDATE_ADDR;
-	//i2c_master_recv(this_client, pbt_buf, dw_lenth);	//0x93_8bit
-	//this_client->addr = MSG2133_TS_ADDR;
-	int rc;
-	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = I2C_M_RD,
-			.len = dw_lenth,
-			#ifdef __MSG_DMA_MODE__
-			.addr = MSG2133_FW_UPDATE_ADDR & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = MSG2133_FW_UPDATE_ADDR,
-			.buf = pbt_buf,
-			#endif
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("i2c_read_update_msg2133 error %d,addr = %d\n", rc,MSG2133_FW_ADDR);
-	}
-	#ifdef __MSG_DMA_MODE__
-	else
-	{
-		memcpy(pbt_buf, g_dma_buff_va, dw_lenth);
-	}
-	#endif
-}
-
-static void i2c_write_update_msg2133(unsigned char *pbt_buf, int dw_lenth)
-{	
-  //  this_client->addr = MSG2133_FW_UPDATE_ADDR;
-	//i2c_master_send(this_client, pbt_buf, dw_lenth);	//0x92_8bit
-	//this_client->addr = MSG2133_TS_ADDR;
-		//this_client->addr = MSG2133_TS_ADDR;
-	int rc;
-  	#ifdef __MSG_DMA_MODE__
-	if (g_dma_buff_va == NULL)
-		return;
-	memcpy(g_dma_buff_va, pbt_buf, dw_lenth);
-	#endif
-	struct i2c_msg msgs[] =
-    {
-		{
-			
-			.flags = 0,
-			.len = dw_lenth,
-			#ifdef __MSG_DMA_MODE__
-			.addr = MSG2133_FW_UPDATE_ADDR & I2C_MASK_FLAG | I2C_DMA_FLAG,
-			.buf = g_dma_buff_pa,
-			#else
-			.addr = MSG2133_FW_UPDATE_ADDR,
-			.buf = pbt_buf,
-			#endif
-			
-		},
-	};
-	rc = i2c_transfer(this_client->adapter, msgs, 1);
-	if( rc < 0 )
-    {
-		printk("i2c_write_update_msg2133 error %d,addr = %d\n", rc,MSG2133_FW_ADDR);
-	}
-}
-
-
-
-void dbbusDWIICEnterSerialDebugMode(void)
-{
-    unsigned char data[5];
-    // Enter the Serial Debug Mode
-    data[0] = 0x53;
-    data[1] = 0x45;
-    data[2] = 0x52;
-    data[3] = 0x44;
-    data[4] = 0x42;
-    i2c_write_msg2133(data, 5);
-}
-
-void dbbusDWIICStopMCU(void)
-{
-    unsigned char data[1];
-    // Stop the MCU
-    data[0] = 0x37;
-    i2c_write_msg2133(data, 1);
-}
-
-void dbbusDWIICIICUseBus(void)
-{
-    unsigned char data[1];
-    // IIC Use Bus
-    data[0] = 0x35;
-    i2c_write_msg2133(data, 1);
-}
-
-void dbbusDWIICIICReshape(void)
-{
-    unsigned char data[1];
-    // IIC Re-shape
-    data[0] = 0x71;
-    i2c_write_msg2133(data, 1);
-}
-
-void dbbusDWIICIICNotUseBus(void)
-{
-    unsigned char data[1];
-    // IIC Not Use Bus
-    data[0] = 0x34;
-    i2c_write_msg2133(data, 1);
-}
-
-void dbbusDWIICNotStopMCU(void)
-{
-    unsigned char data[1];
-    // Not Stop the MCU
-    data[0] = 0x36;
-    i2c_write_msg2133(data, 1);
-}
-
-void dbbusDWIICExitSerialDebugMode(void)
-{
-    unsigned char data[1];
-    // Exit the Serial Debug Mode
-    data[0] = 0x45;
-    i2c_write_msg2133(data, 1);
-    // Delay some interval to guard the next transaction
-}
-
-void drvISP_EntryIspMode(void)
-{
-    unsigned char bWriteData[5] =
-    {
-        0x4D, 0x53, 0x54, 0x41, 0x52
-    };
-    i2c_write_update_msg2133(bWriteData, 5);
-    msleep(10);           // delay about 10ms
-}
-
-void drvISP_WriteEnable(void)
-{
-    unsigned char bWriteData[2] =
-    {
-        0x10, 0x06
-    };
-    unsigned char bWriteData1 = 0x12;
-    i2c_write_update_msg2133(bWriteData, 2);
-    i2c_write_update_msg2133(&bWriteData1, 1);
-}
-
-unsigned char drvISP_Read(unsigned char n, unsigned char *pDataToRead)    //First it needs send 0x11 to notify we want to get flash data back.
-{
-    unsigned char Read_cmd = 0x11;
-    unsigned char i = 0;
-    unsigned char dbbus_rx_data[16] = {0};
-    i2c_write_update_msg2133(&Read_cmd, 1);
-    //if (n == 1)
-    {
-        i2c_read_update_msg2133(&dbbus_rx_data[0], n + 1);
-
-        for(i = 0; i < n; i++)
-        {
-            *(pDataToRead + i) = dbbus_rx_data[i + 1];
-        }
-    }
-    //else
-    {
-        //     i2c_read_update_msg2133(pDataToRead, n);
-    }
-    return 0;
-}
-
-unsigned char drvISP_ReadStatus(void)
-{
-    unsigned char bReadData = 0;
-    unsigned char bWriteData[2] =
-    {
-        0x10, 0x05
-    };
-    unsigned char bWriteData1 = 0x12;
-//    msleep(1);           // delay about 100us
-    i2c_write_update_msg2133(bWriteData, 2);
-//    msleep(1);           // delay about 100us
-    drvISP_Read(1, &bReadData);
-//    msleep(10);           // delay about 10ms
-    i2c_write_update_msg2133(&bWriteData1, 1);
-    return bReadData;
-}
-
-
-
-void drvISP_BlockErase(unsigned int addr)
-{
-    unsigned char bWriteData[5] = { 0x00, 0x00, 0x00, 0x00, 0x00 };
-    unsigned char bWriteData1 = 0x12;
-    unsigned int timeOutCount=0;
-	
-    drvISP_WriteEnable();
-    //Enable write status register
-    bWriteData[0] = 0x10;
-    bWriteData[1] = 0x50;
-    i2c_write_update_msg2133(bWriteData, 2);
-    i2c_write_update_msg2133(&bWriteData1, 1);
-    //Write Status
-    bWriteData[0] = 0x10;
-    bWriteData[1] = 0x01;
-    bWriteData[2] = 0x00;
-    i2c_write_update_msg2133(bWriteData, 3);
-    i2c_write_update_msg2133(&bWriteData1, 1);
-    //Write disable
-    bWriteData[0] = 0x10;
-    bWriteData[1] = 0x04;
-    i2c_write_update_msg2133(bWriteData, 2);
-    i2c_write_update_msg2133(&bWriteData1, 1);
-
-    timeOutCount=0;
-    msleep(1);           // delay about 100us
-    while((drvISP_ReadStatus() & 0x01) == 0x01)
-    {
-        timeOutCount++;
-	 if ( timeOutCount > 10000 ) 
-            break; /* around 1 sec timeout */
-    }
-
-    //pr_ch("The drvISP_ReadStatus3=%d\n", drvISP_ReadStatus());
-    drvISP_WriteEnable();
-    //pr_ch("The drvISP_ReadStatus4=%d\n", drvISP_ReadStatus());
-    bWriteData[0] = 0x10;
-    bWriteData[1] = 0xC7;        //Block Erase
-    //bWriteData[2] = ((addr >> 16) & 0xFF) ;
-    //bWriteData[3] = ((addr >> 8) & 0xFF) ;
-    // bWriteData[4] = (addr & 0xFF) ;
-    i2c_write_update_msg2133(bWriteData, 2);
-    //i2c_write_update_msg2133( &bWriteData, 5);
-    i2c_write_update_msg2133(&bWriteData1, 1);
-
-    timeOutCount=0;
-    msleep(1);           // delay about 100us
-    while((drvISP_ReadStatus() & 0x01) == 0x01)
-    {
-        timeOutCount++;
-	 if ( timeOutCount > 10000 ) 
-            break; /* around 1 sec timeout */
-    }
-}
-
-void drvISP_Program(unsigned short k, unsigned char *pDataToWrite)
-{
-    unsigned short i = 0;
-    unsigned short j = 0;
-    //U16 n = 0;
-    unsigned char TX_data[133];
-    unsigned char bWriteData1 = 0x12;
-    unsigned int addr = k * 1024;
-#if 1
-
-    for(j = 0; j < 8; j++)    //128*8 cycle
-    {
-        TX_data[0] = 0x10;
-        TX_data[1] = 0x02;// Page Program CMD
-        TX_data[2] = (addr + 128 * j) >> 16;
-        TX_data[3] = (addr + 128 * j) >> 8;
-        TX_data[4] = (addr + 128 * j);
-
-        for(i = 0; i < 128; i++)
-        {
-            TX_data[5 + i] = pDataToWrite[j * 128 + i];
-        }
-
-        while((drvISP_ReadStatus() & 0x01) == 0x01)
-        {
-            ;    //wait until not in write operation
-        }
-
-        drvISP_WriteEnable();
-        i2c_write_update_msg2133( TX_data, 133);   //write 133 byte per cycle
-        i2c_write_update_msg2133(&bWriteData1, 1);
-    }
-
-#else
-
-    for(j = 0; j < 512; j++)    //128*8 cycle
-    {
-        TX_data[0] = 0x10;
-        TX_data[1] = 0x02;// Page Program CMD
-        TX_data[2] = (addr + 2 * j) >> 16;
-        TX_data[3] = (addr + 2 * j) >> 8;
-        TX_data[4] = (addr + 2 * j);
-
-        for(i = 0; i < 2; i++)
-        {
-            TX_data[5 + i] = pDataToWrite[j * 2 + i];
-        }
-
-        while((drvISP_ReadStatus() & 0x01) == 0x01)
-        {
-            ;    //wait until not in write operation
-        }
-
-        drvISP_WriteEnable();
-        i2c_write_update_msg2133(TX_data, 7);    //write 7 byte per cycle
-        i2c_write_update_msg2133(&bWriteData1, 1);
-    }
-
-#endif
-}
-
-void drvISP_ExitIspMode(void)
-{
-    unsigned char bWriteData = 0x24;
-    i2c_write_update_msg2133(&bWriteData, 1);
-}
-
-
-static ssize_t firmware_version_show(struct device *dev,
-                                     struct device_attribute *attr, char *buf)
-{
-	printk("tyd-tp: firmware_version_show\n");
-    TPD_DMESG("*** firmware_version_show fw_version = %s***\n", fw_version);
-    return sprintf(buf, "%s\n", fw_version);
-}
-
-static ssize_t firmware_version_store(struct device *dev,
-                                      struct device_attribute *attr, const char *buf, size_t size)
-{
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_alloct();
-	#endif
-    unsigned char dbbus_tx_data[3];
-    unsigned char dbbus_rx_data[4] ;
-    unsigned short major = 0, minor = 0;
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();
-    fw_version = kzalloc(sizeof(char), GFP_KERNEL);
-    TPD_DMESG("\n");
-	TPD_DMESG("tyd-tp: firmware_version_store\n");
-    //Get_Chip_Version();
-    dbbus_tx_data[0] = 0x53;
-    dbbus_tx_data[1] = 0x00;
-    dbbus_tx_data[2] = 0x2a;//0x74--msg2133a;  0x2A----msg2133a
-    //i2c_write(TOUCH_ADDR_MSG20XX, &dbbus_tx_data[0], 3);
-    //i2c_read(TOUCH_ADDR_MSG20XX, &dbbus_rx_data[0], 4);
-//    msg2133_i2c_write(&dbbus_tx_data[0], 3);
-//    msg2133_i2c_read(&dbbus_rx_data[0], 4);
-		HalTscrCDevWriteI2CSeq(this_client->addr, &dbbus_tx_data[0], 3);
-		HalTscrCReadI2CSeq(this_client->addr, &dbbus_rx_data[0], 4);
-    major = (dbbus_rx_data[1] << 8) + dbbus_rx_data[0];
-    minor = (dbbus_rx_data[3] << 8) + dbbus_rx_data[2];
-    TPD_DMESG("***major = %d ***\n", major);
-    TPD_DMESG("***minor = %d ***\n", minor);
-    sprintf(fw_version, "%03d%03d", major, minor);
-    TPD_DMESG("***fw_version = %s ***\n", fw_version);
-	
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_release();
-	#endif
-	
-    return size;
-}
-
-static ssize_t firmware_update_show(struct device *dev,
-                                    struct device_attribute *attr, char *buf)
-{
-	printk("tyd-tp: firmware_update_show\n");
-    return sprintf(buf, "%s\n", fw_version);
-}
-#define _FW_UPDATE_C3_
-
-#define FW_ADDR_MSG21XX   (0xC4>>1)
-#define FW_ADDR_MSG21XX_TP   (0x4C>>1)
-#define FW_UPDATE_ADDR_MSG21XX   (0x92>>1)
-#define TP_DEBUG	printk//(x)		//x
-#define DBUG	printk//(x) //x
-
-#ifdef _FW_UPDATE_C3_
-
-u8  Fmr_Loader[1024];
-    u32 crc_tab[256];
-
-#define _HalTscrHWReset(...) msg2133_reset(__VA_ARGS__)
-//#define disable_irq(...) disable_irq_nosync(__VA_ARGS__)
-
-static ssize_t firmware_update_c2(struct device *dev,struct device_attribute *attr, const char *buf, size_t size)
-{
-    unsigned char i;
-    unsigned char dbbus_tx_data[4];
-    unsigned char dbbus_rx_data[2] = {0};
-    update_switch = 1;
-    //drvISP_EntryIspMode();
-    //drvISP_BlockErase(0x00000);
-    //M by cheehwa _HalTscrHWReset();
-
-    //
-  //  disable_irq_nosync(this_client->irq);
-	
-	msg2133_reset();
-    //msctpc_LoopDelay ( 100 );        // delay about 100ms*****
-    // Enable slave's ISP ECO mode
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();
-    //pr_ch("dbbusDWIICIICReshape\n");
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x08;
-    dbbus_tx_data[2] = 0x0c;
-    dbbus_tx_data[3] = 0x08;
-    // Disable the Watchdog
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Get_Chip_Version();
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x11;
-    dbbus_tx_data[2] = 0xE2;
-    dbbus_tx_data[3] = 0x00;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x60;
-    dbbus_tx_data[3] = 0x55;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //pr_ch("update\n");
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x61;
-    dbbus_tx_data[3] = 0xAA;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Stop MCU
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x0F;
-    dbbus_tx_data[2] = 0xE6;
-    dbbus_tx_data[3] = 0x01;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Enable SPI Pad
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x02;
-    i2c_write_msg2133(dbbus_tx_data, 3);
-    i2c_read_msg2133(&dbbus_rx_data[0], 2);
-    //pr_tp("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = (dbbus_rx_data[0] | 0x20);  //Set Bit 5
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x25;
-    i2c_write_msg2133(dbbus_tx_data, 3);
-    dbbus_rx_data[0] = 0;
-    dbbus_rx_data[1] = 0;
-    i2c_read_msg2133(&dbbus_rx_data[0], 2);
-    //pr_tp("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = dbbus_rx_data[0] & 0xFC;  //Clear Bit 1,0
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    /*
-    //------------
-    // ISP Speed Change to 400K
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x11;
-    dbbus_tx_data[2] = 0xE2;
-    i2c_write_msg2133( dbbus_tx_data, 3);
-    i2c_read_msg2133( &dbbus_rx_data[3], 1);
-    //pr_tp("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = dbbus_tx_data[3]&0xf7;  //Clear Bit3
-    i2c_write_msg2133( dbbus_tx_data, 4);
-    */
-    //WP overwrite
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x0E;
-    dbbus_tx_data[3] = 0x02;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //set pin high
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x10;
-    dbbus_tx_data[3] = 0x08;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbusDWIICIICNotUseBus();
-    dbbusDWIICNotStopMCU();
-    dbbusDWIICExitSerialDebugMode();
-    ///////////////////////////////////////
-    // Start to load firmware
-    ///////////////////////////////////////
-    drvISP_EntryIspMode();
-    TPD_DMESG("entryisp\n");
-    drvISP_BlockErase(0x00000);
-    //msleep(1000);
-    TPD_DMESG("FwVersion=2");
-
-    for(i = 0; i < 94; i++)    // total  94 KB : 1 byte per R/W
-    {
-        //msleep(1);//delay_100us
-        TPD_DMESG("drvISP_Program\n");
-        drvISP_Program(i, temp[i]);    // program to slave's flash
-        //pr_ch("drvISP_Verify\n");
-        //drvISP_Verify ( i, temp[i] ); //verify data
-    }
-
-    //MSG2133_DBG("update OK\n");
-    drvISP_ExitIspMode();
-    FwDataCnt = 0;
-    msg2133_reset();
-    TPD_DMESG("update OK\n");
-    update_switch = 0;
-    //
-    enable_irq(this_client->irq);
-    return size;
-}
-
-static u32 Reflect ( u32 ref, char ch ) //unsigned int Reflect(unsigned int ref, char ch)
-{
-    u32 value = 0;
-    u32 i = 0;
-
-    for ( i = 1; i < ( ch + 1 ); i++ )
-    {
-        if ( ref & 1 )
-        {
-            value |= 1 << ( ch - i );
-        }
-        ref >>= 1;
-    }
-    return value;
-}
-
-u32 Get_CRC ( u32 text, u32 prevCRC, u32 *crc32_table )
-{
-    u32  ulCRC = prevCRC;
-	ulCRC = ( ulCRC >> 8 ) ^ crc32_table[ ( ulCRC & 0xFF ) ^ text];
-    return ulCRC ;
-}
-static void Init_CRC32_Table ( u32 *crc32_table )
-{
-    u32 magicnumber = 0x04c11db7;
-    u32 i = 0, j;
-
-    for ( i = 0; i <= 0xFF; i++ )
-    {
-        crc32_table[i] = Reflect ( i, 8 ) << 24;
-        for ( j = 0; j < 8; j++ )
-        {
-            crc32_table[i] = ( crc32_table[i] << 1 ) ^ ( crc32_table[i] & ( 0x80000000L ) ? magicnumber : 0 );
-        }
-        crc32_table[i] = Reflect ( crc32_table[i], 32 );
-    }
-}
-
-typedef enum
-{
-	EMEM_ALL = 0,
-	EMEM_MAIN,
-	EMEM_INFO,
-} EMEM_TYPE_t;
-
-static void drvDB_WriteReg8Bit ( u8 bank, u8 addr, u8 data )
-{
-    u8 tx_data[4] = {0x10, bank, addr, data};
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 4 );
-}
-
-static void drvDB_WriteReg ( u8 bank, u8 addr, u16 data )
-{
-    u8 tx_data[5] = {0x10, bank, addr, data & 0xFF, data >> 8};
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 5 );
-}
-
-static unsigned short drvDB_ReadReg ( u8 bank, u8 addr )
-{
-    u8 tx_data[3] = {0x10, bank, addr};
-    u8 rx_data[2] = {0};
-
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 3 );
-    HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &rx_data[0], 2 );
-    return ( rx_data[1] << 8 | rx_data[0] );
-}
-
-static int drvTP_erase_emem_c32 ( void )
-{
-    /////////////////////////
-    //Erase  all
-    /////////////////////////
-    
-    //enter gpio mode
-    drvDB_WriteReg ( 0x16, 0x1E, 0xBEAF );
-
-    // before gpio mode, set the control pin as the orginal status
-    drvDB_WriteReg ( 0x16, 0x08, 0x0000 );
-    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
-    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
-
-    // ptrim = 1, h'04[2]
-    drvDB_WriteReg8Bit ( 0x16, 0x08, 0x04 );
-    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
-    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
-
-    // ptm = 6, h'04[12:14] = b'110
-    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x60 );
-    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
-
-    // pmasi = 1, h'04[6]
-    drvDB_WriteReg8Bit ( 0x16, 0x08, 0x44 );
-    // pce = 1, h'04[11]
-    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x68 );
-    // perase = 1, h'04[7]
-    drvDB_WriteReg8Bit ( 0x16, 0x08, 0xC4 );
-    // pnvstr = 1, h'04[5]
-    drvDB_WriteReg8Bit ( 0x16, 0x08, 0xE4 );
-    // pwe = 1, h'04[9]
-    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x6A );
-    // trigger gpio load
-    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
-
-    return ( 1 );
-}
-
-static ssize_t firmware_update_c32 ( struct device *dev, struct device_attribute *attr,
-                                     const char *buf, size_t size,  EMEM_TYPE_t emem_type )
-{
-    u8  dbbus_tx_data[4];
-    u8  dbbus_rx_data[2] = {0};
-      // Buffer for slave's firmware
-
-    u32 i, j, k;
-    u32 crc_main, crc_main_tp;
-    u32 crc_info, crc_info_tp;
-    u16 reg_data = 0;
-
-    crc_main = 0xffffffff;
-    crc_info = 0xffffffff;
-
-#if 1
-    /////////////////////////
-    // Erase  all
-    /////////////////////////
-    drvTP_erase_emem_c32();
-    mdelay ( 1000 ); //MCR_CLBK_DEBUG_DELAY ( 1000, MCU_LOOP_DELAY_COUNT_MS );
-
-    //ResetSlave();
-    _HalTscrHWReset();
-    //drvDB_EnterDBBUS();
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();
-    mdelay ( 300 );
-
-    // Reset Watchdog
-    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
-    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
-
-    /////////////////////////
-    // Program
-    /////////////////////////
-
-    //polling 0x3CE4 is 0x1C70
-    do
-    {
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-    }
-    while ( reg_data != 0x1C70 );
-
-
-    drvDB_WriteReg ( 0x3C, 0xE4, 0xE38F );  // for all-blocks
-
-    //polling 0x3CE4 is 0x2F43
-    do
-    {
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-    }
-    while ( reg_data != 0x2F43 );
-
-
-    //calculate CRC 32
-    Init_CRC32_Table ( &crc_tab[0] );
-
-    for ( i = 0; i < 33; i++ ) // total  33 KB : 2 byte per R/W
-    {
-        if ( i < 32 )   //emem_main
-        {
-            if ( i == 31 )
-            {
-                temp[i][1014] = 0x5A; //Fmr_Loader[1014]=0x5A;
-                temp[i][1015] = 0xA5; //Fmr_Loader[1015]=0xA5;
-
-                for ( j = 0; j < 1016; j++ )
-                {
-                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
-                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
-                }
-            }
-            else
-            {
-                for ( j = 0; j < 1024; j++ )
-                {
-                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
-                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
-                }
-            }
-        }
-        else  // emem_info
-        {
-            for ( j = 0; j < 1024; j++ )
-            {
-                //crc_info=Get_CRC(Fmr_Loader[j],crc_info,&crc_tab[0]);
-                crc_info = Get_CRC ( temp[i][j], crc_info, &crc_tab[0] );
-            }
-        }
-
-        //drvDWIIC_MasterTransmit( DWIIC_MODE_DWIIC_ID, 1024, Fmr_Loader );
-        //HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i], 1024 );
-		for(k=0; k<8; k++)
-        {
-        	//HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[i*128], 128 );
-        	HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &temp[i][k*128], 128 );
-			TPD_DMESG ( "firmware_update_c32---g_dwiic_info_data[i*128]: %d\n", i );
-			mdelay(50);
-        }
-        // polling 0x3CE4 is 0xD0BC
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-        }
-        while ( reg_data != 0xD0BC );
-
-        drvDB_WriteReg ( 0x3C, 0xE4, 0x2F43 );
-    }
-
-    //write file done
-    drvDB_WriteReg ( 0x3C, 0xE4, 0x1380 );
-
-    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
-    // polling 0x3CE4 is 0x9432
-    do
-    {
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-    }
-    while ( reg_data != 0x9432 );
-
-    crc_main = crc_main ^ 0xffffffff;
-    crc_info = crc_info ^ 0xffffffff;
-
-    // CRC Main from TP
-    crc_main_tp = drvDB_ReadReg ( 0x3C, 0x80 );
-    crc_main_tp = ( crc_main_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
- 
-    //CRC Info from TP
-    crc_info_tp = drvDB_ReadReg ( 0x3C, 0xA0 );
-    crc_info_tp = ( crc_info_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0xA2 );
-
-    TPD_DMESG ( "crc_main=0x%x, crc_info=0x%x, crc_main_tp=0x%x, crc_info_tp=0x%x\n",
-               crc_main, crc_info, crc_main_tp, crc_info_tp );
-
-    //drvDB_ExitDBBUS();
-    if ( ( crc_main_tp != crc_main ) || ( crc_info_tp != crc_info ) )
-    {
-        TPD_DMESG ( "update FAILED\n" );
-		_HalTscrHWReset();
-        FwDataCnt = 0;
-    	enable_irq(this_client->irq);		
-        return ( 0 );
-    }
-
-    TPD_DMESG ( "update OK\n" );
-	_HalTscrHWReset();
-    FwDataCnt = 0;
-	enable_irq(this_client->irq);
-
-    return size;
-#endif
-}
-
-static int drvTP_erase_emem_c33 ( EMEM_TYPE_t emem_type )
-{
-    // stop mcu
-    drvDB_WriteReg ( 0x0F, 0xE6, 0x0001 );
-
-    //disable watch dog
-    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
-    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
-
-    // set PROGRAM password
-    drvDB_WriteReg8Bit ( 0x16, 0x1A, 0xBA );
-    drvDB_WriteReg8Bit ( 0x16, 0x1B, 0xAB );
-
-    //proto.MstarWriteReg(F1.loopDevice, 0x1618, 0x80);
-    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x80 );
-
-    if ( emem_type == EMEM_ALL )
-    {
-        drvDB_WriteReg8Bit ( 0x16, 0x08, 0x10 ); //mark
-    }
-
-    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x40 );
-    mdelay ( 10 );
-
-    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x80 );
-
-    // erase trigger
-    if ( emem_type == EMEM_MAIN )
-    {
-        drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x04 ); //erase main
-    }
-    else
-    {
-        drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x08 ); //erase all block
-    }
-
-    return ( 1 );
-}
-
-static int drvTP_read_emem_dbbus_c33 ( EMEM_TYPE_t emem_type, u16 addr, size_t size, u8 *p, size_t set_pce_high )
-{
-    u32 i;
-
-    // Set the starting address ( must before enabling burst mode and enter riu mode )
-    drvDB_WriteReg ( 0x16, 0x00, addr );
-
-    // Enable the burst mode ( must before enter riu mode )
-    drvDB_WriteReg ( 0x16, 0x0C, drvDB_ReadReg ( 0x16, 0x0C ) | 0x0001 );
-
-    // Set the RIU password
-    drvDB_WriteReg ( 0x16, 0x1A, 0xABBA );
-
-    // Enable the information block if pifren is HIGH
-    if ( emem_type == EMEM_INFO )
-    {
-        // Clear the PCE
-        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0080 );
-        mdelay ( 10 );
-
-        // Set the PIFREN to be HIGH
-        drvDB_WriteReg ( 0x16, 0x08, 0x0010 );
-    }
-
-    // Set the PCE to be HIGH
-    drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
-    mdelay ( 10 );
-
-    // Wait pce becomes 1 ( read data ready )
-    while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
-
-    for ( i = 0; i < size; i += 4 )
-    {
-        // Fire the FASTREAD command
-        drvDB_WriteReg ( 0x16, 0x0E, drvDB_ReadReg ( 0x16, 0x0E ) | 0x0001 );
-
-        // Wait the operation is done
-        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0001 ) != 0x0001 );
-
-        p[i + 0] = drvDB_ReadReg ( 0x16, 0x04 ) & 0xFF;
-        p[i + 1] = ( drvDB_ReadReg ( 0x16, 0x04 ) >> 8 ) & 0xFF;
-        p[i + 2] = drvDB_ReadReg ( 0x16, 0x06 ) & 0xFF;
-        p[i + 3] = ( drvDB_ReadReg ( 0x16, 0x06 ) >> 8 ) & 0xFF;
-    }
-
-    // Disable the burst mode
-    drvDB_WriteReg ( 0x16, 0x0C, drvDB_ReadReg ( 0x16, 0x0C ) & ( ~0x0001 ) );
-
-    // Clear the starting address
-    drvDB_WriteReg ( 0x16, 0x00, 0x0000 );
-
-    //Always return to main block
-    if ( emem_type == EMEM_INFO )
-    {
-        // Clear the PCE before change block
-        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0080 );
-        mdelay ( 10 );
-        // Set the PIFREN to be LOW
-        drvDB_WriteReg ( 0x16, 0x08, drvDB_ReadReg ( 0x16, 0x08 ) & ( ~0x0010 ) );
-
-        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
-        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
-    }
-
-    // Clear the RIU password
-    drvDB_WriteReg ( 0x16, 0x1A, 0x0000 );
-
-    if ( set_pce_high )
-    {
-        // Set the PCE to be HIGH before jumping back to e-flash codes
-        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
-        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
-    }
-
-    return ( 1 );
-}
-
-
-static int drvTP_read_info_dwiic_c33 ( void )
-{
-    u8  dwiic_tx_data[5];
-    u8  dwiic_rx_data[4];
-    u16 reg_data=0;
-    mdelay ( 300 );
-
-    // Stop Watchdog
-    TPD_DMESG ("drvTP_read_info_dwiic_c33---1 \n");
-    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
-    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---2 \n");
-
-    drvDB_WriteReg ( 0x3C, 0xE4, 0xA4AB );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---3 \n");
-
-	drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---4 \n");
-
-    // TP SW reset
-    drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
-	mdelay ( 100 );
-    dwiic_tx_data[0] = 0x10;
-    dwiic_tx_data[1] = 0x0F;
-    dwiic_tx_data[2] = 0xE6;
-    dwiic_tx_data[3] = 0x00;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dwiic_tx_data, 4 );	
-    mdelay ( 100 );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---5 \n");
-
-    do{
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-    }
-    while ( reg_data != 0x5B58 );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---6 \n");
-
-    dwiic_tx_data[0] = 0x72;
-    dwiic_tx_data[1] = 0x80;
-    dwiic_tx_data[2] = 0x00;
-    dwiic_tx_data[3] = 0x04;
-    dwiic_tx_data[4] = 0x00;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , dwiic_tx_data, 5 );
-
-    mdelay ( 50 );
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---7 \n");
-
-    // recive info data
-    
-    for(reg_data=0;reg_data<8;reg_data++)
-    {
-		TPD_DMESG ("drvTP_read_info_dwiic_c33---8---ADDR \n");
-		 dwiic_tx_data[1] = 0x80+(((reg_data*128)&0xff00)>>8);            // address High
-         dwiic_tx_data[2] = (reg_data*128)&0x00ff;                                   // address low
-         HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , dwiic_tx_data, 5 );
-         mdelay (10 );
-		 TPD_DMESG ("drvTP_read_info_dwiic_c33---8---READ START\n");
-    	// recive info data
-         HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX_TP, &g_dwiic_info_data[reg_data*128], 128);
-		mdelay (200 );
-		TPD_DMESG ("drvTP_read_info_dwiic_c33---8---READ END \n");
-    }
-
-	
-	TPD_DMESG ("drvTP_read_info_dwiic_c33---8 \n");
-
-    return ( 1 );
-}
-
-static int drvTP_info_updata_C33 ( u16 start_index, u8 *data, u16 size )
-{
-    // size != 0, start_index+size !> 1024
-    u16 i;
-    for ( i = 0; i < size; i++ )
-    {
-        g_dwiic_info_data[start_index] = * ( data + i );
-        start_index++;
-    }
-    return ( 1 );
-}
-
-static ssize_t firmware_update_c33 ( struct device *dev, struct device_attribute *attr,
-                                     const char *buf, size_t size, EMEM_TYPE_t emem_type )
-{
-    u8  dbbus_tx_data[4];
-    u8  dbbus_rx_data[2] = {0};
-    u8  life_counter[2];
-    u32 i, j, k;
-    u32 crc_main, crc_main_tp;
-    u32 crc_info, crc_info_tp;
-  
-    int update_pass = 1;
-    u16 reg_data = 0;
-
-    crc_main = 0xffffffff;
-    crc_info = 0xffffffff;
-
-    drvTP_read_info_dwiic_c33();
-	
-    if ( g_dwiic_info_data[0] == 'M' && g_dwiic_info_data[1] == 'S' && g_dwiic_info_data[2] == 'T' && g_dwiic_info_data[3] == 'A' && g_dwiic_info_data[4] == 'R' && g_dwiic_info_data[5] == 'T' && g_dwiic_info_data[6] == 'P' && g_dwiic_info_data[7] == 'C' )
-    {
-        // updata FW Version
-        //drvTP_info_updata_C33 ( 8, &temp[32][8], 5 );
-
-		g_dwiic_info_data[8]=temp[32][8];
-		g_dwiic_info_data[9]=temp[32][9];
-		g_dwiic_info_data[10]=temp[32][10];
-		g_dwiic_info_data[11]=temp[32][11];
-        // updata life counter
-        life_counter[1] = (( ( (g_dwiic_info_data[13] << 8 ) | g_dwiic_info_data[12]) + 1 ) >> 8 ) & 0xFF;
-        life_counter[0] = ( ( (g_dwiic_info_data[13] << 8 ) | g_dwiic_info_data[12]) + 1 ) & 0xFF;
-		g_dwiic_info_data[12]=life_counter[0];
-		g_dwiic_info_data[13]=life_counter[1];
-		TPD_DMESG ( "life_counter[0]=%d life_counter[1]=%d\n",life_counter[0],life_counter[1] );
-        //drvTP_info_updata_C33 ( 10, &life_counter[0], 3 );
-        drvDB_WriteReg ( 0x3C, 0xE4, 0x78C5 );
-		drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
-        // TP SW reset
-        drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
-
-        mdelay ( 50 );
-
-        //polling 0x3CE4 is 0x2F43
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-
-        }
-        while ( reg_data != 0x2F43 );
-
-        // transmit lk info data---xb.pang for 1024
-        //HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[0], 1024 );
-		for(i=0;i<8;i++)
-        {
-        	HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[i*128], 128 );
-			TPD_DMESG ( "HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[%*128], 128 ); \n", i);
-			mdelay(50);
-        }
-        //polling 0x3CE4 is 0xD0BC
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-        }
-        while ( reg_data != 0xD0BC );
-
-    }
-
-    //erase main
-    drvTP_erase_emem_c33 ( EMEM_MAIN );
-    mdelay ( 1000 );
-
-    //ResetSlave();
-    _HalTscrHWReset();
-
-    //drvDB_EnterDBBUS();
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();
-    mdelay ( 300 );
-
-    /////////////////////////
-    // Program
-    /////////////////////////
-
-    //polling 0x3CE4 is 0x1C70
-    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-        }
-        while ( reg_data != 0x1C70 );
-    }
-
-    switch ( emem_type )
-    {
-        case EMEM_ALL:
-            drvDB_WriteReg ( 0x3C, 0xE4, 0xE38F );  // for all-blocks
-            break;
-        case EMEM_MAIN:
-            drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for main block
-            break;
-        case EMEM_INFO:
-            drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for info block
-
-            drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x01 );
-
-            drvDB_WriteReg8Bit ( 0x3C, 0xE4, 0xC5 ); //
-            drvDB_WriteReg8Bit ( 0x3C, 0xE5, 0x78 ); //
-
-            drvDB_WriteReg8Bit ( 0x1E, 0x04, 0x9F );
-            drvDB_WriteReg8Bit ( 0x1E, 0x05, 0x82 );
-
-            drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x00 );
-            mdelay ( 100 );
-            break;
-    }
-
-    // polling 0x3CE4 is 0x2F43
-    do
-    {
-        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-    }
-    while ( reg_data != 0x2F43 );
-
-    // calculate CRC 32
-    Init_CRC32_Table ( &crc_tab[0] );
-
-    for ( i = 0; i < 33; i++ ) // total  33 KB : 2 byte per R/W
-    {
-        if ( emem_type == EMEM_INFO )
-			i = 32;
-
-        if ( i < 32 )   //emem_main
-        {
-            if ( i == 31 )
-            {
-                temp[i][1014] = 0x5A; //Fmr_Loader[1014]=0x5A;
-                temp[i][1015] = 0xA5; //Fmr_Loader[1015]=0xA5;
-
-                for ( j = 0; j < 1016; j++ )
-                {
-                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
-                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
-                }
-            }
-            else
-            {
-                for ( j = 0; j < 1024; j++ )
-                {
-                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
-                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
-                }
-            }
-        }
-        else  //emem_info
-        {
-            for ( j = 0; j < 1024; j++ )
-            {
-                //crc_info=Get_CRC(Fmr_Loader[j],crc_info,&crc_tab[0]);
-                crc_info = Get_CRC ( g_dwiic_info_data[j], crc_info, &crc_tab[0] );
-            }
-            if ( emem_type == EMEM_MAIN ) break;
-        }
-
-        //drvDWIIC_MasterTransmit( DWIIC_MODE_DWIIC_ID, 1024, Fmr_Loader );
-        //HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i], 1024 );
-		for(k=0; k<8; k++)
-        {
-        	HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &temp[i][k*128], 128 );
-			TPD_DMESG ( "temp[i] \n");
-			mdelay(50);
-        }
-        // polling 0x3CE4 is 0xD0BC
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-        }
-        while ( reg_data != 0xD0BC );
-
-        drvDB_WriteReg ( 0x3C, 0xE4, 0x2F43 );
-    }
-
-    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        // write file done and check crc
-        drvDB_WriteReg ( 0x3C, 0xE4, 0x1380 );
-    }
-    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
-
-    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        // polling 0x3CE4 is 0x9432
-        do
-        {
-            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
-			TPD_DMESG("polling \n");
-        }while ( reg_data != 0x9432 );
-    }
-
-    crc_main = crc_main ^ 0xffffffff;
-    crc_info = crc_info ^ 0xffffffff;
-
-    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        // CRC Main from TP
-        crc_main_tp = drvDB_ReadReg ( 0x3C, 0x80 );
-        crc_main_tp = ( crc_main_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
-
-        // CRC Info from TP
-        crc_info_tp = drvDB_ReadReg ( 0x3C, 0xA0 );
-        crc_info_tp = ( crc_info_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0xA2 );
-    }
-    TPD_DMESG ( "crc_main=0x%x, crc_info=0x%x, crc_main_tp=0x%x, crc_info_tp=0x%x\n",
-               crc_main, crc_info, crc_main_tp, crc_info_tp );
-
-    //drvDB_ExitDBBUS();
-
-    update_pass = 1;
-	if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
-    {
-        if ( crc_main_tp != crc_main )
-            update_pass = 0;
-
-        if ( crc_info_tp != crc_info )
-            update_pass = 0;
-    }
-
-    if ( !update_pass )
-    {
-        TPD_DMESG ( "update FAILED\n" );
-		_HalTscrHWReset();
-        FwDataCnt = 0;
-    	enable_irq(this_client->irq);
-        return ( 0 );
-    }
-
-    TPD_DMESG ( "update OK\n" );
-	_HalTscrHWReset();
-    FwDataCnt = 0;
-    enable_irq(this_client->irq);
-    return size;
-}
-
-static ssize_t firmware_update_store ( struct device *dev,
-                                       struct device_attribute *attr, const char *buf, size_t size )
-{
-    u8 i;
-    u8 dbbus_tx_data[4];
-    unsigned char dbbus_rx_data[2] = {0};
-	//disable_irq(this_client->irq);
-#ifdef __MSG_DMA_MODE__
-	msg_dma_alloct();
-#endif
-    _HalTscrHWReset();
-
-    // Erase TP Flash first
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();
-    mdelay ( 300 );
-
-    // Disable the Watchdog
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x60;
-    dbbus_tx_data[3] = 0x55;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x61;
-    dbbus_tx_data[3] = 0xAA;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
-    // Stop MCU
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x0F;
-    dbbus_tx_data[2] = 0xE6;
-    dbbus_tx_data[3] = 0x01;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
-    /////////////////////////
-    // Difference between C2 and C3
-    /////////////////////////
-	// c2:2133 c32:2133a(2) c33:2138
-    //check id
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0xCC;
-    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
-    HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
-    if ( dbbus_rx_data[0] == 2 )//update for 21XXA
-    {
-        // check version
-        dbbus_tx_data[0] = 0x10;
-        dbbus_tx_data[1] = 0x3C;
-        dbbus_tx_data[2] = 0xEA;
-        HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
-        HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
-        TPD_DMESG ( "dbbus_rx version[0]=0x%x", dbbus_rx_data[0] );
-
-        if ( dbbus_rx_data[0] == 3 )//update for 21XXA u03
-		{
-             firmware_update_c33 ( dev, attr, buf, size, EMEM_MAIN );
-		}
-        else//update for 21XXA U02
-		{
-             firmware_update_c32 ( dev, attr, buf, size, EMEM_ALL );
-        }
-    }
-    else//update for 21XX
-    {
-         firmware_update_c2 ( dev, attr, buf, size );
-    } 
-
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_release();
-	#endif
-
-	return 1;
-}
-#endif //endif _FW_UPDATE_C3_
-
-static ssize_t firmware_data_show(struct device *dev,
-                                  struct device_attribute *attr, char *buf)
-{
-	TPD_DMESG("tyd-tp: firmware_data_show\n");
-    return FwDataCnt;
-}
-
-static ssize_t firmware_data_store(struct device *dev,
-                                   struct device_attribute *attr, const char *buf, size_t size)
-{
-    int i;
-    TPD_DMESG("***FwDataCnt = %d ***\n", FwDataCnt);
-	TPD_DMESG("tyd-tp: firmware_data_store\n");
-   // for(i = 0; i < 1024; i++)
-    {
-        memcpy(temp[FwDataCnt], buf, 1024);
-    }
-
-    FwDataCnt++;
-    return size;
-}
-
-static ssize_t firmware_clear_show(struct device *dev,
-                                   struct device_attribute *attr, char *buf)
-{
-    unsigned short k = 0, i = 0, j = 0;
-    unsigned char bWriteData[5] =
-    {
-        0x10, 0x03, 0, 0, 0
-    };
-    unsigned char RX_data[256];
-    unsigned char bWriteData1 = 0x12;
-    unsigned int addr = 0;
-    TPD_DMESG("\n");
-	TPD_DMESG("tyd-tp: firmware_clear_show\n");
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_alloct();
-	#endif
-    for(k = 0; k < 94; i++)    // total  94 KB : 1 byte per R/W
-    {
-        addr = k * 1024;
-
-        for(j = 0; j < 8; j++)    //128*8 cycle
-        {
-            bWriteData[2] = (unsigned char)((addr + j * 128) >> 16);
-            bWriteData[3] = (unsigned char)((addr + j * 128) >> 8);
-            bWriteData[4] = (unsigned char)(addr + j * 128);
-
-            while((drvISP_ReadStatus() & 0x01) == 0x01)
-            {
-                ;    //wait until not in write operation
-            }
-
-            i2c_write_update_msg2133(bWriteData, 5);     //write read flash addr
-            drvISP_Read(128, RX_data);
-            i2c_write_update_msg2133(&bWriteData1, 1);    //cmd end
-
-            for(i = 0; i < 128; i++)    //log out if verify error{
-                if(RX_data[i] != 0xFF){
-                    TPD_DMESG("k=%d,j=%d,i=%d===============erase not clean================", k, j, i);
-                }
-            }
-     }
-    TPD_DMESG("read finish\n");
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_release();
-	#endif
-    return sprintf(buf, "%s\n", fw_version);
-}
-
-static ssize_t firmware_clear_store(struct device *dev,
-                                    struct device_attribute *attr, const char *buf, size_t size)
-{
-    unsigned char dbbus_tx_data[4];
-    unsigned char dbbus_rx_data[2] = {0};
-    //msctpc_LoopDelay ( 100 );        // delay about 100ms*****
-    // Enable slave's ISP ECO mode
-    /*
-    dbbusDWIICEnterSerialDebugMode();
-    dbbusDWIICStopMCU();
-    dbbusDWIICIICUseBus();
-    dbbusDWIICIICReshape();*/
-    #ifdef __MSG_DMA_MODE__
-	msg_dma_alloct();
-	#endif
-    TPD_DMESG("\n");
-	TPD_DMESG("tyd-tp: firmware_clear_store\n");
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x08;
-    dbbus_tx_data[2] = 0x0c;
-    dbbus_tx_data[3] = 0x08;
-    // Disable the Watchdog
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Get_Chip_Version();
-    //FwVersion  = 2;
-    //if (FwVersion  == 2)
-    {
-        dbbus_tx_data[0] = 0x10;
-        dbbus_tx_data[1] = 0x11;
-        dbbus_tx_data[2] = 0xE2;
-        dbbus_tx_data[3] = 0x00;
-        i2c_write_msg2133(dbbus_tx_data, 4);
-    }
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x60;
-    dbbus_tx_data[3] = 0x55;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x3C;
-    dbbus_tx_data[2] = 0x61;
-    dbbus_tx_data[3] = 0xAA;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Stop MCU
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x0F;
-    dbbus_tx_data[2] = 0xE6;
-    dbbus_tx_data[3] = 0x01;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //Enable SPI Pad
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x02;
-    i2c_write_msg2133(dbbus_tx_data, 3);
-    i2c_read_msg2133(&dbbus_rx_data[0], 2);
-    TPD_DMESG("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = (dbbus_rx_data[0] | 0x20);  //Set Bit 5
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x25;
-    i2c_write_msg2133(dbbus_tx_data, 3);
-    dbbus_rx_data[0] = 0;
-    dbbus_rx_data[1] = 0;
-    i2c_read_msg2133(&dbbus_rx_data[0], 2);
-    TPD_DMESG("dbbus_rx_data[0]=0x%x", dbbus_rx_data[0]);
-    dbbus_tx_data[3] = dbbus_rx_data[2] & 0xFC;  //Clear Bit 1,0
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //WP overwrite
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x0E;
-    dbbus_tx_data[3] = 0x02;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    //set pin high
-    dbbus_tx_data[0] = 0x10;
-    dbbus_tx_data[1] = 0x1E;
-    dbbus_tx_data[2] = 0x10;
-    dbbus_tx_data[3] = 0x08;
-    i2c_write_msg2133(dbbus_tx_data, 4);
-    dbbusDWIICIICNotUseBus();
-    dbbusDWIICNotStopMCU();
-    dbbusDWIICExitSerialDebugMode();
-    ///////////////////////////////////////
-    // Start to load firmware
-    ///////////////////////////////////////
-    drvISP_EntryIspMode();
-    TPD_DMESG("chip erase+\n");
-    drvISP_BlockErase(0x00000);
-    TPD_DMESG("chip erase-\n");
-    drvISP_ExitIspMode();
-	#ifdef __MSG_DMA_MODE__
-	msg_dma_release();
-	#endif
-    return size;
-}
-
-static DEVICE_ATTR(version, 0777, firmware_version_show, firmware_version_store);
-static DEVICE_ATTR(update, 0777, firmware_update_show, firmware_update_store);
-static DEVICE_ATTR(data, 0777, firmware_data_show, firmware_data_store);
-static DEVICE_ATTR(clear, 0777, firmware_clear_show, firmware_clear_store);
-
-void msg2133_init_class()
-{
-	firmware_class = class_create(THIS_MODULE,"ms-touchscreen-msg20xx" );//client->name
-
-	if(IS_ERR(firmware_class))
-		pr_err("Failed to create class(firmware)!\n");
-
-	firmware_cmd_dev = device_create(firmware_class,
-	                                     NULL, 0, NULL, "device");//device
-
-	if(IS_ERR(firmware_cmd_dev))
-		pr_err("Failed to create device(firmware_cmd_dev)!\n");
-		
-	// version /sys/class/mtk-tpd/device/version
-	if(device_create_file(firmware_cmd_dev, &dev_attr_version) < 0)
-		pr_err("Failed to create device file(%s)!\n", dev_attr_version.attr.name);
-
-	// update /sys/class/mtk-tpd/device/update
-	if(device_create_file(firmware_cmd_dev, &dev_attr_update) < 0)
-		pr_err("Failed to create device file(%s)!\n", dev_attr_update.attr.name);
-
-	// data /sys/class/mtk-tpd/device/data
-	if(device_create_file(firmware_cmd_dev, &dev_attr_data) < 0)
-		pr_err("Failed to create device file(%s)!\n", dev_attr_data.attr.name);
-
-	// clear /sys/class/mtk-tpd/device/clear
-	if(device_create_file(firmware_cmd_dev, &dev_attr_clear) < 0)
-		pr_err("Failed to create device file(%s)!\n", dev_attr_clear.attr.name);
-}
-
-#endif //endif __FIRMWARE_UPDATE__ MSG2133_UPDATE
-
-//end for update firmware
-
- static u8 Calculate_8BitsChecksum( u8 *msg, s32 s32Length )
- {
-	 s32 s32Checksum = 0;
-	 s32 i;
- 
-	 for( i = 0 ; i < s32Length; i++ )
-	 {
-		 s32Checksum += msg[i];
-	 }
- 
-	 return ( u8 )( ( -s32Checksum ) & 0xFF );
- }
-
- static int tpd_touchinfo(TouchScreenInfo_t *touchData)
- {
-
-    u8 val[8] = {0};
-    u8 Checksum = 0;
-    u8 i;
-    u32 delta_x = 0, delta_y = 0;
-    u32 u32X = 0;
-    u32 u32Y = 0;
-    
-
-    TPD_DEBUG(KERN_ERR "[msg2133]==tpd_touchinfo() \n");
-
-
-#ifdef SWAP_X_Y
-    int tempx;
-    int tempy;
-#endif
-
-    /*Get Touch Raw Data*/
-    i2c_master_recv( msg_i2c_client, &val[0], REPORT_PACKET_LENGTH );
-    TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--val[0]:%x, REPORT_PACKET_LENGTH:%x \n",val[0], REPORT_PACKET_LENGTH);
-    Checksum = Calculate_8BitsChecksum( &val[0], 7 ); //calculate checksum
-    TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--Checksum:%x, val[7]:%x, val[0]:%x \n",Checksum, val[7], val[0]);
-
-    if( ( Checksum == val[7] ) && ( val[0] == 0x52 ) ) //check the checksum  of packet
-    {
-        u32X = ( ( ( val[1] & 0xF0 ) << 4 ) | val[2] );   //parse the packet to coordinates
-        u32Y = ( ( ( val[1] & 0x0F ) << 8 ) | val[3] );
-
-        delta_x = ( ( ( val[4] & 0xF0 ) << 4 ) | val[5] );
-        delta_y = ( ( ( val[4] & 0x0F ) << 8 ) | val[6] );
-		TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--u32X:%d, u32Y:%d, delta_x:%d, delta_y:%d \n",u32X, u32Y,delta_x, delta_y);
-
-#ifdef SWAP_X_Y
-        tempy = u32X;
-        tempx = u32Y;
-        u32X = tempx;
-        u32Y = tempy;
-
-        tempy = delta_x;
-        tempx = delta_y;
-        delta_x = tempx;
-        delta_y = tempy;
-#endif
-#ifdef REVERSE_X
-        u32X = 2047 - u32X;
-        delta_x = 4095 - delta_x;
-#endif
-#ifdef REVERSE_Y
-        u32Y = 2047 - u32Y;
-        delta_y = 4095 - delta_y;
-#endif
-
-		TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--u32X:%d, u32Y:%d, delta_x:%d, delta_y:%d \n",u32X, u32Y,delta_x, delta_y);
-
-        if( ( val[1] == 0xFF ) && ( val[2] == 0xFF ) && ( val[3] == 0xFF ) && ( val[4] == 0xFF ) && ( val[6] == 0xFF ) )
-        {  
-            touchData->Point[0].X = 0; // final X coordinate
-            touchData->Point[0].Y = 0; // final Y coordinate
-
-            if( ( val[5] == 0x0 ) || ( val[5] == 0xFF ) )
-            {
-                touchData->nFingerNum = 0; //touch end
-                touchData->nTouchKeyCode = 0; //TouchKeyMode
-                touchData->nTouchKeyMode = 0; //TouchKeyMode
-            }
-            else
-            {
-                touchData->nTouchKeyMode = 1; //TouchKeyMode
-                touchData->nTouchKeyCode = val[5]; //TouchKeyCode
-                touchData->nFingerNum = 1;
-            }
-        }
-        else
-        {
-            touchData->nTouchKeyMode = 0; //Touch on screen...
-
-            if(
-#ifdef REVERSE_X
-                ( delta_x == 4095 )
-#else
-                ( delta_x == 0 )
-#endif
-                &&
-#ifdef REVERSE_Y
-                ( delta_y == 4095 )
-#else
-                ( delta_y == 0 )
-#endif
-            )
-            {
-                touchData->nFingerNum = 1; //one touch
-                touchData->Point[0].X = ( u32X * MS_TS_MSG21XX_X_MAX ) / 2048;
-                touchData->Point[0].Y = ( u32Y * MS_TS_MSG21XX_Y_MAX ) / 2048;
-				TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--FingerNum = 1 \n");
-				TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--touchData->Point[0].X = %d,  touchData->Point[0].Y = %d \n",touchData->Point[0].X,touchData->Point[0].Y);
-            }
-            else
-            {
-                u32 x2, y2;
-
-                touchData->nFingerNum = 2; //two touch
-
-                /* Finger 1 */
-                touchData->Point[0].X = ( u32X * MS_TS_MSG21XX_X_MAX ) / 2048;
-                touchData->Point[0].Y = ( u32Y * MS_TS_MSG21XX_Y_MAX ) / 2048;
-
-                /* Finger 2 */
-                if( delta_x > 2048 )    //transform the unsigh value to sign value
-                {
-                    delta_x -= 4096;
-                }
-                if( delta_y > 2048 )
-                {
-                    delta_y -= 4096;
-                }
-
-                x2 = ( u32 )( u32X + delta_x );
-                y2 = ( u32 )( u32Y + delta_y );
-
-                touchData->Point[1].X = ( x2 * MS_TS_MSG21XX_X_MAX ) / 2048;
-                touchData->Point[1].Y = ( y2 * MS_TS_MSG21XX_Y_MAX ) / 2048;
-				TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--FingerNum = 2 \n");
-            }
-        }
-
-       
-    }
-    else
-    {
-        //DBG("Packet error 0x%x, 0x%x, 0x%x", val[0], val[1], val[2]);
-        //DBG("             0x%x, 0x%x, 0x%x", val[3], val[4], val[5]);
-        //DBG("             0x%x, 0x%x, 0x%x", val[6], val[7], Checksum);
-        TPD_DEBUG( KERN_ERR "err status in tp\n" );
-    }
-
-    //enable_irq( msg21xx_irq );
-  ///
-	 return true;
-
- };
- 
- static  void tpd_down(int x, int y, int p) {
- 	
-	 // input_report_abs(tpd->dev, ABS_PRESSURE, p);
-	  input_report_key(tpd->dev, BTN_TOUCH, 1);
-	  input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 25);
-	  input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
-	  input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
-
-	  /* track id Start 0 */
-		//input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
-	  input_mt_sync(tpd->dev);
-	  if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-	  {   
-		tpd_button(x, y, 1);  
-	  }
-	  if(y > TPD_RES_Y) //virtual key debounce to avoid android ANR issue
-	  {
-		  msleep(50);
-		  TPD_DEBUG("D virtual key \n");
-	  }
-	  TPD_EM_PRINT(x, y, x, y, p-1, 1);
-  }
-  
- static  void tpd_up(int x, int y,int *count) {
-
-	  input_report_key(tpd->dev, BTN_TOUCH, 0);
-	  input_mt_sync(tpd->dev);
-	  TPD_EM_PRINT(x, y, x, y, 0, 0);
-		  
-	  if(FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
-	  {   
-	  	 TPD_DEBUG(KERN_ERR "[msg2133]--tpd_up-BOOT MODE--X:%d, Y:%d; \n", x, y);
-		 tpd_button(x, y, 0); 
-	  } 		  
- 
-  }
-
- static int touch_event_handler(void *unused)
- {
-  
-    TouchScreenInfo_t touchData;
-	u8 touchkeycode = 0;
-	static u32 preKeyStatus = 0;
-	int i=0;
- 
-    TPD_DEBUG(KERN_ERR "[msg2133]touch_event_handler() do while \n");
-
-	touchData.nFingerNum = 0;
-	TPD_DEBUG(KERN_ERR "[msg2133]touch_event_handler() do while \n");
-	 
-	if (tpd_touchinfo(&touchData)) 
-	{
-	 
-		TPD_DEBUG(KERN_ERR "[msg2133]--KeyMode:%d, KeyCode:%d, FingerNum =%d \n", touchData.nTouchKeyMode, touchData.nTouchKeyCode, touchData.nFingerNum );
-	 
-		//key...
-		if( touchData.nTouchKeyMode )
-		{
-	    	//key mode change virtual key mode
-			touchData.nFingerNum = 1;
-			if( touchData.nTouchKeyCode == 1 )
-			{
-				//touchkeycode = KEY_MENU;
-				touchData.Point[0].X = 80;
-				touchData.Point[0].Y = 850;
-			}
-			if( touchData.nTouchKeyCode == 2 )
-			{
-				//touchkeycode = KEY_HOMEPAGE ;
-				touchData.Point[0].X = 240;
-				touchData.Point[0].Y = 850;
-
-			}
-			if( touchData.nTouchKeyCode == 4 )
-			{
-				//touchkeycode = KEY_BACK;
-				touchData.Point[0].X = 400;
-				touchData.Point[0].Y = 850;
-
-			}
-			if( touchData.nTouchKeyCode == 8 )
-			{
-				//touchkeycode = KEY_SEARCH;
-				//touchData.Point[0].X = 560;
-				//touchData.Point[0].Y = 850;
-
-			}
-					
-		}
-				//report
-		{
-	 
-			if( ( touchData.nFingerNum ) == 0 ) //touch end
-			{
-				TPD_DEBUG("------UP------ \n");
-				TPD_DEBUG(KERN_ERR "[msg2133]---X:%d, Y:%d; \n", touchData.Point[0].X, touchData.Point[0].Y);
-				tpd_up(touchData.Point[0].X, touchData.Point[0].Y, 0);
-				input_sync( tpd->dev );
-			}
-			else //touch on screen
-			{
-	 
-				for( i = 0; i < ( (int)touchData.nFingerNum ); i++ )
-				{
-				    TPD_DEBUG("------DOWN------ \n");
-					tpd_down(touchData.Point[i].X, touchData.Point[i].Y, 1);
-					TPD_DEBUG(KERN_ERR "[msg2133]---X:%d, Y:%d; i=%d \n", touchData.Point[i].X, touchData.Point[i].Y, i);
-				}
-	 
-				input_sync( tpd->dev );
-			}
-		}//end if(touchData->nTouchKeyMode)
-	 
-			}
-
-     mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
-	 return 0;
- }
- 
- static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info) 
- {
-	 strcpy(info->type, TPD_DEVICE);	
-	  return 0;
- }
- 
- static void tpd_eint_interrupt_handler(void)
- {
-	 mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-	 schedule_work( &msg21xx_wq );
- }
-
- static int __devinit tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
- {	 
- 
-	int retval = TPD_OK;
-	char data;
-	u8 report_rate=0;
-	int err=0;
-	int reset_count = 0;
-
-	msg_i2c_client = client;
-	//msg21xx_i2c_client = client;
-	this_client = client;
-	/*reset I2C clock*/
-    //i2c_client->timing = 0;
-    
-   INIT_WORK( &msg21xx_wq, touch_event_handler );
-//power on, need confirm with SA
-#ifdef TPD_POWER_SOURCE_CUSTOM
-	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
-#else
-	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");
-#endif
-#ifdef TPD_POWER_SOURCE_1800
-	hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
-#endif 
-
-
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	 
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-	hwPowerOn(TPD_POWER_SOURCE,VOL_2800,"TP");
-	msleep(100);
-#else
-
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(10);
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(50);
-	TPD_DMESG(" msg2133 reset\n");
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(50);
-	
-#endif
-	
-
-	mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
-    mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
-   	mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_ENABLE);
-    mt_set_gpio_pull_select(GPIO_CTP_EINT_PIN, GPIO_PULL_DOWN);
-		
-
-    msleep(10);
-
-	//mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
-	//mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
-	mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_TYPE, tpd_eint_interrupt_handler, 1);
-	msleep(50);
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-	msleep(200);
-/*
-	 char dbbus_tx_data[3];
-	 char dbbus_rx_data[2]; 
-	 dbbusDWIICEnterSerialDebugMode();
-	 dbbusDWIICStopMCU();
-	 dbbusDWIICIICUseBus();
-	 dbbusDWIICIICReshape();
-	 dbbus_tx_data[0] = 0x10;
-	 dbbus_tx_data[1] = 0x3A;
-	 dbbus_tx_data[2] = 0x08; 
-	 dbbus_rx_data[0]=0xFF;
-	 dbbus_rx_data[1]=0xFF; 
-	 HalTscrCDevWriteI2CSeq(0XC4, &dbbus_tx_data[0], 3);
-	 HalTscrCReadI2CSeq(0XC4, &dbbus_rx_data[0], 2);
-	 dbbusDWIICIICNotUseBus();
-	 dbbusDWIICNotStopMCU();
-	 dbbusDWIICExitSerialDebugMode();
-
-	 if(dbbus_rx_data[0]==0||dbbus_rx_data[0]==0xff)
-	 {
-		 return -1;//	
-	 }
-
-	*/
-    if((i2c_smbus_read_i2c_block_data(msg_i2c_client, 0x00, 1, &data))< 0)
-	{
-		TPD_DMESG("I2C transfer error, line: %d\n", __LINE__);
-		return -1; 
-	}
-	
-    tpd_load_status = 1;
-
-	TPD_DMESG("msg2133 Touch Panel Device Probe %s\n", (retval < TPD_OK) ? "FAIL" : "PASS");
-	
-	TPD_DEBUG("msg2133--frameware upgrade \n");
-
-    /*frameware upgrade*/	
-#ifdef __FIRMWARE_UPDATE__
-		firmware_class = class_create( THIS_MODULE, "ms-touchscreen-msg20xx" );
-		if( IS_ERR( firmware_class ) )
-			pr_err( "Failed to create class(firmware)!\n" );
-		firmware_cmd_dev = device_create( firmware_class,
-										  NULL, 0, NULL, "device" );
-		if( IS_ERR( firmware_cmd_dev ) )
-			pr_err( "Failed to create device(firmware_cmd_dev)!\n" );
-	
-		// version
-		if( device_create_file( firmware_cmd_dev, &dev_attr_version ) < 0 )
-			pr_err( "Failed to create device file(%s)!\n", dev_attr_version.attr.name );
-		// update
-		if( device_create_file( firmware_cmd_dev, &dev_attr_update ) < 0 )
-			pr_err( "Failed to create device file(%s)!\n", dev_attr_update.attr.name );
-		// data
-		if( device_create_file( firmware_cmd_dev, &dev_attr_data ) < 0 )
-			pr_err( "Failed to create device file(%s)!\n", dev_attr_data.attr.name );
-		// clear
-		if( device_create_file( firmware_cmd_dev, &dev_attr_clear ) < 0 )
-			pr_err( "Failed to create device file(%s)!\n", dev_attr_clear.attr.name );
-	
-		dev_set_drvdata( firmware_cmd_dev, NULL );
-#endif
-
-   return 0;
-   
- }
-
- static int __devexit tpd_remove(struct i2c_client *client)
- 
- {
-   
-	 TPD_DEBUG("TPD removed\n");
- 
-   return 0;
- }
- 
- 
- static int tpd_local_init(void)
- {
-
- 
-  	TPD_DMESG("Mstar msg2133 I2C Touchscreen Driver (Built %s @ %s)\n", __DATE__, __TIME__);
- 
- 
-    if(i2c_add_driver(&tpd_i2c_driver)!=0)
-   	{
-  		TPD_DMESG("msg2133 unable to add i2c driver.\n");
-      	return -1;
-    }
-    if(tpd_load_status == 0) 
-    {
-    	TPD_DMESG("msg2133 add error touch panel driver.\n");
-    	i2c_del_driver(&tpd_i2c_driver);
-    	return -1;
-    }
-	
-#ifdef TPD_HAVE_BUTTON     
-    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
-#endif   
-  
-//#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))    
-//WARP CHECK IS NEED --XB.PANG
-//#endif 
-
-	TPD_DMESG("end %s, %d\n", __FUNCTION__, __LINE__);  
-		
-    return 0; 
- }
-
- static void tpd_resume( struct early_suspend *h )
- {
- 
-   TPD_DMESG("TPD wake up\n");
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	
-	hwPowerOn(TPD_POWER_SOURCE,VOL_2800,"TP");
-#endif
-	msleep(100);
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	msleep(50);
-	TPD_DMESG(" msg2133 reset\n");
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
-	msleep(200);
-	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
-	TPD_DMESG("TPD wake up done\n");
-	
- }
-
- static void tpd_suspend( struct early_suspend *h )
- {
- 	
-	TPD_DMESG("TPD enter sleep\n");
-	mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
-	
-	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
-    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
-    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
-	 
-#ifdef TPD_CLOSE_POWER_IN_SLEEP	
-	hwPowerDown(TPD_POWER_SOURCE,"TP");
-#else
-	//TP enter sleep mode----XB.PANG NEED CHECK
-	//if have sleep mode
-#endif
-    TPD_DMESG("TPD enter sleep done\n");
- } 
-
-
- static struct tpd_driver_t tpd_device_driver = {
-		 .tpd_device_name = "msg2133",
-		 .tpd_local_init = tpd_local_init,
-		 .suspend = tpd_suspend,
-		 .resume = tpd_resume,
-#ifdef TPD_HAVE_BUTTON
-		 .tpd_have_button = 1,
-#else
-		 .tpd_have_button = 0,
-#endif		
- };
- /* called when loaded into kernel */
- static int __init tpd_driver_init(void) {
-	 TPD_DEBUG("MediaTek MSG2133 touch panel driver init\n");
-	   i2c_register_board_info(0, &msg2133_i2c_tpd, 1);
-		 if(tpd_driver_add(&tpd_device_driver) < 0)
-			 TPD_DMESG("add MSG2133 driver failed\n");
-	 return 0;
- }
- 
- /* should never be called */
- static void __exit tpd_driver_exit(void) {
-	 TPD_DMESG("MediaTek MSG2133 touch panel driver exit\n");
-	 tpd_driver_remove(&tpd_device_driver);
- }
- 
- module_init(tpd_driver_init);
- module_exit(tpd_driver_exit);
-
-
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_common.c b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_common.c
new file mode 100644
index 0000000..94822b5
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_common.c
@@ -0,0 +1,152 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_common.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_common.h"
+
+/*=============================================================*/
+// MACRO DEFINITION
+/*=============================================================*/
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// VARIABLE DEFINITION
+/*=============================================================*/
+
+static u32 _gCrc32Table[256]; 
+
+/*=============================================================*/
+// DATA TYPE DEFINITION
+/*=============================================================*/
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+/// CRC
+u32 DrvCommonCrcDoReflect(u32 nRef, s8 nCh)
+{
+    u32 nValue = 0;
+    u32 i = 0;
+
+    for (i = 1; i < (nCh + 1); i ++)
+    {
+        if (nRef & 1)
+        {
+            nValue |= 1 << (nCh - i);
+        }
+        nRef >>= 1;
+    }
+
+    return nValue;
+}
+
+u32 DrvCommonCrcGetValue(u32 nText, u32 nPrevCRC)
+{
+    u32 nCRC = nPrevCRC;
+
+    nCRC = (nCRC >> 8) ^ _gCrc32Table[(nCRC & 0xFF) ^ nText];
+
+    return nCRC;
+}
+
+void DrvCommonCrcInitTable(void)
+{
+    u32 nMagicNumber = 0x04c11db7;
+    u32 i, j;
+
+    for (i = 0; i <= 0xFF; i ++)
+    {
+        _gCrc32Table[i] = DrvCommonCrcDoReflect(i, 8) << 24;
+        for (j = 0; j < 8; j ++)
+        {
+            _gCrc32Table[i] = (_gCrc32Table[i] << 1) ^ (_gCrc32Table[i] & (0x80000000L) ? nMagicNumber : 0);
+        }
+        _gCrc32Table[i] = DrvCommonCrcDoReflect(_gCrc32Table[i], 32);
+    }
+}
+
+u8 DrvCommonCalculateCheckSum(u8 *pMsg, u32 nLength)
+{
+    s32 nCheckSum = 0;
+    u32 i;
+
+    for (i = 0; i < nLength; i ++)
+    {
+        nCheckSum += pMsg[i];
+    }
+
+    return (u8)((-nCheckSum) & 0xFF);
+}
+
+u32 DrvCommonConvertCharToHexDigit(char *pCh, u32 nLength)
+{
+    u32 nRetVal = 0;
+    u32 i;
+    
+    DBG("nLength = %d\n", nLength);
+
+    for (i = 0; i < nLength; i ++)
+    {
+        char ch = *pCh++;
+        u32 n = 0;
+        
+        if ((i == 0 && ch == '0') || (i == 1 && ch == 'x'))
+        {
+            continue;		
+        }
+        
+        if ('0' <= ch && ch <= '9')
+        {
+            n = ch-'0';
+        }
+        else if ('a' <= ch && ch <= 'f')
+        {
+            n = 10 + ch-'a';
+        }
+        else if ('A' <= ch && ch <= 'F')
+        {
+            n = 10 + ch-'A';
+        }
+        
+        if (i < 6)
+        {
+            nRetVal = n + nRetVal*16;
+        }
+    }
+    
+    return nRetVal;
+}
+
+//------------------------------------------------------------------------------//
\ No newline at end of file
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_common.h b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_common.h
new file mode 100644
index 0000000..88374b6
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_common.h
@@ -0,0 +1,320 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_common.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_COMMON_H__
+#define __MSTAR_DRV_COMMON_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/earlysuspend.h>
+#include <linux/i2c.h>
+#include <linux/proc_fs.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+/*--------------------------------------------------------------------------*/
+/* TOUCH DEVICE DRIVER RELEASE VERSION                                      */
+/*--------------------------------------------------------------------------*/
+
+#define DEVICE_DRIVER_RELEASE_VERSION   ("2.2.0.0")
+
+
+/*--------------------------------------------------------------------------*/
+/* COMPILE OPTION DEFINITION                                                */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling for distinct smart phone developer platform.
+ * For running on Spreadtrum platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM.
+ * For running on Qualcomm platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM.
+ * For running on MediaTek platform, please define the compile option CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM.
+ */
+//#define CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM
+//#define CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM
+#define CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling for distinct touch ic.
+ * Please enable the compile option depends on the touch ic that customer project are using and disable the others.
+ */
+#define CONFIG_ENABLE_CHIP_MSG21XXA
+//#define CONFIG_ENABLE_CHIP_MSG22XX
+//#define CONFIG_ENABLE_CHIP_MSG26XXM
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling to make sure main board can supply power to touch ic for some specific BB chip of MTK(EX. MT6582)/SPRD(EX. SC7715)/QCOM(EX. MSM8610).
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_REGULATOR_POWER_ON
+
+/*
+ * Note.
+ * The below compile option is used to distinguish different workqueue scheduling mechanism when firmware report finger touch to device driver by IRQ interrupt.
+ * For MTK platform, there are two type of workqueue scheduling mechanism available.
+ * Please refer to the related code which is enclosed by compile option CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM in mstar_drv_platform_porting_layer.c for more detail.
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+
+//#define CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+
+/*
+ * Note.
+ * The below compile option is used to apply DMA mode for read/write data between device driver and firmware by I2C.
+ * The DMA mode is used to reslove I2C read/write 8 bytes limitation for specific MTK BB chip(EX. MT6589/MT6572/...)
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_DMA_IIC
+
+/*
+ * Note.
+ * The below compile option is used to enable the output log mechanism while touch device driver is running.
+ * If this compile option is not defined, the function for output log will be disabled.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_TOUCH_DRIVER_DEBUG
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code handling when touch panel support virtual key(EX. Menu, Home, Back, Search).
+ * If this compile option is not defined, the function for virtual key handling will be disabled.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_TP_HAVE_KEY
+
+/*
+ * Note.
+ * Since specific MTK BB chip report virtual key touch by using coordinate instead of key code, the below compile option is used to enable the code handling for reporting key with coordinate.
+ * This compile option is used for MTK platform only.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+
+/*
+ * Note.
+ * The below compile option is used to enable debug mode data log for firmware.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+/*
+ * Note.
+ * The below compile option is used to enable gesture wakeup.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*
+ * Note.
+ * The below compile option is used to enable phone level MP test handling.
+ * By the way, phone level MP test is ready for MSG21XXA(support Open Test&Short Test)/MSG26XXM(support Open Test) only, but phone level MP test for MSG22XX is not ready yet.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_ENABLE_ITO_MP_TEST
+
+
+/*
+ * Note.
+ * The below compile option is used to change the permission of the sysfs virtual file system for CTS test.
+ * If this compile option is enabled, the permission 0644 will be used. 
+ * If this compile option is disabled, the permission 0777 will be used. 
+ * By default, this compile option is disabled.
+ */
+//#define SYSFS_AUTHORITY_CHANGE_FOR_CTS_TEST
+
+/*
+ * Note.
+ * If this compile option is not defined, the SW ID mechanism for updating firmware will be disabled.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*
+ * Note.
+ * If this compile option is defined, the update firmware bin file shall be stored in a two dimensional array format.
+ * Else, the update firmware bin file shall be stored in an one dimensional array format.
+ * Be careful, MSG22XX only support storing update firmware bin file in an one dimensional array format, it does not support two dimensional array format.
+ * By default, this compile option is disabled.
+ */
+//#define CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY 
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define u8   unsigned char
+#define u16  unsigned short
+#define u32  unsigned int
+#define s8   signed char
+#define s16  signed short
+#define s32  signed int
+
+//#define SLAVE_I2C_ID_DBBUS         (0xB2>>1) //0x59 // for MSG22XX
+#define SLAVE_I2C_ID_DBBUS         (0xC4>>1) //0x62 // for MSG21XX/MSG21XXA/MSG26XXM
+#define SLAVE_I2C_ID_DWI2C         (0x4C>>1) //0x26 
+
+#define CHIP_TYPE_MSG21XX   (0x01) // EX. MSG2133
+#define CHIP_TYPE_MSG21XXA  (0x02) // EX. MSG2133A/MSG2138A(Besides, use version to distinguish MSG2133A/MSG2138A, you may refer to _DrvFwCtrlUpdateFirmwareCash()) 
+#define CHIP_TYPE_MSG26XXM  (0x03) // EX. MSG2633M
+#define CHIP_TYPE_MSG22XX   (0x7A) // EX. MSG2238/MSG2256
+
+#define PACKET_TYPE_TOOTH_PATTERN   (0x20)
+#define PACKET_TYPE_GESTURE_WAKEUP  (0x50)
+
+#define TOUCH_SCREEN_X_MIN   (0)
+#define TOUCH_SCREEN_Y_MIN   (0)
+/*
+ * Note.
+ * Please change the below touch screen resolution according to the touch panel that you are using.
+ */
+#define TOUCH_SCREEN_X_MAX   (240) //LCD_WIDTH
+#define TOUCH_SCREEN_Y_MAX   (320) //LCD_HEIGHT
+/*
+ * Note.
+ * Please do not change the below setting.
+ */
+#define TPD_WIDTH   (2048)
+#define TPD_HEIGHT  (2048)
+
+
+#define BIT0  (1<<0)  // 0x0001
+#define BIT1  (1<<1)  // 0x0002
+#define BIT2  (1<<2)  // 0x0004
+#define BIT3  (1<<3)  // 0x0008
+#define BIT4  (1<<4)  // 0x0010
+#define BIT5  (1<<5)  // 0x0020
+#define BIT6  (1<<6)  // 0x0040
+#define BIT7  (1<<7)  // 0x0080
+#define BIT8  (1<<8)  // 0x0100
+#define BIT9  (1<<9)  // 0x0200
+#define BIT10 (1<<10) // 0x0400
+#define BIT11 (1<<11) // 0x0800
+#define BIT12 (1<<12) // 0x1000
+#define BIT13 (1<<13) // 0x2000
+#define BIT14 (1<<14) // 0x4000
+#define BIT15 (1<<15) // 0x8000
+
+
+#define MAX_DEBUG_REGISTER_NUM     (10)
+
+
+#ifdef SYSFS_AUTHORITY_CHANGE_FOR_CTS_TEST
+#define SYSFS_AUTHORITY (0644)
+#else
+#define SYSFS_AUTHORITY (0777)
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#define GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG     0x0001    //0000 0000 0000 0001
+#define GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG        0x0002    //0000 0000 0000 0010
+#define GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG      0x0004    //0000 0000 0000 0100
+#define GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG      0x0008    //0000 0000 0000 1000
+#define GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG     0x0010    //0000 0000 0001 0000
+#define GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG      0x0020    //0000 0000 0010 0000
+#define GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG      0x0040    //0000 0000 0100 0000
+#define GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG      0x0080    //0000 0000 1000 0000
+#define GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG      0x0100    //0000 0001 0000 0000
+#define GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG      0x0200    //0000 0010 0000 0000
+#define GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG      0x0400    //0000 0100 0000 0000
+#define GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG      0x0800    //0000 1000 0000 0000
+#define GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG      0x1000    //0001 0000 0000 0000
+
+#define GESTURE_WAKEUP_PACKET_LENGTH    (6)
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR MACRO DEFINITION                                            */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_TOUCH_DRIVER_DEBUG
+//#define DBG(fmt, arg...) pr_info(fmt, ##arg)
+#define DBG(fmt, arg...) printk(fmt, ##arg)
+#else
+#define DBG(fmt, arg...)
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+typedef enum
+{
+    EMEM_ALL = 0,
+    EMEM_MAIN,
+    EMEM_INFO
+} EmemType_e;
+
+typedef enum
+{
+    ITO_TEST_MODE_OPEN_TEST = 1,
+    ITO_TEST_MODE_SHORT_TEST = 2
+} ItoTestMode_e;
+
+typedef enum
+{
+    ITO_TEST_OK = 0,
+    ITO_TEST_FAIL,
+    ITO_TEST_GET_TP_TYPE_ERROR,
+    ITO_TEST_UNDEFINED_ERROR,
+    ITO_TEST_UNDER_TESTING
+
+} ItoTestResult_e;
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL VARIABLE DEFINITION                                               */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern u8 DrvCommonCalculateCheckSum(u8 *pMsg, u32 nLength);
+extern u32 DrvCommonConvertCharToHexDigit(char *pCh, u32 nLength);
+extern u32 DrvCommonCrcDoReflect(u32 nRef, s8 nCh);
+extern u32 DrvCommonCrcGetValue(u32 nText, u32 nPrevCRC);
+extern void DrvCommonCrcInitTable(void);
+
+#endif  /* __MSTAR_DRV_COMMON_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_ic_fw_porting_layer.c b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_ic_fw_porting_layer.c
new file mode 100644
index 0000000..ca562b5
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_ic_fw_porting_layer.c
@@ -0,0 +1,195 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_ic_fw_porting_layer.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u16 g_GestureWakeupMode;
+extern u8 g_GestureWakeupFlag;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+u8 DrvIcFwLyrGetChipType(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvFwCtrlGetChipType();
+}
+
+void DrvIcFwLyrGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetCustomerFirmwareVersion(pMajor, pMinor, ppVersion);
+}
+
+void DrvIcFwLyrGetPlatformFirmwareVersion(u8 **ppVersion)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetPlatformFirmwareVersion(ppVersion);
+}
+
+s32 DrvIcFwLyrUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvFwCtrlUpdateFirmware(szFwData, eEmemType);
+}	
+
+u32 DrvIcFwLyrIsRegisterFingerTouchInterruptHandler(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return 1; // Indicate that it is necessary to register interrupt handler with GPIO INT pin when firmware is running on IC
+}
+
+void DrvIcFwLyrHandleFingerTouch(u8 *pPacket, u16 nLength)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlHandleFingerTouch();
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+void DrvIcFwLyrOpenGestureWakeup(u16 nWakeupMode)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlOpenGestureWakeup(nWakeupMode);
+}	
+
+void DrvIcFwLyrCloseGestureWakeup(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlCloseGestureWakeup();
+}	
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+u16 DrvIcFwLyrGetFirmwareMode(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvFwCtrlGetFirmwareMode();
+}
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+
+u16 DrvIcFwLyrChangeFirmwareMode(u16 nMode)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvFwCtrlChangeFirmwareMode(nMode); 
+}
+
+void DrvIcFwLyrGetFirmwareInfo(FirmwareInfo_t *pInfo)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlGetFirmwareInfo(pInfo);
+}
+
+void DrvIcFwLyrRestoreFirmwareModeToLogDataMode(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlRestoreFirmwareModeToLogDataMode();
+}	
+
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+void DrvIcFwLyrCheckFirmwareUpdateBySwId(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    DrvFwCtrlCheckFirmwareUpdateBySwId();
+}
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+void DrvIcFwLyrCreateMpTestWorkQueue(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+	
+    DrvMpTestCreateMpTestWorkQueue();
+}
+
+void DrvIcFwLyrScheduleMpTestWork(ItoTestMode_e eItoTestMode)
+{
+//    DBG("*** %s() ***\n", __func__);
+	
+    DrvMpTestScheduleMpTestWork(eItoTestMode);
+}
+
+s32 DrvIcFwLyrGetMpTestResult(void)
+{
+//    DBG("*** %s() ***\n", __func__);
+	
+    return DrvMpTestGetTestResult();
+}
+
+void DrvIcFwLyrGetMpTestFailChannel(ItoTestMode_e eItoTestMode, u8 *pFailChannel, u32 *pFailChannelCount)
+{
+//    DBG("*** %s() ***\n", __func__);
+	
+    return DrvMpTestGetTestFailChannel(eItoTestMode, pFailChannel, pFailChannelCount);
+}
+
+void DrvIcFwLyrGetMpTestDataLog(ItoTestMode_e eItoTestMode, u8 *pDataLog, u32 *pLength)
+{
+//    DBG("*** %s() ***\n", __func__);
+
+    return DrvMpTestGetTestDataLog(eItoTestMode, pDataLog, pLength);
+}
+#endif //CONFIG_ENABLE_ITO_MP_TEST		
\ No newline at end of file
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_ic_fw_porting_layer.h b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_ic_fw_porting_layer.h
new file mode 100644
index 0000000..2ca7fcb
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_ic_fw_porting_layer.h
@@ -0,0 +1,90 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_ic_fw_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_IC_FW_PORTING_LAYER_H__
+#define __MSTAR_DRV_IC_FW_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+#include "mstar_drv_mutual_fw_control.h"
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#include "mstar_drv_mutual_mp_test.h"
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+#include "mstar_drv_self_fw_control.h"
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#include "mstar_drv_self_mp_test.h"
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern void DrvIcFwLyrOpenGestureWakeup(u16 nWakeupMode);
+extern void DrvIcFwLyrCloseGestureWakeup(void);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern u16 DrvIcFwLyrChangeFirmwareMode(u16 nMode);
+extern void DrvIcFwLyrGetFirmwareInfo(FirmwareInfo_t *pInfo);
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+extern u16 DrvIcFwLyrGetFirmwareMode(void);
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+extern void DrvIcFwLyrRestoreFirmwareModeToLogDataMode(void);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+extern void DrvIcFwLyrCheckFirmwareUpdateBySwId(void);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+extern u8 DrvIcFwLyrGetChipType(void);
+extern void DrvIcFwLyrGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion);
+extern void DrvIcFwLyrGetPlatformFirmwareVersion(u8 **ppVersion);
+extern void DrvIcFwLyrHandleFingerTouch(u8 *pPacket, u16 nLength);
+extern u32 DrvIcFwLyrIsRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvIcFwLyrUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern void DrvIcFwLyrCreateMpTestWorkQueue(void);
+extern void DrvIcFwLyrScheduleMpTestWork(ItoTestMode_e eItoTestMode);
+extern void DrvIcFwLyrGetMpTestDataLog(ItoTestMode_e eItoTestMode, u8 *pDataLog, u32 *pLength);
+extern void DrvIcFwLyrGetMpTestFailChannel(ItoTestMode_e eItoTestMode, u8 *pFailChannel, u32 *pFailChannelCount);
+extern s32 DrvIcFwLyrGetMpTestResult(void);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+        
+#endif  /* __MSTAR_DRV_IC_FW_PORTING_LAYER_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_main.c b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_main.c
new file mode 100644
index 0000000..4a5faed
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_main.c
@@ -0,0 +1,987 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_main.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_main.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern FirmwareInfo_t g_FirmwareInfo;
+extern u8 *g_LogModePacket;
+extern u16 g_FirmwareMode;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u16 g_GestureWakeupMode;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+extern u8 g_ChipType;
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static u16 _gDebugReg[MAX_DEBUG_REGISTER_NUM] = {0};
+static u32 _gDebugRegCount = 0;
+
+static u8 *_gPlatformFwVersion = NULL; // internal use firmware version for MStar
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+static ItoTestMode_e _gItoTestMode = 0;
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+static u32 _gIsUpdateComplete = 0;
+
+static u8 *_gFwVersion = NULL; // customer firmware version
+
+static struct class *_gFirmwareClass = NULL;
+static struct device *_gFirmwareCmdDev = NULL;
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+struct kset *g_TouchKSet = NULL;
+struct kobject *g_TouchKObj = NULL;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+u8 g_FwData[94][1024];
+u32 g_FwDataCount = 0;
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+ssize_t DrvMainFirmwareChipTypeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return sprintf(pBuf, "%d", g_ChipType);
+}
+
+ssize_t DrvMainFirmwareChipTypeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+//    g_ChipType = DrvIcFwLyrGetChipType();
+
+    return nSize;
+}
+
+static DEVICE_ATTR(chip_type, SYSFS_AUTHORITY, DrvMainFirmwareChipTypeShow, DrvMainFirmwareChipTypeStore);
+
+ssize_t DrvMainFirmwareDriverVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return sprintf(pBuf, "%s", DEVICE_DRIVER_RELEASE_VERSION);
+}
+
+ssize_t DrvMainFirmwareDriverVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(driver_version, SYSFS_AUTHORITY, DrvMainFirmwareDriverVersionShow, DrvMainFirmwareDriverVersionStore);
+
+/*--------------------------------------------------------------------------*/
+
+ssize_t DrvMainFirmwareUpdateShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    return sprintf(pBuf, "%s\n", _gFwVersion);
+}
+
+ssize_t DrvMainFirmwareUpdateStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DBG("*** %s() g_FwDataCount = %d ***\n", __func__, g_FwDataCount);
+
+    if (0 != DrvIcFwLyrUpdateFirmware(g_FwData, EMEM_ALL))
+    {
+        _gIsUpdateComplete = 0;
+        DBG("Update FAILED\n");
+    }
+    else
+    {
+        _gIsUpdateComplete = 1;
+        DBG("Update SUCCESS\n");
+    }
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    DrvIcFwLyrRestoreFirmwareModeToLogDataMode();    
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    DrvPlatformLyrEnableFingerTouchReport();
+  
+    return nSize;
+}
+
+static DEVICE_ATTR(update, SYSFS_AUTHORITY, DrvMainFirmwareUpdateShow, DrvMainFirmwareUpdateStore);
+
+ssize_t DrvMainFirmwareVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    return sprintf(pBuf, "%s\n", _gFwVersion);
+}
+
+ssize_t DrvMainFirmwareVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u16 nMajor = 0, nMinor = 0;
+    
+    DrvIcFwLyrGetCustomerFirmwareVersion(&nMajor, &nMinor, &_gFwVersion);
+
+    DBG("*** %s() _gFwVersion = %s ***\n", __func__, _gFwVersion);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(version, SYSFS_AUTHORITY, DrvMainFirmwareVersionShow, DrvMainFirmwareVersionStore);
+
+ssize_t DrvMainFirmwareDataShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() g_FwDataCount = %d ***\n", __func__, g_FwDataCount);
+    
+    return g_FwDataCount;
+}
+
+ssize_t DrvMainFirmwareDataStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u32 nCount = nSize / 1024;
+    u32 i;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (nCount > 0) // nSize >= 1024
+   	{
+        for (i = 0; i < nCount; i ++)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuf+(i*1024), 1024);
+
+            g_FwDataCount ++;
+        }
+    }
+    else // nSize < 1024
+    {
+    		if (nSize > 0)
+    		{
+            memcpy(g_FwData[g_FwDataCount], pBuf, nSize);
+
+            g_FwDataCount ++;
+    		}
+    }
+
+    DBG("*** g_FwDataCount = %d ***\n", g_FwDataCount);
+
+    if (pBuf != NULL)
+    {
+        DBG("*** buf[0] = %c ***\n", pBuf[0]);
+    }
+   
+    return nSize;
+}
+
+static DEVICE_ATTR(data, SYSFS_AUTHORITY, DrvMainFirmwareDataShow, DrvMainFirmwareDataStore);
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+ssize_t DrvMainFirmwareTestShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+    DBG("*** ctp mp test status = %d ***\n", DrvIcFwLyrGetMpTestResult());
+    
+    return sprintf(pBuf, "%d", DrvIcFwLyrGetMpTestResult());
+}
+
+ssize_t DrvMainFirmwareTestStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u32 nMode = 0;
+
+    DBG("*** %s() ***\n", __func__);
+    
+    if (pBuf != NULL)
+    {
+        sscanf(pBuf, "%x", &nMode);   
+
+        DBG("Mp Test Mode = 0x%x\n", nMode);
+
+        if (nMode == ITO_TEST_MODE_OPEN_TEST) //open test
+        {
+            _gItoTestMode = ITO_TEST_MODE_OPEN_TEST;
+            DrvIcFwLyrScheduleMpTestWork(ITO_TEST_MODE_OPEN_TEST);
+        }
+        else if (nMode == ITO_TEST_MODE_SHORT_TEST) //short test
+        {
+            _gItoTestMode = ITO_TEST_MODE_SHORT_TEST;
+            DrvIcFwLyrScheduleMpTestWork(ITO_TEST_MODE_SHORT_TEST);
+        }
+        else
+        {
+            DBG("*** Undefined MP Test Mode ***\n");
+        }
+    }
+
+    return nSize;
+}
+
+static DEVICE_ATTR(test, SYSFS_AUTHORITY, DrvMainFirmwareTestShow, DrvMainFirmwareTestStore);
+
+ssize_t DrvMainFirmwareTestLogShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    u32 nLength = 0;
+    
+    DBG("*** %s() ***\n", __func__);
+    
+    DrvIcFwLyrGetMpTestDataLog(_gItoTestMode, pBuf, &nLength);
+    
+    return nLength;
+}
+
+ssize_t DrvMainFirmwareTestLogStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(test_log, SYSFS_AUTHORITY, DrvMainFirmwareTestLogShow, DrvMainFirmwareTestLogStore);
+
+ssize_t DrvMainFirmwareTestFailChannelShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    u32 nCount = 0;
+
+    DBG("*** %s() ***\n", __func__);
+    
+    DrvIcFwLyrGetMpTestFailChannel(_gItoTestMode, pBuf, &nCount);
+    
+    return nCount;
+}
+
+ssize_t DrvMainFirmwareTestFailChannelStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(test_fail_channel, SYSFS_AUTHORITY, DrvMainFirmwareTestFailChannelShow, DrvMainFirmwareTestFailChannelStore);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+ssize_t DrvMainFirmwareGestureWakeupModeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+    DBG("g_GestureWakeupMode = 0x%x\n", g_GestureWakeupMode);
+
+    return sprintf(pBuf, "%x", g_GestureWakeupMode);
+}
+
+ssize_t DrvMainFirmwareGestureWakeupModeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u32 nLength, nWakeupMode;
+    
+    DBG("*** %s() ***\n", __func__);
+
+    if (pBuf != NULL)
+    {
+        sscanf(pBuf, "%x", &nWakeupMode);   
+        DBG("nWakeupMode = 0x%x\n", nWakeupMode);
+
+        nLength = nSize;
+        DBG("nLength = %d\n", nLength);
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG) == GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG);
+        }
+        
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG) == GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG);
+        }
+       
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG);
+        }
+
+        if ((nWakeupMode & GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG) == GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG)
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode | GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+        }
+        else
+        {
+            g_GestureWakeupMode = g_GestureWakeupMode & (~GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG);
+        }
+
+        DBG("g_GestureWakeupMode = 0x%x\n", g_GestureWakeupMode);
+    }
+        
+    return nSize;
+}
+
+static DEVICE_ATTR(gesture_wakeup_mode, SYSFS_AUTHORITY, DrvMainFirmwareGestureWakeupModeShow, DrvMainFirmwareGestureWakeupModeStore);
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*--------------------------------------------------------------------------*/
+
+ssize_t DrvMainFirmwareDebugShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    u32 i;
+    u8 nBank, nAddr;
+    u16 szRegData[MAX_DEBUG_REGISTER_NUM] = {0};
+    u8 szOut[MAX_DEBUG_REGISTER_NUM*25] = {0}, szValue[10] = {0};
+
+    DBG("*** %s() ***\n", __func__);
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+    
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+        szRegData[i] = RegGet16BitValue(_gDebugReg[i]);
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    for (i = 0; i < _gDebugRegCount; i ++)
+    {
+    	  nBank = (_gDebugReg[i] >> 8) & 0xFF;
+    	  nAddr = _gDebugReg[i] & 0xFF;
+    	  
+        DBG("reg(0x%X,0x%X)=0x%04X\n", nBank, nAddr, szRegData[i]);
+
+        strcat(szOut, "reg(");
+        sprintf(szValue, "0x%X", nBank);
+        strcat(szOut, szValue);
+        strcat(szOut, ",");
+        sprintf(szValue, "0x%X", nAddr);
+        strcat(szOut, szValue);
+        strcat(szOut, ")=");
+        sprintf(szValue, "0x%04X", szRegData[i]);
+        strcat(szOut, szValue);
+        strcat(szOut, "\n");
+    }
+
+    return sprintf(pBuf, "%s\n", szOut);
+}
+
+ssize_t DrvMainFirmwareDebugStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    u32 i;
+    char *pCh;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (pBuf != NULL)
+    {
+        DBG("*** %s() pBuf[0] = %c ***\n", __func__, pBuf[0]);
+        DBG("*** %s() pBuf[1] = %c ***\n", __func__, pBuf[1]);
+        DBG("*** %s() pBuf[2] = %c ***\n", __func__, pBuf[2]);
+        DBG("*** %s() pBuf[3] = %c ***\n", __func__, pBuf[3]);
+        DBG("*** %s() pBuf[4] = %c ***\n", __func__, pBuf[4]);
+        DBG("*** %s() pBuf[5] = %c ***\n", __func__, pBuf[5]);
+
+        DBG("nSize = %d\n", nSize);
+       
+        i = 0;
+        while ((pCh = strsep((char **)&pBuf, " ,")) && (i < MAX_DEBUG_REGISTER_NUM))
+        {
+            DBG("pCh = %s\n", pCh);
+            
+            _gDebugReg[i] = DrvCommonConvertCharToHexDigit(pCh, strlen(pCh));
+
+            DBG("_gDebugReg[%d] = 0x%04X\n", i, _gDebugReg[i]);
+            i ++;
+        }
+        _gDebugRegCount = i;
+        
+        DBG("_gDebugRegCount = %d\n", _gDebugRegCount);
+    }
+
+    return nSize;
+}
+
+static DEVICE_ATTR(debug, SYSFS_AUTHORITY, DrvMainFirmwareDebugShow, DrvMainFirmwareDebugStore);
+
+/*--------------------------------------------------------------------------*/
+
+ssize_t DrvMainFirmwarePlatformVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() _gPlatformFwVersion = %s ***\n", __func__, _gPlatformFwVersion);
+
+    return sprintf(pBuf, "%s\n", _gPlatformFwVersion);
+}
+
+ssize_t DrvMainFirmwarePlatformVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DrvIcFwLyrGetPlatformFirmwareVersion(&_gPlatformFwVersion);
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    DrvIcFwLyrRestoreFirmwareModeToLogDataMode();    
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    DBG("*** %s() _gPlatformFwVersion = %s ***\n", __func__, _gPlatformFwVersion);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(platform_version, SYSFS_AUTHORITY, DrvMainFirmwarePlatformVersionShow, DrvMainFirmwarePlatformVersionStore);
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+ssize_t DrvMainFirmwareModeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    g_FirmwareMode = DrvIcFwLyrGetFirmwareMode();
+    
+    DBG("%s() firmware mode = 0x%x\n", __func__, g_FirmwareMode);
+
+    return sprintf(pBuf, "%x", g_FirmwareMode);
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+    g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+
+    DBG("%s() firmware mode = 0x%x, can change firmware mode = %d\n", __func__, g_FirmwareInfo.nFirmwareMode, g_FirmwareInfo.nIsCanChangeFirmwareMode);
+
+    return sprintf(pBuf, "%x,%d", g_FirmwareInfo.nFirmwareMode, g_FirmwareInfo.nIsCanChangeFirmwareMode);
+#endif
+}
+
+ssize_t DrvMainFirmwareModeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    u32 nMode;
+    
+    if (pBuf != NULL)
+    {
+        sscanf(pBuf, "%x", &nMode);   
+        DBG("firmware mode = 0x%x\n", nMode);
+
+        if (nMode == FIRMWARE_MODE_DEMO_MODE) //demo mode
+        {
+            g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_DEMO_MODE);
+        }
+        else if (nMode == FIRMWARE_MODE_DEBUG_MODE) //debug mode
+        {
+            g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_DEBUG_MODE);
+        }
+#if defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+        else if (nMode == FIRMWARE_MODE_RAW_DATA_MODE) //raw data mode
+        {
+            g_FirmwareMode = DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_RAW_DATA_MODE);
+        }
+#endif
+        else
+        {
+            DBG("*** Undefined Firmware Mode ***\n");
+        }
+    }
+
+    DBG("*** g_FirmwareMode = 0x%x ***\n", g_FirmwareMode);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(mode, SYSFS_AUTHORITY, DrvMainFirmwareModeShow, DrvMainFirmwareModeStore);
+/*
+ssize_t DrvMainFirmwarePacketShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    u32 i = 0;
+    u32 nLength = 0;
+    
+    DBG("*** %s() ***\n", __func__);
+    
+    if (g_LogModePacket != NULL)
+    {
+        DBG("g_FirmwareMode=%x, g_LogModePacket[0]=%x, g_LogModePacket[1]=%x\n", g_FirmwareMode, g_LogModePacket[0], g_LogModePacket[1]);
+        DBG("g_LogModePacket[2]=%x, g_LogModePacket[3]=%x\n", g_LogModePacket[2], g_LogModePacket[3]);
+        DBG("g_LogModePacket[4]=%x, g_LogModePacket[5]=%x\n", g_LogModePacket[4], g_LogModePacket[5]);
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+        if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE) && (g_LogModePacket[0] == 0xA5 || g_LogModePacket[0] == 0xAB || g_LogModePacket[0] == 0xA7))
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+        if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE) && (g_LogModePacket[0] == 0x62))
+#endif
+        {
+            for (i = 0; i < g_FirmwareInfo.nLogModePacketLength; i ++)
+            {
+                pBuf[i] = g_LogModePacket[i];
+            }
+
+            nLength = g_FirmwareInfo.nLogModePacketLength;
+            DBG("nLength = %d\n", nLength);
+        }
+        else
+        {
+            DBG("CURRENT MODE IS NOT DEBUG MODE/WRONG DEBUG MODE HEADER\n");
+//        nLength = 0;
+        }
+    }
+    else
+    {
+        DBG("g_LogModePacket is NULL\n");
+//        nLength = 0;
+    }
+
+    return nLength;
+}
+
+ssize_t DrvMainFirmwarePacketStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return nSize;
+}
+
+static DEVICE_ATTR(packet, SYSFS_AUTHORITY, DrvMainFirmwarePacketShow, DrvMainFirmwarePacketStore);
+*/
+ssize_t DrvMainFirmwareSensorShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    if (g_FirmwareInfo.nLogModePacketHeader == 0xA5 || g_FirmwareInfo.nLogModePacketHeader == 0xAB)
+    {
+        return sprintf(pBuf, "%d,%d", g_FirmwareInfo.nMx, g_FirmwareInfo.nMy);
+    }
+    else if (g_FirmwareInfo.nLogModePacketHeader == 0xA7)
+    {
+        return sprintf(pBuf, "%d,%d,%d,%d", g_FirmwareInfo.nMx, g_FirmwareInfo.nMy, g_FirmwareInfo.nSs, g_FirmwareInfo.nSd);
+    }
+    else
+    {
+        DBG("Undefined debug mode packet format : 0x%x\n", g_FirmwareInfo.nLogModePacketHeader);
+        return 0;
+    }
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    return sprintf(pBuf, "%d", g_FirmwareInfo.nLogModePacketLength);
+#endif
+}
+
+ssize_t DrvMainFirmwareSensorStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+/*
+    DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+#if defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+#endif 
+*/    
+    return nSize;
+}
+
+static DEVICE_ATTR(sensor, SYSFS_AUTHORITY, DrvMainFirmwareSensorShow, DrvMainFirmwareSensorStore);
+
+ssize_t DrvMainFirmwareHeaderShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return sprintf(pBuf, "%d", g_FirmwareInfo.nLogModePacketHeader);
+}
+
+ssize_t DrvMainFirmwareHeaderStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize)
+{
+    DBG("*** %s() ***\n", __func__);
+/*
+    DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+#if defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+#endif
+*/    
+    return nSize;
+}
+
+static DEVICE_ATTR(header, SYSFS_AUTHORITY, DrvMainFirmwareHeaderShow, DrvMainFirmwareHeaderStore);
+
+//------------------------------------------------------------------------------//
+
+ssize_t DrvMainKObjectPacketShow(struct kobject *pKObj, struct kobj_attribute *pAttr, char *pBuf)
+{
+    u32 i = 0;
+    u32 nLength = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (strcmp(pAttr->attr.name, "packet") == 0)
+    {
+        if (g_LogModePacket != NULL)
+        {
+            DBG("g_FirmwareMode=%x, g_LogModePacket[0]=%x, g_LogModePacket[1]=%x\n", g_FirmwareMode, g_LogModePacket[0], g_LogModePacket[1]);
+            DBG("g_LogModePacket[2]=%x, g_LogModePacket[3]=%x\n", g_LogModePacket[2], g_LogModePacket[3]);
+            DBG("g_LogModePacket[4]=%x, g_LogModePacket[5]=%x\n", g_LogModePacket[4], g_LogModePacket[5]);
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+            if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE) && (g_LogModePacket[0] == 0xA5 || g_LogModePacket[0] == 0xAB || g_LogModePacket[0] == 0xA7))
+#elif defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+            if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE) && (g_LogModePacket[0] == 0x62))
+#endif
+            {
+                for (i = 0; i < g_FirmwareInfo.nLogModePacketLength; i ++)
+                {
+                    pBuf[i] = g_LogModePacket[i];
+                }
+
+                nLength = g_FirmwareInfo.nLogModePacketLength;
+                DBG("nLength = %d\n", nLength);
+            }
+            else
+            {
+                DBG("CURRENT MODE IS NOT DEBUG MODE/WRONG DEBUG MODE HEADER\n");
+//            nLength = 0;
+            }
+        }
+        else
+        {
+            DBG("g_LogModePacket is NULL\n");
+//            nLength = 0;
+        }
+    }
+    else
+    {
+        DBG("pAttr->attr.name = %s \n", pAttr->attr.name);
+//        nLength = 0;
+    }
+
+    return nLength;
+}
+
+ssize_t DrvMainKObjectPacketStore(struct kobject *pKObj, struct kobj_attribute *pAttr, const char *pBuf, size_t nCount)
+{
+    DBG("*** %s() ***\n", __func__);
+/*
+    if (strcmp(pAttr->attr.name, "packet") == 0)
+    {
+
+    }
+*/    	
+    return nCount;
+}
+
+static struct kobj_attribute packet_attr = __ATTR(packet, 0666, DrvMainKObjectPacketShow, DrvMainKObjectPacketStore);
+
+/* Create a group of attributes so that we can create and destroy them all at once. */
+static struct attribute *attrs[] = {
+    &packet_attr.attr,
+    NULL,	/* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory. If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+struct attribute_group attr_group = {
+    .attrs = attrs,
+};
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+//------------------------------------------------------------------------------//
+
+s32 DrvMainTouchDeviceInitialize(void)
+{
+    s32 nRetVal = 0;
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    u8 *pDevicePath = NULL;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    DBG("*** %s() ***\n", __func__);
+
+    /* set sysfs for firmware */
+    _gFirmwareClass = class_create(THIS_MODULE, "ms-touchscreen-msg20xx");
+    if (IS_ERR(_gFirmwareClass))
+        DBG("Failed to create class(firmware)!\n");
+
+    _gFirmwareCmdDev = device_create(_gFirmwareClass, NULL, 0, NULL, "device");
+    if (IS_ERR(_gFirmwareCmdDev))
+        DBG("Failed to create device(_gFirmwareCmdDev)!\n");
+
+    // version
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_version) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_version.attr.name);
+    // update
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_update) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_update.attr.name);
+    // data
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_data) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_data.attr.name);
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+    // test
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_test) < 0)
+        pr_err("Failed to create device file(%s)!\n", dev_attr_test.attr.name);
+    // test_log
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_test_log) < 0)
+        pr_err("Failed to create device file(%s)!\n", dev_attr_test_log.attr.name);
+    // test_fail_channel
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_test_fail_channel) < 0)
+        pr_err("Failed to create device file(%s)!\n", dev_attr_test_fail_channel.attr.name);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    // mode
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_mode) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_mode.attr.name);
+    // packet
+//    if (device_create_file(_gFirmwareCmdDev, &dev_attr_packet) < 0)
+//        DBG("Failed to create device file(%s)!\n", dev_attr_packet.attr.name);
+    // sensor
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_sensor) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_sensor.attr.name);
+    // header
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_header) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_header.attr.name);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    // debug
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_debug) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_debug.attr.name);
+    // platform version
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_platform_version) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_platform_version.attr.name);
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    // gesture wakeup mode
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_gesture_wakeup_mode) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_gesture_wakeup_mode.attr.name);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+    // chip type
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_chip_type) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_chip_type.attr.name);
+    // driver version
+    if (device_create_file(_gFirmwareCmdDev, &dev_attr_driver_version) < 0)
+        DBG("Failed to create device file(%s)!\n", dev_attr_driver_version.attr.name);
+
+    dev_set_drvdata(_gFirmwareCmdDev, NULL);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+    DrvIcFwLyrCreateMpTestWorkQueue();
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+    
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    /* create a kset with the name of "kset_example" which is located under /sys/kernel/ */
+    g_TouchKSet = kset_create_and_add("kset_example", NULL, kernel_kobj);
+    if (!g_TouchKSet)
+    {
+        DBG("*** kset_create_and_add() failed, nRetVal = %d ***\n", nRetVal);
+
+        nRetVal = -ENOMEM;
+    }
+
+    g_TouchKObj = kobject_create();
+    if (!g_TouchKObj)
+    {
+        DBG("*** kobject_create() failed, nRetVal = %d ***\n", nRetVal);
+
+        nRetVal = -ENOMEM;
+		    kset_unregister(g_TouchKSet);
+		    g_TouchKSet = NULL;
+    }
+
+    g_TouchKObj->kset = g_TouchKSet;
+
+    nRetVal = kobject_add(g_TouchKObj, NULL, "%s", "kobject_example");
+    if (nRetVal != 0)
+    {
+        DBG("*** kobject_add() failed, nRetVal = %d ***\n", nRetVal);
+
+		    kobject_put(g_TouchKObj);
+		    g_TouchKObj = NULL;
+		    kset_unregister(g_TouchKSet);
+		    g_TouchKSet = NULL;
+    }
+    
+    /* create the files associated with this kobject */
+    nRetVal = sysfs_create_group(g_TouchKObj, &attr_group);
+    if (nRetVal != 0)
+    {
+        DBG("*** sysfs_create_file() failed, nRetVal = %d ***\n", nRetVal);
+
+        kobject_put(g_TouchKObj);
+		    g_TouchKObj = NULL;
+		    kset_unregister(g_TouchKSet);
+		    g_TouchKSet = NULL;
+    }
+    
+    pDevicePath = kobject_get_path(g_TouchKObj, GFP_KERNEL);
+    DBG("DEVPATH = %s\n", pDevicePath);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    g_ChipType = DrvIcFwLyrGetChipType();
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    // get firmware mode for parsing packet judgement.
+    g_FirmwareMode = DrvIcFwLyrGetFirmwareMode();
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+
+    memset(&g_FirmwareInfo, 0x0, sizeof(FirmwareInfo_t));
+
+    DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+
+#if defined(CONFIG_ENABLE_CHIP_MSG21XXA) || defined(CONFIG_ENABLE_CHIP_MSG22XX)
+    g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+#endif
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+    DrvIcFwLyrCheckFirmwareUpdateBySwId();
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+    return nRetVal;
+}
+
+//------------------------------------------------------------------------------//
\ No newline at end of file
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_main.h b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_main.h
new file mode 100644
index 0000000..e19e6b1
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_main.h
@@ -0,0 +1,89 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_main.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_MAIN_H__
+#define __MSTAR_DRV_MAIN_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR MACRO DEFINITION                                            */
+/*--------------------------------------------------------------------------*/
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern ssize_t DrvMainFirmwareDataShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareDataStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwareUpdateShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareUpdateStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwareVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern ssize_t DrvMainFirmwareTestShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareTestStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+#endif //CONFIG_ENABLE_ITO_MP_TEST
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern ssize_t DrvMainFirmwareGestureWakeupModeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareGestureWakeupModeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+extern ssize_t DrvMainFirmwareDebugShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareDebugStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwarePlatformVersionShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwarePlatformVersionStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern ssize_t DrvMainFirmwareHeaderShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareHeaderStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwareModeShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareModeStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+//extern ssize_t DrvMainFirmwarePacketShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+//extern ssize_t DrvMainFirmwarePacketStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainFirmwareSensorShow(struct device *pDevice, struct device_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainFirmwareSensorStore(struct device *pDevice, struct device_attribute *pAttr, const char *pBuf, size_t nSize);
+extern ssize_t DrvMainKObjectPacketShow(struct kobject *pKObj, struct kobj_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainKObjectPacketStore(struct kobject *pKObj, struct kobj_attribute *pAttr, const char *pBuf, size_t nCount);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern s32 DrvMainTouchDeviceInitialize(void);
+
+#endif  /* __MSTAR_DRV_MAIN_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_mtk.c b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_mtk.c
new file mode 100644
index 0000000..58890d4
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_mtk.c
@@ -0,0 +1,275 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_mtk.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/hwmsen_helper.h>
+//#include <linux/hw_module_info.h>
+
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/namei.h>
+#include <linux/vmalloc.h>
+
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+#include <mach/mt_gpio.h>
+
+#include <cust_eint.h>
+
+#include "tpd.h"
+#include "cust_gpio_usage.h"
+
+#include "mstar_drv_platform_interface.h"
+
+/*=============================================================*/
+// CONSTANT VALUE DEFINITION
+/*=============================================================*/
+
+#define MSG_TP_IC_NAME "msg2xxx" //"msg21xxA" or "msg22xx" or "msg26xxM" /* Please define the mstar touch ic name based on the mutual-capacitive ic or self capacitive ic that you are using */
+#define I2C_BUS_ID   (2)       // i2c bus id : 0 or 1
+
+#define TPD_OK (0)
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_TP_HAVE_KEY
+extern const int g_TpVirtualKey[];
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+extern const int g_TpVirtualKeyDimLocal[][4];
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+extern struct tpd_device *tpd;
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+/*
+#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))
+static int tpd_wb_start_local[TPD_WARP_CNT] = TPD_WARP_START;
+static int tpd_wb_end_local[TPD_WARP_CNT] = TPD_WARP_END;
+#endif
+
+#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
+static int tpd_calmat_local[8] = TPD_CALIBRATION_MATRIX;
+static int tpd_def_calmat_local[8] = TPD_CALIBRATION_MATRIX;
+#endif
+*/
+struct i2c_client *g_I2cClient = NULL;
+
+//static int boot_mode = 0;
+
+/*=============================================================*/
+// FUNCTION DECLARATION
+/*=============================================================*/
+
+/*=============================================================*/
+// FUNCTION DEFINITION
+/*=============================================================*/
+
+/* probe function is used for matching and initializing input device */
+static int  tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    TPD_DMESG("TPD probe\n");   
+    
+    if (client == NULL)
+    {
+        TPD_DMESG("i2c client is NULL\n");
+        return -1;
+    }
+    g_I2cClient = client;
+    
+    MsDrvInterfaceTouchDeviceSetIicDataRate(g_I2cClient, 100000); // 100 KHZ
+
+    MsDrvInterfaceTouchDeviceProbe(g_I2cClient, id);
+
+    tpd_load_status = 1;
+
+    TPD_DMESG("TPD probe done\n");
+    
+    return TPD_OK;   
+}
+
+static int tpd_detect(struct i2c_client *client, struct i2c_board_info *info) 
+{
+    strcpy(info->type, TPD_DEVICE);    
+//    strcpy(info->type, MSG_TP_IC_NAME);
+    
+    return TPD_OK;
+}
+
+static int tpd_remove(struct i2c_client *client)
+{   
+    TPD_DEBUG("TPD removed\n");
+    
+    MsDrvInterfaceTouchDeviceRemove(client);
+    
+    return TPD_OK;
+}
+
+static struct i2c_board_info __initdata i2c_tpd = {I2C_BOARD_INFO(MSG_TP_IC_NAME, (0x4C>>1))};
+
+/* The I2C device list is used for matching I2C device and I2C device driver. */
+static const struct i2c_device_id tpd_device_id[] =
+{
+    {MSG_TP_IC_NAME, 0},
+    {}, /* should not omitted */ 
+};
+
+MODULE_DEVICE_TABLE(i2c, tpd_device_id);
+
+static struct i2c_driver tpd_i2c_driver = {
+    .driver = {
+        .name = MSG_TP_IC_NAME,
+    },
+    .probe = tpd_probe,
+    .remove = tpd_remove,
+    .id_table = tpd_device_id,
+    .detect = tpd_detect,
+};
+
+static int tpd_local_init(void)
+{  
+    TPD_DMESG("TPD init device driver (Built %s @ %s)\n", __DATE__, __TIME__);
+/*
+    // Software reset mode will be treated as normal boot
+    boot_mode = get_boot_mode();
+    if (boot_mode == 3) 
+    {
+        boot_mode = NORMAL_BOOT;    
+    }
+*/
+    if (i2c_add_driver(&tpd_i2c_driver) != 0)
+    {
+        TPD_DMESG("unable to add i2c driver.\n");
+         
+        return -1;
+    }
+    
+    if (tpd_load_status == 0) 
+    {
+        TPD_DMESG("add error touch panel driver.\n");
+
+        i2c_del_driver(&tpd_i2c_driver);
+        return -1;
+    }
+
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE     
+    // initialize tpd button data
+    tpd_button_setting(4, g_TpVirtualKey, g_TpVirtualKeyDimLocal); //MAX_KEY_NUM
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE  
+#endif //CONFIG_TP_HAVE_KEY  
+
+/*
+#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))    
+    TPD_DO_WARP = 1;
+    memcpy(tpd_wb_start, tpd_wb_start_local, TPD_WARP_CNT*4);
+    memcpy(tpd_wb_end, tpd_wb_start_local, TPD_WARP_CNT*4);
+#endif 
+
+#if (defined(TPD_HAVE_CALIBRATION) && !defined(TPD_CUSTOM_CALIBRATION))
+    memcpy(tpd_calmat, tpd_def_calmat_local, 8*4);
+    memcpy(tpd_def_calmat, tpd_def_calmat_local, 8*4);    
+#endif  
+*/
+    TPD_DMESG("TPD init done %s, %d\n", __FUNCTION__, __LINE__);  
+        
+    return TPD_OK; 
+}
+
+static void tpd_resume(struct early_suspend *h)
+{
+    TPD_DMESG("TPD wake up\n");
+    
+    MsDrvInterfaceTouchDeviceResume(h);
+    
+    TPD_DMESG("TPD wake up done\n");
+}
+
+static void tpd_suspend(struct early_suspend *h)
+{
+    TPD_DMESG("TPD enter sleep\n");
+
+    MsDrvInterfaceTouchDeviceSuspend(h);
+
+    TPD_DMESG("TPD enter sleep done\n");
+} 
+
+static struct tpd_driver_t tpd_device_driver = {
+     .tpd_device_name = MSG_TP_IC_NAME,
+     .tpd_local_init = tpd_local_init,
+     .suspend = tpd_suspend,
+     .resume = tpd_resume,
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+     .tpd_have_button = 1,
+#else
+     .tpd_have_button = 0,
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE        
+#endif //CONFIG_TP_HAVE_KEY        
+};
+
+static int __init tpd_driver_init(void) 
+{
+    TPD_DMESG("touch panel driver init\n");
+
+    i2c_register_board_info(I2C_BUS_ID, &i2c_tpd, 1);
+    if (tpd_driver_add(&tpd_device_driver) < 0)
+    {
+        TPD_DMESG("TPD add driver failed\n");
+    }
+     
+    return 0;
+}
+ 
+static void __exit tpd_driver_exit(void) 
+{
+    TPD_DMESG("touch panel driver exit\n");
+    
+    tpd_driver_remove(&tpd_device_driver);
+}
+
+module_init(tpd_driver_init);
+module_exit(tpd_driver_exit);
+MODULE_LICENSE("GPL");
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_interface.c b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_interface.c
new file mode 100644
index 0000000..8ca0510
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_interface.c
@@ -0,0 +1,147 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_interface.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_platform_interface.h"
+#include "mstar_drv_main.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+#include "mstar_drv_platform_porting_layer.h"
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u16 g_GestureWakeupMode;
+extern u8 g_GestureWakeupFlag;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+extern struct input_dev *g_InputDevice;
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+void MsDrvInterfaceTouchDeviceSuspend(struct early_suspend *pSuspend)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+//    g_GestureWakeupMode = 0x1FFF; // Enable all gesture wakeup mode for testing 
+
+    if (g_GestureWakeupMode != 0x0000)
+    {
+        DrvIcFwLyrOpenGestureWakeup(g_GestureWakeupMode);
+        return;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    DrvPlatformLyrFingerTouchReleased(0, 0); // Send touch end for clearing point touch
+    input_sync(g_InputDevice);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+    DrvPlatformLyrTouchDevicePowerOff(); 
+}
+
+void MsDrvInterfaceTouchDeviceResume(struct early_suspend *pSuspend)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        DrvIcFwLyrCloseGestureWakeup();
+    }
+    else
+    {
+        DrvPlatformLyrEnableFingerTouchReport(); 
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+    
+    DrvPlatformLyrTouchDevicePowerOn();
+/*
+    DrvPlatformLyrFingerTouchReleased(0, 0);
+    input_sync(g_InputDevice);
+*/    
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    DrvIcFwLyrRestoreFirmwareModeToLogDataMode();
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifndef CONFIG_ENABLE_GESTURE_WAKEUP
+    DrvPlatformLyrEnableFingerTouchReport(); 
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+}
+
+/* probe function is used for matching and initializing input device */
+s32 /*__devinit*/ MsDrvInterfaceTouchDeviceProbe(struct i2c_client *pClient, const struct i2c_device_id *pDeviceId)
+{
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+  
+    DrvPlatformLyrInputDeviceInitialize(pClient);
+  
+    DrvPlatformLyrTouchDeviceRequestGPIO();
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+    DrvPlatformLyrTouchDeviceRegulatorPowerOn();
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+    DrvPlatformLyrTouchDevicePowerOn();
+
+    DrvMainTouchDeviceInitialize();
+
+    DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler();
+
+    DrvPlatformLyrTouchDeviceRegisterEarlySuspend();
+
+    DBG("*** MStar touch driver registered ***\n");
+    
+    return nRetVal;
+}
+
+/* remove function is triggered when the input device is removed from input sub-system */
+s32 /*__devexit*/ MsDrvInterfaceTouchDeviceRemove(struct i2c_client *pClient)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return DrvPlatformLyrTouchDeviceRemove(pClient);
+}
+
+void MsDrvInterfaceTouchDeviceSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    DrvPlatformLyrSetIicDataRate(pClient, nIicDataRate);
+}    
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_interface.h b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_interface.h
new file mode 100644
index 0000000..251c45a
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_interface.h
@@ -0,0 +1,47 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_interface.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_INTERFACE_H__
+#define __MSTAR_DRV_PLATFORM_INTERFACE_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern s32 /*__devinit*/ MsDrvInterfaceTouchDeviceProbe(struct i2c_client *pClient, const struct i2c_device_id *pDeviceId);
+extern s32 /*__devexit*/ MsDrvInterfaceTouchDeviceRemove(struct i2c_client *pClient);
+extern void MsDrvInterfaceTouchDeviceResume(struct early_suspend *pSuspend);        
+extern void MsDrvInterfaceTouchDeviceSuspend(struct early_suspend *pSuspend);
+extern void MsDrvInterfaceTouchDeviceSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate);
+        
+#endif  /* __MSTAR_DRV_PLATFORM_INTERFACE_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_porting_layer.c b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_porting_layer.c
new file mode 100644
index 0000000..944a900
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_porting_layer.c
@@ -0,0 +1,598 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_porting_layer.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+#include "mstar_drv_platform_interface.h"
+
+/*=============================================================*/
+// EXTREN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern struct kset *g_TouchKSet;
+extern struct kobject *g_TouchKObj;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+extern struct tpd_device *tpd;
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+extern struct regulator *g_ReguVdd;
+#endif
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+struct mutex g_Mutex;
+static struct work_struct _gFingerTouchWork;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+static struct early_suspend _gEarlySuspend;
+#endif
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifndef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+static DECLARE_WAIT_QUEUE_HEAD(_gWaiter);
+static struct task_struct *_gThread = NULL;
+static int _gTpdFlag = 0;
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_TP_HAVE_KEY
+const int g_TpVirtualKey[] = {TOUCH_KEY_MENU, TOUCH_KEY_HOME, TOUCH_KEY_BACK, TOUCH_KEY_SEARCH};
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#define BUTTON_W (100)
+#define BUTTON_H (100)
+
+const int g_TpVirtualKeyDimLocal[MAX_KEY_NUM][4] = {{BUTTON_W/2*1,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},{BUTTON_W/2*3,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},{BUTTON_W/2*5,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H},{BUTTON_W/2*7,TOUCH_SCREEN_Y_MAX+BUTTON_H/2,BUTTON_W,BUTTON_H}};
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+struct input_dev *g_InputDevice = NULL;
+static int _gIrq = -1;
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+/* read data through I2C then report data to input sub-system when interrupt occurred */
+static void _DrvPlatformLyrFingerTouchDoWork(struct work_struct *pWork)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+    mutex_lock(&g_Mutex);
+
+    DrvIcFwLyrHandleFingerTouch(NULL, 0);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    enable_irq(MS_TS_MSG_IC_GPIO_INT);
+    enable_irq(_gIrq);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
+#endif
+
+    mutex_unlock(&g_Mutex);
+}
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+/* The interrupt service routine will be triggered when interrupt occurred */
+static irqreturn_t _DrvPlatformLyrFingerTouchInterruptHandler(s32 nIrq, void *pDeviceId)
+{
+    DBG("*** %s() ***\n", __func__);
+
+//    disable_irq_nosync(MS_TS_MSG_IC_GPIO_INT);
+    disable_irq_nosync(_gIrq);
+    schedule_work(&_gFingerTouchWork);
+
+    return IRQ_HANDLED;
+}
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+static void _DrvPlatformLyrFingerTouchInterruptHandler(void)
+{
+#ifdef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+    schedule_work(&_gFingerTouchWork);
+#else    
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+
+    _gTpdFlag = 1;
+    wake_up_interruptible(&_gWaiter); 
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+}
+
+static int _DrvPlatformLyrFingerTouchHandler(void *pUnUsed)
+{
+    struct sched_param param = { .sched_priority = RTPM_PRIO_TPD };
+    sched_setscheduler(current, SCHED_RR, &param);
+	
+    do
+    {
+        set_current_state(TASK_INTERRUPTIBLE);
+        wait_event_interruptible(_gWaiter, _gTpdFlag != 0);
+        _gTpdFlag = 0;
+        
+        set_current_state(TASK_RUNNING);
+
+        mutex_lock(&g_Mutex);
+
+        DrvIcFwLyrHandleFingerTouch(NULL, 0);
+
+        mutex_unlock(&g_Mutex);
+
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
+		
+    } while (!kthread_should_stop());
+	
+    return 0;
+}
+#endif
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+void DrvPlatformLyrTouchDeviceRegulatorPowerOn(void)
+{
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+    
+    nRetVal = regulator_set_voltage(g_ReguVdd, 2800000, 2800000); // For specific SPRD BB chip(ex. SC7715) or QCOM BB chip, need to enable this function call for correctly power on Touch IC.
+
+    if (nRetVal)
+    {
+        DBG("Could not set to 2800mv.\n");
+    }
+    regulator_enable(g_ReguVdd);
+
+    mdelay(20); //mdelay(100);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    hwPowerOn(MT6323_POWER_LDO_VGP1, VOL_2800, "TP"); // For specific MTK BB chip(ex. MT6582), need to enable this function call for correctly power on Touch IC.
+#endif
+}
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+void DrvPlatformLyrTouchDevicePowerOn(void)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 1);
+//    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1); 
+//    mdelay(100);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+    mdelay(10);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1);
+    mdelay(300);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+
+#ifdef TPD_CLOSE_POWER_IN_SLEEP
+    hwPowerDown(TPD_POWER_SOURCE, "TP"); 
+    mdelay(100);
+    hwPowerOn(TPD_POWER_SOURCE, VOL_2800, "TP"); 
+    mdelay(10);  // reset pulse
+#endif //TPD_CLOSE_POWER_IN_SLEEP
+
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    mdelay(180); // wait stable
+#endif
+}
+
+void DrvPlatformLyrTouchDevicePowerOff(void)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 0);
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+#ifdef TPD_CLOSE_POWER_IN_SLEEP
+    hwPowerDown(TPD_POWER_SOURCE, "TP");
+#endif //TPD_CLOSE_POWER_IN_SLEEP
+#endif    
+}
+
+void DrvPlatformLyrTouchDeviceResetHw(void)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 1);
+//    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1); 
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+    mdelay(100); 
+    gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1);
+    mdelay(100); 
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    mdelay(10);
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ZERO);  
+    mdelay(50);
+    mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_RST, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_RST, GPIO_DIR_OUT);
+    mt_set_gpio_out(MS_TS_MSG_IC_GPIO_RST, GPIO_OUT_ONE);
+    mdelay(50); 
+#endif
+}
+
+void DrvPlatformLyrDisableFingerTouchReport(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    disable_irq(MS_TS_MSG_IC_GPIO_RST);
+    disable_irq(_gIrq);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif
+}
+
+void DrvPlatformLyrEnableFingerTouchReport(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    enable_irq(MS_TS_MSG_IC_GPIO_RST);
+    enable_irq(_gIrq);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+#endif
+}
+
+void DrvPlatformLyrFingerTouchPressed(s32 nX, s32 nY, s32 nPressure, s32 nId)
+{
+    DBG("*** %s() ***\n", __func__);
+    DBG("point touch pressed\n");
+
+    input_report_key(g_InputDevice, BTN_TOUCH, 1);
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    input_report_abs(g_InputDevice, ABS_MT_TRACKING_ID, nId);
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+    input_report_abs(g_InputDevice, ABS_MT_TOUCH_MAJOR, 1);
+    input_report_abs(g_InputDevice, ABS_MT_WIDTH_MAJOR, 1);
+    input_report_abs(g_InputDevice, ABS_MT_POSITION_X, nX);
+    input_report_abs(g_InputDevice, ABS_MT_POSITION_Y, nY);
+
+    input_mt_sync(g_InputDevice);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_TP_HAVE_KEY    
+    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+    {   
+        tpd_button(nX, nY, 1);  
+    }
+#endif //CONFIG_TP_HAVE_KEY
+
+    TPD_EM_PRINT(nX, nY, nX, nY, nPressure-1, 1);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+}
+
+void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY)
+{
+    DBG("*** %s() ***\n", __func__);
+    DBG("point touch released\n");
+
+    input_report_key(g_InputDevice, BTN_TOUCH, 0);
+    input_mt_sync(g_InputDevice);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_TP_HAVE_KEY 
+    if (FACTORY_BOOT == get_boot_mode() || RECOVERY_BOOT == get_boot_mode())
+    {   
+       tpd_button(nX, nY, 0); 
+//       tpd_button(0, 0, 0); 
+    }            
+#endif //CONFIG_TP_HAVE_KEY    
+
+    TPD_EM_PRINT(nX, nY, nX, nY, 0, 0);
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+}
+
+s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient)
+{
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    mutex_init(&g_Mutex);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    /* allocate an input device */
+    g_InputDevice = input_allocate_device();
+    if (g_InputDevice == NULL)
+    {
+        DBG("*** input device allocation failed ***\n");
+        return -ENOMEM;
+    }
+
+    g_InputDevice->name = pClient->name;
+    g_InputDevice->phys = "I2C";
+    g_InputDevice->dev.parent = &pClient->dev;
+    g_InputDevice->id.bustype = BUS_I2C;
+    
+    /* set the supported event type for input device */
+    set_bit(EV_ABS, g_InputDevice->evbit);
+    set_bit(EV_SYN, g_InputDevice->evbit);
+    set_bit(EV_KEY, g_InputDevice->evbit);
+    set_bit(BTN_TOUCH, g_InputDevice->keybit);
+    set_bit(INPUT_PROP_DIRECT, g_InputDevice->propbit);
+
+#ifdef CONFIG_TP_HAVE_KEY
+    {
+        u32 i;
+        for (i = 0; i < MAX_KEY_NUM; i ++)
+        {
+            input_set_capability(g_InputDevice, EV_KEY, g_TpVirtualKey[i]);
+        }
+    }
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    input_set_capability(g_InputDevice, EV_KEY, KEY_POWER);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_UP);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_DOWN);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_LEFT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_RIGHT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_W);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_Z);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_V);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_O);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_M);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_C);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_E);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_S);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*
+#ifdef CONFIG_TP_HAVE_KEY
+    set_bit(TOUCH_KEY_MENU, g_InputDevice->keybit); //Menu
+    set_bit(TOUCH_KEY_HOME, g_InputDevice->keybit); //Home
+    set_bit(TOUCH_KEY_BACK, g_InputDevice->keybit); //Back
+    set_bit(TOUCH_KEY_SEARCH, g_InputDevice->keybit); //Search
+#endif
+*/
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    input_set_abs_params(g_InputDevice, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+    input_set_abs_params(g_InputDevice, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_X, TOUCH_SCREEN_X_MIN, TOUCH_SCREEN_X_MAX, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_Y, TOUCH_SCREEN_Y_MIN, TOUCH_SCREEN_Y_MAX, 0, 0);
+
+    /* register the input device to input sub-system */
+    nRetVal = input_register_device(g_InputDevice);
+    if (nRetVal < 0)
+    {
+        DBG("*** Unable to register touch input device ***\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    g_InputDevice = tpd->dev;
+
+//    g_InputDevice->name = pClient->name;
+    g_InputDevice->phys = "I2C";
+    g_InputDevice->dev.parent = &pClient->dev;
+    g_InputDevice->id.bustype = BUS_I2C;
+    
+    /* set the supported event type for input device */
+    set_bit(EV_ABS, g_InputDevice->evbit);
+    set_bit(EV_SYN, g_InputDevice->evbit);
+    set_bit(EV_KEY, g_InputDevice->evbit);
+    set_bit(BTN_TOUCH, g_InputDevice->keybit);
+    set_bit(INPUT_PROP_DIRECT, g_InputDevice->propbit);
+
+#ifdef CONFIG_TP_HAVE_KEY
+    {
+        u32 i;
+        for (i = 0; i < MAX_KEY_NUM; i ++)
+        {
+            input_set_capability(g_InputDevice, EV_KEY, g_TpVirtualKey[i]);
+        }
+    }
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    input_set_capability(g_InputDevice, EV_KEY, KEY_POWER);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_UP);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_DOWN);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_LEFT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_RIGHT);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_W);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_Z);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_V);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_O);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_M);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_C);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_E);
+    input_set_capability(g_InputDevice, EV_KEY, KEY_S);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*
+#ifdef CONFIG_TP_HAVE_KEY
+    set_bit(TOUCH_KEY_MENU, g_InputDevice->keybit); //Menu
+    set_bit(TOUCH_KEY_HOME, g_InputDevice->keybit); //Home
+    set_bit(TOUCH_KEY_BACK, g_InputDevice->keybit); //Back
+    set_bit(TOUCH_KEY_SEARCH, g_InputDevice->keybit); //Search
+#endif
+*/
+
+#if defined(CONFIG_ENABLE_CHIP_MSG26XXM)
+    input_set_abs_params(g_InputDevice, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+#endif //CONFIG_ENABLE_CHIP_MSG26XXM
+    input_set_abs_params(g_InputDevice, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_X, TOUCH_SCREEN_X_MIN, TOUCH_SCREEN_X_MAX, 0, 0);
+    input_set_abs_params(g_InputDevice, ABS_MT_POSITION_Y, TOUCH_SCREEN_Y_MIN, TOUCH_SCREEN_Y_MAX, 0, 0);
+#endif
+
+    return nRetVal;    
+}
+
+s32 DrvPlatformLyrTouchDeviceRequestGPIO(void)
+{
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+    
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_RST, "C_TP_RST");     
+    if (nRetVal < 0)
+    {
+        DBG("*** Failed to request GPIO %d, error %d ***\n", MS_TS_MSG_IC_GPIO_RST, nRetVal);
+    }
+
+    nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_INT, "C_TP_INT");    
+    if (nRetVal < 0)
+    {
+        DBG("*** Failed to request GPIO %d, error %d ***\n", MS_TS_MSG_IC_GPIO_INT, nRetVal);
+    }
+#endif
+
+    return nRetVal;    
+}
+
+s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void)
+{
+    s32 nRetVal = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (DrvIcFwLyrIsRegisterFingerTouchInterruptHandler())
+    {    	
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+        /* initialize the finger touch work queue */ 
+        INIT_WORK(&_gFingerTouchWork, _DrvPlatformLyrFingerTouchDoWork);
+
+        _gIrq = gpio_to_irq(MS_TS_MSG_IC_GPIO_INT);
+
+        /* request an irq and register the isr */
+        nRetVal = request_irq(_gIrq/*MS_TS_MSG_IC_GPIO_INT*/, _DrvPlatformLyrFingerTouchInterruptHandler,
+                      IRQF_TRIGGER_RISING /* | IRQF_NO_SUSPEND *//* IRQF_TRIGGER_FALLING */,
+                      "msg2xxx", NULL);
+        if (nRetVal != 0)
+        {
+            DBG("*** Unable to claim irq %d; error %d ***\n", MS_TS_MSG_IC_GPIO_INT, nRetVal);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        mt_set_gpio_mode(MS_TS_MSG_IC_GPIO_INT, GPIO_CTP_EINT_PIN_M_EINT);
+        mt_set_gpio_dir(MS_TS_MSG_IC_GPIO_INT, GPIO_DIR_IN);
+        mt_set_gpio_pull_enable(MS_TS_MSG_IC_GPIO_INT, GPIO_PULL_ENABLE);
+        mt_set_gpio_pull_select(MS_TS_MSG_IC_GPIO_INT, GPIO_PULL_UP);
+
+        mt_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
+        mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, EINTF_TRIGGER_RISING, _DrvPlatformLyrFingerTouchInterruptHandler, 1);
+
+        mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+
+#ifdef CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+        /* initialize the finger touch work queue */ 
+        INIT_WORK(&_gFingerTouchWork, _DrvPlatformLyrFingerTouchDoWork);
+#else
+        _gThread = kthread_run(_DrvPlatformLyrFingerTouchHandler, 0, TPD_DEVICE);
+        if (IS_ERR(_gThread))
+        { 
+            nRetVal = PTR_ERR(_gThread);
+            DBG("Failed to create kernel thread: %d\n", nRetVal);
+        }
+#endif //CONFIG_USE_IRQ_INTERRUPT_FOR_MTK_PLATFORM
+#endif
+    }
+    
+    return nRetVal;    
+}	
+
+void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    _gEarlySuspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+    _gEarlySuspend.suspend = MsDrvInterfaceTouchDeviceSuspend;
+    _gEarlySuspend.resume = MsDrvInterfaceTouchDeviceResume;
+    register_early_suspend(&_gEarlySuspend);
+#endif    
+}
+
+/* remove function is triggered when the input device is removed from input sub-system */
+s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient)
+{
+    DBG("*** %s() ***\n", __func__);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+//    free_irq(MS_TS_MSG_IC_GPIO_INT, g_InputDevice);
+    free_irq(_gIrq, g_InputDevice);
+    gpio_free(MS_TS_MSG_IC_GPIO_INT);
+    gpio_free(MS_TS_MSG_IC_GPIO_RST);
+    input_unregister_device(g_InputDevice);
+#endif    
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    kset_unregister(g_TouchKSet);
+    kobject_put(g_TouchKObj);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    return 0;
+}
+
+void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate)
+{
+    DBG("*** %s() nIicDataRate = %d ***\n", __func__, nIicDataRate);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    // TODO : Please FAE colleague to confirm with customer device driver engineer for how to set i2c data rate on SPRD platform
+    //sprd_i2c_ctl_chg_clk(pClient->adapter->nr, nIicDataRate); 
+    //mdelay(100);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    // TODO : Please FAE colleague to confirm with customer device driver engineer for how to set i2c data rate on QCOM platform
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    pClient->timing = nIicDataRate/1000;
+#endif
+}
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_porting_layer.h b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_porting_layer.h
new file mode 100644
index 0000000..7a9121c
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_platform_porting_layer.h
@@ -0,0 +1,155 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_platform_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+#define __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+#include <mach/board.h>
+#include <mach/gpio.h>
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <mach/regulator.h>
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/hwmsen_helper.h>
+//#include <linux/hw_module_info.h>
+
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/namei.h>
+#include <linux/vmalloc.h>
+
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+#include <mach/mt_gpio.h>
+
+#include <cust_eint.h>
+#include "tpd.h"
+#include "cust_gpio_usage.h"
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Note.
+ * Please change the below GPIO pin setting to follow the platform that you are using(EX. MediaTek, Spreadtrum, Qualcomm).
+ */
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+
+// TODO : Please FAE colleague to confirm with customer device driver engineer about the value of RST and INT GPIO setting
+#define MS_TS_MSG_IC_GPIO_RST   GPIO_CTP_RST_PIN //53 //35 
+#define MS_TS_MSG_IC_GPIO_INT   GPIO_CTP_EINT_PIN   //52 //37
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139) //229
+#define TOUCH_KEY_HOME (172) //102
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+
+// TODO : Please FAE colleague to confirm with customer device driver engineer about the value of RST and INT GPIO setting
+#define MS_TS_MSG_IC_GPIO_RST   0
+#define MS_TS_MSG_IC_GPIO_INT   1
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139) //229
+#define TOUCH_KEY_HOME (172) //102
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+
+#define MS_TS_MSG_IC_GPIO_RST   (GPIO_CTP_RST_PIN)
+#define MS_TS_MSG_IC_GPIO_INT   (GPIO_CTP_EINT_PIN)
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU    KEY_MENU 
+#define TOUCH_KEY_HOME    KEY_HOMEPAGE 
+#define TOUCH_KEY_BACK    KEY_BACK
+#define TOUCH_KEY_SEARCH  KEY_SEARCH
+
+#define MAX_KEY_NUM (4)
+#endif //CONFIG_TP_HAVE_KEY
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern void DrvPlatformLyrDisableFingerTouchReport(void);
+extern void DrvPlatformLyrEnableFingerTouchReport(void);
+extern void DrvPlatformLyrFingerTouchPressed(s32 nX, s32 nY, s32 nPressure, s32 nId);
+extern void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY);
+extern s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient);
+extern void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate);
+extern void DrvPlatformLyrTouchDevicePowerOff(void);
+extern void DrvPlatformLyrTouchDevicePowerOn(void);
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegulatorPowerOn(void);
+#endif //CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void);
+extern s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient);
+extern s32 DrvPlatformLyrTouchDeviceRequestGPIO(void);        
+extern void DrvPlatformLyrTouchDeviceResetHw(void);
+        
+#endif  /* __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_self_fw_control.c b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_self_fw_control.c
new file mode 100644
index 0000000..64f816c
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_self_fw_control.c
@@ -0,0 +1,3974 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_self_fw_control.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+ 
+/*=============================================================*/
+// INCLUDE FILE
+/*=============================================================*/
+
+#include "mstar_drv_self_fw_control.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+
+/*=============================================================*/
+// EXTERN VARIABLE DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_TP_HAVE_KEY
+extern const int g_TpVirtualKey[];
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+extern const int g_TpVirtualKeyDimLocal[][4];
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+#endif //CONFIG_TP_HAVE_KEY
+
+extern struct input_dev *g_InputDevice;
+
+extern u8 g_FwData[94][1024];
+extern u32 g_FwDataCount;
+
+extern struct mutex g_Mutex;
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern struct kobject *g_TouchKObj;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+/*=============================================================*/
+// LOCAL VARIABLE DEFINITION
+/*=============================================================*/
+
+static u8 _gTpVendorCode[3] = {0};
+
+static u8 _gDwIicInfoData[1024];
+static u8 _gOneDimenFwData[MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024+MSG22XX_FIRMWARE_INFO_BLOCK_SIZE] = {0}; // used for MSG22XX
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+/*
+ * Note.
+ * Please modify the name of the below .h depends on the vendor TP that you are using.
+ */
+#include "msg2xxx_xxxx_update_bin.h"
+#include "msg2xxx_yyyy_update_bin.h"
+
+static u32 _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+static struct work_struct _gUpdateFirmwareBySwIdWork;
+static struct workqueue_struct *_gUpdateFirmwareBySwIdWorkQueue = NULL;
+
+static u32 _gIsUpdateInfoBlockFirst = 0;
+static u8 _gIsUpdateFirmware = 0x00;
+
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+static u16 _gGestureWakeupValue = 0;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+
+/*=============================================================*/
+// GLOBAL VARIABLE DEFINITION
+/*=============================================================*/
+
+u8 g_ChipType = 0;
+u8 g_DemoModePacket[DEMO_MODE_PACKET_LENGTH] = {0};
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+FirmwareInfo_t g_FirmwareInfo;
+
+u8 *g_LogModePacket = NULL;
+u16 g_FirmwareMode = FIRMWARE_MODE_DEMO_MODE; 
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+u8 *_gGestureWakeupPacket = NULL;
+
+u16 g_GestureWakeupMode = 0x0000;
+u8 g_GestureWakeupFlag = 0;
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*=============================================================*/
+// LOCAL FUNCTION DECLARATION
+/*=============================================================*/
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+static void _DrvFwCtrlUpdateFirmwareBySwIdDoWork(struct work_struct *pWork);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*=============================================================*/
+// LOCAL FUNCTION DEFINITION
+/*=============================================================*/
+
+static void _DrvFwCtrlEraseEmemC32(void)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    /////////////////////////
+    //Erase  all
+    /////////////////////////
+    
+    // Enter gpio mode
+    RegSet16BitValue(0x161E, 0xBEAF);
+
+    // Before gpio mode, set the control pin as the orginal status
+    RegSet16BitValue(0x1608, 0x0000);
+    RegSetLByteValue(0x160E, 0x10);
+    mdelay(10); 
+
+    // ptrim = 1, h'04[2]
+    RegSetLByteValue(0x1608, 0x04);
+    RegSetLByteValue(0x160E, 0x10);
+    mdelay(10); 
+
+    // ptm = 6, h'04[12:14] = b'110
+    RegSetLByteValue(0x1609, 0x60);
+    RegSetLByteValue(0x160E, 0x10);
+
+    // pmasi = 1, h'04[6]
+    RegSetLByteValue(0x1608, 0x44);
+    // pce = 1, h'04[11]
+    RegSetLByteValue(0x1609, 0x68);
+    // perase = 1, h'04[7]
+    RegSetLByteValue(0x1608, 0xC4);
+    // pnvstr = 1, h'04[5]
+    RegSetLByteValue(0x1608, 0xE4);
+    // pwe = 1, h'04[9]
+    RegSetLByteValue(0x1609, 0x6A);
+    // trigger gpio load
+    RegSetLByteValue(0x160E, 0x10);
+}
+
+static void _DrvFwCtrlEraseEmemC33(EmemType_e eEmemType)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    // Clear pce
+    RegSetLByteValue(0x1618, 0x80);
+
+    if (eEmemType == EMEM_ALL)
+    {
+        RegSetLByteValue(0x1608, 0x10); //mark
+    }
+
+    RegSetLByteValue(0x1618, 0x40);
+    mdelay(10);
+
+    RegSetLByteValue(0x1618, 0x80);
+
+    // erase trigger
+    if (eEmemType == EMEM_MAIN)
+    {
+        RegSetLByteValue(0x160E, 0x04); //erase main
+    }
+    else
+    {
+        RegSetLByteValue(0x160E, 0x08); //erase all block
+    }
+}
+
+static void _DrvFwCtrlMsg22xxGetTpVendorCode(u8 *pTpVendorCode)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        u16 nRegData1, nRegData2;
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        mdelay(100);
+        
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        // Clear pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xC1E9); // Set start address for tp vendor code on info block(Actually, start reading from 0xC1E8)
+    
+        // Enable burst mode
+//        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        // Set pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+        RegSetLByteValue(0x160E, 0x01); 
+
+        nRegData1 = RegGet16BitValue(0x1604);
+        nRegData2 = RegGet16BitValue(0x1606);
+
+        pTpVendorCode[0] = ((nRegData1 >> 8) & 0xFF);
+        pTpVendorCode[1] = (nRegData2 & 0xFF);
+        pTpVendorCode[2] = ((nRegData2 >> 8) & 0xFF);
+
+        DBG("pTpVendorCode[0] = 0x%x , %c \n", pTpVendorCode[0], pTpVendorCode[0]); 
+        DBG("pTpVendorCode[1] = 0x%x , %c \n", pTpVendorCode[1], pTpVendorCode[1]); 
+        DBG("pTpVendorCode[2] = 0x%x , %c \n", pTpVendorCode[2], pTpVendorCode[2]); 
+        
+        // Clear burst mode
+//        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+        mdelay(100);
+    }
+}
+
+static void _DrvFwCtrlMsg22xxEraseEmem(EmemType_e eEmemType)
+{
+    u32 i;
+    u16 nRegData = 0;
+    
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    DBG("Erase start\n");
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    if (eEmemType == EMEM_ALL) // 48KB + 512Byte
+    {
+        DBG("Erase all block\n");
+
+        // Clear pce
+        RegSetLByteValue(0x1618, 0x80);
+        mdelay(100);
+
+        // Chip erase
+        RegSet16BitValue(0x160E, BIT3);
+
+        DBG("Wait erase done flag\n");
+
+        do // Wait erase done flag
+        {
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            mdelay(50);
+        } while((nRegData & BIT1) != BIT1);
+    }
+    else if (eEmemType == EMEM_MAIN) // 48KB (32+8+8)
+    {
+        DBG("Erase main block\n");
+
+        for (i = 0; i < 3; i ++)
+        {
+            // Clear pce
+            RegSetLByteValue(0x1618, 0x80);
+            mdelay(10);
+
+            if (i == 0)
+            {
+                RegSet16BitValue(0x1600, 0x0000);
+            }
+            else if (i == 1)
+            {
+                RegSet16BitValue(0x1600, 0x8000);
+            }
+            else if (i == 2)
+            {
+                RegSet16BitValue(0x1600, 0xA000);
+            }
+
+            // Sector erase
+            RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+            DBG("Wait erase done flag\n");
+
+            do // Wait erase done flag
+            {
+                nRegData = RegGet16BitValue(0x1610); // Memory status
+                mdelay(50);
+            } while((nRegData & BIT1) != BIT1);
+        }   
+    }
+    else if (eEmemType == EMEM_INFO) // 512Byte
+    {
+        DBG("Erase info block\n");
+
+        // Clear pce
+        RegSetLByteValue(0x1618, 0x80);
+        mdelay(10);
+
+        RegSet16BitValue(0x1600, 0xC000);
+        
+        // Sector erase
+        RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+        DBG("Wait erase done flag\n");
+
+        do // Wait erase done flag
+        {
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            mdelay(50);
+        } while((nRegData & BIT1) != BIT1);
+    }
+    
+    DBG("Erase end\n");
+    
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+}
+
+static void _DrvFwCtrlMsg22xxProgramEmem(EmemType_e eEmemType) // For MSG22XX
+{
+    u32 i, j; 
+    u32 nRemainSize = 0, nBlockSize = 0, nSize = 0, index = 0;
+    u16 nRegData;
+    u8 szDbBusTxData[1024] = {0};
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u32 nSizePerWrite = 125;
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    u32 nSizePerWrite = 1021;
+#endif
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+
+    // Hold reset pin before program
+    RegSetLByteValue(0x1E06, 0x00);
+
+    DBG("Program start\n");
+
+    RegSet16BitValue(0x161A, 0xABBA);
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+    if (eEmemType == EMEM_MAIN)
+    {
+        DBG("Program main block\n");
+
+        RegSet16BitValue(0x1600, 0x0000); // Set start address of main block
+        nRemainSize = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024; //48KB
+        index = 0;
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        DBG("Program info block\n");
+
+        RegSet16BitValue(0x1600, 0xC000); // Set start address of info block
+        nRemainSize = MSG22XX_FIRMWARE_INFO_BLOCK_SIZE; //512Byte
+        index = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024;
+    }
+    else
+    {
+        DBG("eEmemType = %d is not supported for program e-memory.\n", eEmemType);
+        return;
+    }
+
+    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+
+    // Program start
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x16;
+    szDbBusTxData[2] = 0x02;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+
+    szDbBusTxData[0] = 0x20;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+    i = 0;
+    
+    while (nRemainSize > 0)
+    {
+        if (nRemainSize > nSizePerWrite)
+        {
+            nBlockSize = nSizePerWrite;
+        }
+        else
+        {
+            nBlockSize = nRemainSize;
+        }
+
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+
+        nSize = 3;
+
+        for (j = 0; j < nBlockSize; j ++)
+        {
+            szDbBusTxData[3+j] = _gOneDimenFwData[index+(i*nSizePerWrite)+j];
+            nSize ++; 
+        }
+        i ++;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+
+        nRemainSize = nRemainSize - nBlockSize;
+    }
+
+    // Program end
+    szDbBusTxData[0] = 0x21;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+    nRegData = RegGet16BitValue(0x160C); 
+    RegSet16BitValue(0x160C, nRegData & (~0x01));      
+
+    DBG("Wait write done flag\n");
+
+    // Polling 0x1610 is 0x0002
+    do
+    {
+        nRegData = RegGet16BitValue(0x1610);
+        nRegData = nRegData & BIT1;
+        mdelay(10);
+
+    } while (nRegData != BIT1); // Wait write done flag
+
+    DBG("Program end\n");
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+}
+
+static u32 _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EmemType_e eEmemType) // For MSG22XX
+{
+    u16 nCrcDown = 0;
+    u32 nRetVal = 0; 
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA);      
+
+    // Set PCE high
+    RegSetLByteValue(0x1618, 0x40);      
+
+    if (eEmemType == EMEM_MAIN)
+    {
+        // Set start address and end address for main block
+        RegSet16BitValue(0x1600, 0x0000);      
+        RegSet16BitValue(0x1640, 0xBFF8);      
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        // Set start address and end address for info block
+        RegSet16BitValue(0x1600, 0xC000);      
+        RegSet16BitValue(0x1640, 0xC1F8);      
+    }
+
+    // CRC reset
+    RegSet16BitValue(0x164E, 0x0001);      
+
+    RegSet16BitValue(0x164E, 0x0000);   
+    
+    // Trigger CRC check
+    RegSetLByteValue(0x160E, 0x20);   
+    mdelay(10);
+       
+    nCrcDown = RegGet16BitValue(0x164E);
+    
+    while (nCrcDown != 2)
+    {
+        DBG("Wait CRC down\n");
+        mdelay(10);
+        nCrcDown = RegGet16BitValue(0x164E);
+    }
+
+    nRetVal = RegGet16BitValue(0x1652);
+    nRetVal = (nRetVal << 16) | RegGet16BitValue(0x1650);
+
+    DBG("Hardware CRC = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static void _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(u8 szTwoDimenFwData[][1024], u8* pOneDimenFwData)
+{
+    u32 i, j;
+
+    DBG("*** %s() ***\n", __func__);
+
+    for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+    {
+        if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                pOneDimenFwData[i*1024+j] = szTwoDimenFwData[i][j];
+            }
+        }
+        else // i == 48
+        {
+            for (j = 0; j < 512; j ++)
+            {
+                pOneDimenFwData[i*1024+j] = szTwoDimenFwData[i][j];
+            }
+        }
+    }
+}
+
+static s32 _DrvFwCtrlParsePacket(u8 *pPacket, u16 nLength, TouchInfo_t *pInfo)
+{
+    u8 nCheckSum = 0;
+    u32 nDeltaX = 0, nDeltaY = 0;
+    u32 nX = 0;
+    u32 nY = 0;
+#ifdef CONFIG_SWAP_X_Y
+    u32 nTempX;
+    u32 nTempY;
+#endif
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    u8 nCheckSumIndex = 0;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+    {
+        nCheckSumIndex = 7;
+    }
+    else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE || g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE)
+    {
+        nCheckSumIndex = 31;
+    }
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        nCheckSumIndex = nLength-1;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    nCheckSum = DrvCommonCalculateCheckSum(&pPacket[0], nCheckSumIndex);
+    DBG("check sum : [%x] == [%x]? \n", pPacket[nCheckSumIndex], nCheckSum);
+#else
+    nCheckSum = DrvCommonCalculateCheckSum(&pPacket[0], (nLength-1));
+    DBG("check ksum : [%x] == [%x]? \n", pPacket[nLength-1], nCheckSum);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        u8 nWakeupMode = 0;
+        u8 bIsCorrectFormat = 0;
+
+        DBG("received raw data from touch panel as following:\n");
+        DBG("pPacket[0]=%x \n pPacket[1]=%x pPacket[2]=%x pPacket[3]=%x pPacket[4]=%x pPacket[5]=%x \n", \
+            pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5]);
+
+        if (g_ChipType == CHIP_TYPE_MSG22XX && pPacket[0] == 0xA7 && pPacket[1] == 0x00 && pPacket[2] == 0x06 && pPacket[3] == 0x50)
+        {
+            nWakeupMode = pPacket[4];
+            bIsCorrectFormat = 1;
+        } 
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA && pPacket[0] == 0x52 && pPacket[1] == 0xFF && pPacket[2] == 0xFF && pPacket[3] == 0xFF && pPacket[4] == 0xFF && pPacket[6] == 0xFF)
+        {
+            nWakeupMode = pPacket[5];
+            bIsCorrectFormat = 1;
+        }
+        
+        if (bIsCorrectFormat) 
+        {
+            DBG("nWakeupMode = 0x%x\n", nWakeupMode);
+
+            switch (nWakeupMode)
+            {
+                case 0x58:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+
+                    DBG("Light up screen by DOUBLE_CLICK gesture wakeup.\n");
+
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x60:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+                    
+                    DBG("Light up screen by UP_DIRECT gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_UP, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_UP, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x61:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+
+                    DBG("Light up screen by DOWN_DIRECT gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_DOWN, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_DOWN, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x62:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+
+                    DBG("Light up screen by LEFT_DIRECT gesture wakeup.\n");
+
+//                  input_report_key(g_InputDevice, KEY_LEFT, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_LEFT, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x63:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+
+                    DBG("Light up screen by RIGHT_DIRECT gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_RIGHT, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_RIGHT, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x64:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+
+                    DBG("Light up screen by m_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_M, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_M, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x65:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+
+                    DBG("Light up screen by W_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_W, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_W, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;		
+                case 0x66:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+
+                    DBG("Light up screen by C_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_C, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_C, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x67:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+
+                    DBG("Light up screen by e_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_E, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_E, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x68:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+
+                    DBG("Light up screen by V_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_V, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_V, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x69:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+
+                    DBG("Light up screen by O_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_O, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_O, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x6A:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+
+                    DBG("Light up screen by S_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_S, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_S, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                case 0x6B:
+                    _gGestureWakeupValue = GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+
+                    DBG("Light up screen by Z_CHARACTER gesture wakeup.\n");
+
+//                    input_report_key(g_InputDevice, KEY_Z, 1);
+                    input_report_key(g_InputDevice, KEY_POWER, 1);
+                    input_sync(g_InputDevice);
+//                    input_report_key(g_InputDevice, KEY_Z, 0);
+                    input_report_key(g_InputDevice, KEY_POWER, 0);
+                    input_sync(g_InputDevice);
+                    break;
+                default:
+                    _gGestureWakeupValue = 0;
+                    break;		
+            }
+
+            DBG("_gGestureWakeupValue = 0x%x\n", _gGestureWakeupValue);
+        }
+        else
+        {
+            DBG("gesture wakeup packet format is incorrect.\n");
+        }
+        
+        return -1;
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+    DBG("received raw data from touch panel as following:\n");
+    DBG("pPacket[0]=%x \n pPacket[1]=%x pPacket[2]=%x pPacket[3]=%x pPacket[4]=%x \n pPacket[5]=%x pPacket[6]=%x pPacket[7]=%x \n", \
+                pPacket[0], pPacket[1], pPacket[2], pPacket[3], pPacket[4], pPacket[5], pPacket[6], pPacket[7]);
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    if ((pPacket[nCheckSumIndex] == nCheckSum) && (pPacket[0] == 0x52))   // check the checksum of packet
+#else
+    if ((pPacket[nLength-1] == nCheckSum) && (pPacket[0] == 0x52))   // check the checksum of packet
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    {
+        nX = (((pPacket[1] & 0xF0) << 4) | pPacket[2]);         // parse the packet to coordinate
+        nY = (((pPacket[1] & 0x0F) << 8) | pPacket[3]);
+
+        nDeltaX = (((pPacket[4] & 0xF0) << 4) | pPacket[5]);
+        nDeltaY = (((pPacket[4] & 0x0F) << 8) | pPacket[6]);
+
+        DBG("[x,y]=[%d,%d]\n", nX, nY);
+        DBG("[delta_x,delta_y]=[%d,%d]\n", nDeltaX, nDeltaY);
+
+#ifdef CONFIG_SWAP_X_Y
+        nTempY = nX;
+        nTempX = nY;
+        nX = nTempX;
+        nY = nTempY;
+        
+        nTempY = nDeltaX;
+        nTempX = nDeltaY;
+        nDeltaX = nTempX;
+        nDeltaY = nTempY;
+#endif
+
+#ifdef CONFIG_REVERSE_X
+        nX = 2047 - nX;
+        nDeltaX = 4095 - nDeltaX;
+#endif
+
+#ifdef CONFIG_REVERSE_Y
+        nY = 2047 - nY;
+        nDeltaY = 4095 - nDeltaY;
+#endif
+
+        /*
+         * pPacket[0]:id, pPacket[1]~pPacket[3]:the first point abs, pPacket[4]~pPacket[6]:the relative distance between the first point abs and the second point abs
+         * when pPacket[1]~pPacket[4], pPacket[6] is 0xFF, keyevent, pPacket[5] to judge which key press.
+         * pPacket[1]~pPacket[6] all are 0xFF, release touch
+        */
+        if ((pPacket[1] == 0xFF) && (pPacket[2] == 0xFF) && (pPacket[3] == 0xFF) && (pPacket[4] == 0xFF) && (pPacket[6] == 0xFF))
+        {
+            pInfo->tPoint[0].nX = 0; // final X coordinate
+            pInfo->tPoint[0].nY = 0; // final Y coordinate
+
+            if ((pPacket[5] != 0x00) && (pPacket[5] != 0xFF)) /* pPacket[5] is key value */
+            {   /* 0x00 is key up, 0xff is touch screen up */
+                DBG("touch key down pPacket[5]=%d\n", pPacket[5]);
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = pPacket[5];
+                pInfo->nTouchKeyMode = 1;
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;
+
+                if (pPacket[5] == 4) // TOUCH_KEY_HOME
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[1][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[1][1];
+                }
+                else if (pPacket[5] == 1) // TOUCH_KEY_MENU
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[0][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[0][1];
+                }           
+                else if (pPacket[5] == 2) // TOUCH_KEY_BACK
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[2][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[2][1];
+                }           
+                else if (pPacket[5] == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[3][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[3][1];
+                }
+                else
+                {
+                    DBG("multi-key is pressed.\n");
+
+                    return -1;
+                }
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+            }
+            else
+            {   /* key up or touch up */
+                DBG("touch end\n");
+                pInfo->nFingerNum = 0; //touch end
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;    
+            }
+        }
+        else
+        {
+            pInfo->nTouchKeyMode = 0; //Touch on screen...
+
+//            if ((nDeltaX == 0) && (nDeltaY == 0))
+          if(
+#ifdef CONFIG_REVERSE_X
+                (nDeltaX == 4095)
+#else
+                (nDeltaX == 0)
+#endif
+                &&
+#ifdef CONFIG_REVERSE_Y
+                (nDeltaY == 4095)
+#else
+                (nDeltaY == 0)
+#endif
+            )
+            {   /* one touch point */
+                pInfo->nFingerNum = 1; // one touch
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: [x,y]=[%d,%d]\n", __func__, nX, nY);
+                DBG("[%s]: point[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+            }
+            else
+            {   /* two touch points */
+                u32 nX2, nY2;
+                
+                pInfo->nFingerNum = 2; // two touch
+                /* Finger 1 */
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: point1[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+                /* Finger 2 */
+                if (nDeltaX > 2048)     // transform the unsigned value to signed value
+                {
+                    nDeltaX -= 4096;
+                }
+                
+                if (nDeltaY > 2048)
+                {
+                    nDeltaY -= 4096;
+                }
+
+                nX2 = (u32)(nX + nDeltaX);
+                nY2 = (u32)(nY + nDeltaY);
+
+                pInfo->tPoint[1].nX = (nX2 * TOUCH_SCREEN_X_MAX) / TPD_WIDTH; 
+                pInfo->tPoint[1].nY = (nY2 * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: point2[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[1].nX, pInfo->tPoint[1].nY);
+            }
+        }
+    }
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    else if (pPacket[nCheckSumIndex] == nCheckSum && pPacket[0] == 0x62)
+    {
+        nX = ((pPacket[1] << 8) | pPacket[2]);  // Position_X
+        nY = ((pPacket[3] << 8) | pPacket[4]);  // Position_Y
+
+        nDeltaX = ((pPacket[13] << 8) | pPacket[14]); // Distance_X
+        nDeltaY = ((pPacket[15] << 8) | pPacket[16]); // Distance_Y
+
+        DBG("[x,y]=[%d,%d]\n", nX, nY);
+        DBG("[delta_x,delta_y]=[%d,%d]\n", nDeltaX, nDeltaY);
+
+#ifdef CONFIG_SWAP_X_Y
+        nTempY = nX;
+        nTempX = nY;
+        nX = nTempX;
+        nY = nTempY;
+        
+        nTempY = nDeltaX;
+        nTempX = nDeltaY;
+        nDeltaX = nTempX;
+        nDeltaY = nTempY;
+#endif
+
+#ifdef CONFIG_REVERSE_X
+        nX = 2047 - nX;
+        nDeltaX = 4095 - nDeltaX;
+#endif
+
+#ifdef CONFIG_REVERSE_Y
+        nY = 2047 - nY;
+        nDeltaY = 4095 - nDeltaY;
+#endif
+
+        /*
+         * pPacket[0]:id, pPacket[1]~pPacket[4]:the first point abs, pPacket[13]~pPacket[16]:the relative distance between the first point abs and the second point abs
+         * when pPacket[1]~pPacket[7] is 0xFF, keyevent, pPacket[8] to judge which key press.
+         * pPacket[1]~pPacket[8] all are 0xFF, release touch
+         */
+        if ((pPacket[1] == 0xFF) && (pPacket[2] == 0xFF) && (pPacket[3] == 0xFF) && (pPacket[4] == 0xFF) && (pPacket[5] == 0xFF) && (pPacket[6] == 0xFF) && (pPacket[7] == 0xFF))
+        {
+            pInfo->tPoint[0].nX = 0; // final X coordinate
+            pInfo->tPoint[0].nY = 0; // final Y coordinate
+
+            if ((pPacket[8] != 0x00) && (pPacket[8] != 0xFF)) /* pPacket[8] is key value */
+            {   /* 0x00 is key up, 0xff is touch screen up */
+                DBG("touch key down pPacket[8]=%d\n", pPacket[8]);
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = pPacket[8];
+                pInfo->nTouchKeyMode = 1;
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+                pInfo->nFingerNum = 1;
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;
+
+                if (pPacket[8] == 4) // TOUCH_KEY_HOME
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[1][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[1][1];
+                }
+                else if (pPacket[8] == 1) // TOUCH_KEY_MENU
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[0][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[0][1];
+                }           
+                else if (pPacket[8] == 2) // TOUCH_KEY_BACK
+                {
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[2][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[2][1];
+                }           
+                else if (pPacket[8] == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    pInfo->tPoint[0].nX = g_TpVirtualKeyDimLocal[3][0];
+                    pInfo->tPoint[0].nY = g_TpVirtualKeyDimLocal[3][1];
+                }
+                else
+                {
+                    DBG("multi-key is pressed.\n");
+
+                    return -1;
+                }
+#endif //CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+            }
+            else
+            {   /* key up or touch up */
+                DBG("touch end\n");
+                pInfo->nFingerNum = 0; //touch end
+                pInfo->nTouchKeyCode = 0;
+                pInfo->nTouchKeyMode = 0;    
+            }
+        }
+        else
+        {
+            pInfo->nTouchKeyMode = 0; //Touch on screen...
+
+//            if ((nDeltaX == 0) && (nDeltaY == 0))
+            if (
+#ifdef CONFIG_REVERSE_X
+                (nDeltaX == 4095)
+#else
+                (nDeltaX == 0)
+#endif
+                &&
+#ifdef CONFIG_REVERSE_Y
+                (nDeltaY == 4095)
+#else
+                (nDeltaY == 0)
+#endif
+                )
+            {   /* one touch point */
+                pInfo->nFingerNum = 1; // one touch
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: [x,y]=[%d,%d]\n", __func__, nX, nY);
+                DBG("[%s]: point[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+            }
+            else
+            {   /* two touch points */
+                u32 nX2, nY2;
+                
+                pInfo->nFingerNum = 2; // two touch
+                /* Finger 1 */
+                pInfo->tPoint[0].nX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+                pInfo->tPoint[0].nY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: point1[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[0].nX, pInfo->tPoint[0].nY);
+                /* Finger 2 */
+                if (nDeltaX > 2048)     // transform the unsigned value to signed value
+                {
+                    nDeltaX -= 4096;
+                }
+                
+                if (nDeltaY > 2048)
+                {
+                    nDeltaY -= 4096;
+                }
+
+                nX2 = (u32)(nX + nDeltaX);
+                nY2 = (u32)(nY + nDeltaY);
+
+                pInfo->tPoint[1].nX = (nX2 * TOUCH_SCREEN_X_MAX) / TPD_WIDTH; 
+                pInfo->tPoint[1].nY = (nY2 * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+                DBG("[%s]: point2[x,y]=[%d,%d]\n", __func__, pInfo->tPoint[1].nX, pInfo->tPoint[1].nY);
+            }
+
+            // Notify android application to retrieve log data mode packet from device driver by sysfs.   
+            if (g_TouchKObj != NULL)
+            {
+                char *pEnvp[2];
+                s32 nRetVal = 0; 
+
+                pEnvp[0] = "STATUS=GET_PACKET";  
+                pEnvp[1] = NULL;  
+    
+                nRetVal = kobject_uevent_env(g_TouchKObj, KOBJ_CHANGE, pEnvp); 
+                DBG("kobject_uevent_env() nRetVal = %d\n", nRetVal);
+            }
+        }
+    }
+    else
+    {
+        if (pPacket[nCheckSumIndex] != nCheckSum)
+        {
+            DBG("WRONG CHECKSUM\n");
+            return -1;
+        }
+
+        if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE && pPacket[0] != 0x52)
+        {
+            DBG("WRONG DEMO MODE HEADER\n");
+            return -1;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && pPacket[0] != 0x62)
+        {
+            DBG("WRONG DEBUG MODE HEADER\n");
+            return -1;
+        }
+        else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE && pPacket[0] != 0x62)
+        {
+            DBG("WRONG RAW DATA MODE HEADER\n");
+            return -1;
+        }
+    }
+#else    
+    else
+    {
+        DBG("pPacket[0]=0x%x, pPacket[7]=0x%x, nCheckSum=0x%x\n", pPacket[0], pPacket[7], nCheckSum);
+
+        if (pPacket[nLength-1] != nCheckSum)
+        {
+            DBG("WRONG CHECKSUM\n");
+            return -1;
+        }
+
+        if (pPacket[0] != 0x52)
+        {
+            DBG("WRONG DEMO MODE HEADER\n");
+            return -1;
+        }
+    }
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+    return 0;
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+static void _DrvFwCtrlStoreFirmwareData(u8 *pBuf, u32 nSize)
+{
+    u32 nCount = nSize / 1024;
+    u32 i;
+
+    DBG("*** %s() ***\n", __func__);
+
+    if (nCount > 0) // nSize >= 1024
+   	{
+        for (i = 0; i < nCount; i ++)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuf+(i*1024), 1024);
+
+            g_FwDataCount ++;
+        }
+    }
+    else // nSize < 1024
+    {
+        if (nSize > 0)
+        {
+            memcpy(g_FwData[g_FwDataCount], pBuf, nSize);
+
+            g_FwDataCount ++;
+        }
+    }
+
+    DBG("*** g_FwDataCount = %d ***\n", g_FwDataCount);
+
+    if (pBuf != NULL)
+    {
+        DBG("*** buf[0] = %c ***\n", pBuf[0]);
+    }
+}
+
+//-------------------------Start of SW ID for MSG22XX----------------------------//
+
+static u32 _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EmemType_e eEmemType) // For MSG22XX
+{
+    u32 nRetVal = 0; 
+    u16 nRegData1 = 0, nRegData2 = 0;
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA); 
+
+    // Clear pce
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+    if (eEmemType == EMEM_MAIN) // Read main block CRC(48KB-4) from main block
+    {
+        RegSet16BitValue(0x1600, 0xBFFC); // Set start address for main block CRC
+    }
+    else if (eEmemType == EMEM_INFO) // Read info block CRC(512Byte-4) from info block
+    {
+        RegSet16BitValue(0x1600, 0xC1FC); // Set start address for info block CRC
+    }
+    
+    // Enable burst mode
+    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+    // Set pce
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+    RegSetLByteValue(0x160E, 0x01); 
+
+    nRegData1 = RegGet16BitValue(0x1604);
+    nRegData2 = RegGet16BitValue(0x1606);
+
+    nRetVal  = ((nRegData2 >> 8) & 0xFF) << 24;
+    nRetVal |= (nRegData2 & 0xFF) << 16;
+    nRetVal |= ((nRegData1 >> 8) & 0xFF) << 8;
+    nRetVal |= (nRegData1 & 0xFF);
+    
+    DBG("CRC = 0x%x\n", nRetVal);
+
+    // Clear burst mode
+    RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+    RegSet16BitValue(0x1600, 0x0000); 
+
+    // Clear RIU password
+    RegSet16BitValue(0x161A, 0x0000); 
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(u8 szTmpBuf[], EmemType_e eEmemType) // For MSG22XX
+{
+    u32 nRetVal = 0; 
+    
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+    
+    if (szTmpBuf != NULL)
+    {
+        if (eEmemType == EMEM_MAIN) // Read main block CRC(48KB-4) from bin file
+        {
+            nRetVal  = szTmpBuf[0xBFFF] << 24;
+            nRetVal |= szTmpBuf[0xBFFE] << 16;
+            nRetVal |= szTmpBuf[0xBFFD] << 8;
+            nRetVal |= szTmpBuf[0xBFFC];
+        }
+        else if (eEmemType == EMEM_INFO) // Read info block CRC(512Byte-4) from bin file
+        {
+            nRetVal  = szTmpBuf[0xC1FF] << 24;
+            nRetVal |= szTmpBuf[0xC1FE] << 16;
+            nRetVal |= szTmpBuf[0xC1FD] << 8;
+            nRetVal |= szTmpBuf[0xC1FC];
+        }
+    }
+
+    return nRetVal;
+}
+
+static u16 _DrvFwCtrlMsg22xxGetSwId(EmemType_e eEmemType) // For MSG22XX
+{
+    u16 nRetVal = 0; 
+    u16 nRegData1 = 0;
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); 
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+
+    // RIU password
+    RegSet16BitValue(0x161A, 0xABBA); 
+
+    // Clear pce
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+    if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+    {
+        RegSet16BitValue(0x1600, 0xBFF4); // Set start address for main block SW ID
+    }
+    else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+    {
+        RegSet16BitValue(0x1600, 0xC1EC); // Set start address for info block SW ID
+    }
+
+    /*
+      Ex. SW ID in Main Block :
+          Major low byte at address 0xBFF4
+          Major high byte at address 0xBFF5
+          
+          SW ID in Info Block :
+          Major low byte at address 0xC1EC
+          Major high byte at address 0xC1ED
+    */
+    
+    // Enable burst mode
+//    RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+    // Set pce
+    RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+    RegSetLByteValue(0x160E, 0x01); 
+
+    nRegData1 = RegGet16BitValue(0x1604);
+//    nRegData2 = RegGet16BitValue(0x1606);
+
+    nRetVal = ((nRegData1 >> 8) & 0xFF) << 8;
+    nRetVal |= (nRegData1 & 0xFF);
+    
+    // Clear burst mode
+//    RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+    RegSet16BitValue(0x1600, 0x0000); 
+
+    // Clear RIU password
+    RegSet16BitValue(0x161A, 0x0000); 
+    
+    DBG("SW ID = 0x%x\n", nRetVal);
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    return nRetVal;		
+}
+
+static s32 _DrvFwCtrlMsg22xxUpdateFirmwareBySwId(void) // For MSG22XX
+{
+    s32 nRetVal = -1;
+    u32 nCrcInfoA = 0, nCrcInfoB = 0, nCrcMainA = 0, nCrcMainB = 0;
+    
+    DBG("*** %s() ***\n", __func__);
+    
+    DBG("_gIsUpdateInfoBlockFirst = %d, _gIsUpdateFirmware = 0x%x\n", _gIsUpdateInfoBlockFirst, _gIsUpdateFirmware);
+
+    _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(g_FwData, _gOneDimenFwData);
+    
+    if (_gIsUpdateInfoBlockFirst == 1)
+    {
+        if ((_gIsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+ 
+            nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+            DBG("nCrcInfoA = 0x%x, nCrcInfoB = 0x%x\n", nCrcInfoA, nCrcInfoB);
+        
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+                _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+                nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+                nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+                DBG("nCrcMainA = 0x%x, nCrcMainB = 0x%x\n", nCrcMainA, nCrcMainB);
+        		
+                if (nCrcMainA == nCrcMainB)
+                {
+                    _gIsUpdateFirmware = 0x00;
+                    nRetVal = 0;
+                }
+                else
+                {
+                    _gIsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                _gIsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((_gIsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+            DBG("nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+    		
+            if (nCrcMainA == nCrcMainB)
+            {
+                _gIsUpdateFirmware = 0x00;
+                nRetVal = 0;
+            }
+            else
+            {
+                _gIsUpdateFirmware = 0x01;
+            }
+        }
+    }
+    else //_gIsUpdateInfoBlockFirst == 0
+    {
+        if ((_gIsUpdateFirmware & 0x10) == 0x10)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_MAIN);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_MAIN);
+
+            nCrcMainA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_MAIN);
+            nCrcMainB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+
+            DBG("nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+
+            if (nCrcMainA == nCrcMainB)
+            {
+                _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+                _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+
+                nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+                nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+                
+                DBG("nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+                if (nCrcInfoA == nCrcInfoB)
+                {
+                    _gIsUpdateFirmware = 0x00;
+                    nRetVal = 0;
+                }
+                else
+                {
+                    _gIsUpdateFirmware = 0x01;
+                }
+            }
+            else
+            {
+                _gIsUpdateFirmware = 0x11;
+            }
+        }
+        else if ((_gIsUpdateFirmware & 0x01) == 0x01)
+        {
+            _DrvFwCtrlMsg22xxEraseEmem(EMEM_INFO);
+            _DrvFwCtrlMsg22xxProgramEmem(EMEM_INFO);
+
+            nCrcInfoA = _DrvFwCtrlMsg22xxRetrieveFrimwareCrcFromBinFile(_gOneDimenFwData, EMEM_INFO);
+            nCrcInfoB = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+            DBG("nCrcInfoA=0x%x, nCrcInfoB=0x%x\n", nCrcInfoA, nCrcInfoB);
+
+            if (nCrcInfoA == nCrcInfoB)
+            {
+                _gIsUpdateFirmware = 0x00;
+                nRetVal = 0;
+            }
+            else
+            {
+                _gIsUpdateFirmware = 0x01;
+            }
+        }    		
+    }
+    
+    return nRetVal;	
+}
+
+void _DrvFwCtrlMsg22xxCheckFirmwareUpdateBySwId(void) // For MSG22XX
+{
+    u32 nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB;
+    u32 i;
+    u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+    u16 nMajor = 0, nMinor = 0;
+    u8 *pVersion = NULL;
+    Msg22xxSwId_e eSwId = MSG22XX_SW_ID_UNDEFINED;
+    
+    DBG("*** %s() ***\n", __func__);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DrvFwCtrlGetCustomerFirmwareVersion(&nMajor, &nMinor, &pVersion);
+
+    nCrcMainA = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+    nCrcMainB = _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EMEM_MAIN);
+
+    nCrcInfoA = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+    nCrcInfoB = _DrvFwCtrlMsg22xxRetrieveFirmwareCrcFromEFlash(EMEM_INFO);
+    
+    _gUpdateFirmwareBySwIdWorkQueue = create_singlethread_workqueue("update_firmware_by_sw_id");
+    INIT_WORK(&_gUpdateFirmwareBySwIdWork, _DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+    DBG("nCrcMainA=0x%x, nCrcInfoA=0x%x, nCrcMainB=0x%x, nCrcInfoB=0x%x\n", nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB);
+               
+    if (nCrcMainA == nCrcMainB && nCrcInfoA == nCrcInfoB) // Case 1. Main Block:OK, Info Block:OK
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_MAIN);
+    		
+        if (eSwId == MSG22XX_SW_ID_XXXX)
+        {
+            nUpdateBinMajor = msg2xxx_xxxx_update_bin[0xBFF5]<<8 | msg2xxx_xxxx_update_bin[0xBFF4];
+            nUpdateBinMinor = msg2xxx_xxxx_update_bin[0xBFF7]<<8 | msg2xxx_xxxx_update_bin[0xBFF6];
+        }
+        else if (eSwId == MSG22XX_SW_ID_YYYY)
+        {
+            nUpdateBinMajor = msg2xxx_yyyy_update_bin[0xBFF5]<<8 | msg2xxx_yyyy_update_bin[0xBFF4];
+            nUpdateBinMinor = msg2xxx_yyyy_update_bin[0xBFF7]<<8 | msg2xxx_yyyy_update_bin[0xBFF6];
+        }
+        else //eSwId == MSG22XX_SW_ID_UNDEFINED
+        {
+            DBG("eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG22XX_SW_ID_UNDEFINED;
+            nUpdateBinMajor = 0;
+            nUpdateBinMinor = 0;    		        						
+        }
+    		
+        DBG("eSwId=0x%x, nMajor=%d, nMinor=%d, nUpdateBinMajor=%d, nUpdateBinMinor=%d\n", eSwId, nMajor, nMinor, nUpdateBinMajor, nUpdateBinMinor);
+
+        if (nUpdateBinMinor > nMinor)
+        {
+            if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+            {
+                if (eSwId == MSG22XX_SW_ID_XXXX)
+                {
+                    for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                    {
+                        if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                        {
+                            _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+                        }
+                        else // i == 48
+                        {
+                            _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 512);
+                        }
+                    }
+                }
+                else if (eSwId == MSG22XX_SW_ID_YYYY)
+                {
+                    for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                    {
+                        if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                        {
+                            _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+                        }
+                        else // i == 48
+                        {
+                            _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 512);
+                        }
+                    }
+                }
+
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+                _gIsUpdateFirmware = 0x11;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG("The sw id is invalid.\n");
+                DBG("Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG("The update bin version is older than or equal to the current firmware version on e-flash.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+    else if (nCrcMainA == nCrcMainB && nCrcInfoA != nCrcInfoB) // Case 2. Main Block:OK, Info Block:FAIL
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_MAIN);
+    		
+        DBG("eSwId=0x%x\n", eSwId);
+
+        if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+        {
+            if (eSwId == MSG22XX_SW_ID_XXXX)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+            else if (eSwId == MSG22XX_SW_ID_YYYY)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            _gIsUpdateInfoBlockFirst = 1; // Set 1 for indicating main block is complete 
+            _gIsUpdateFirmware = 0x11;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG("The sw id is invalid.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+    else if (nCrcMainA != nCrcMainB && nCrcInfoA == nCrcInfoB) // Case 3. Main Block:FAIL, Info Block:OK
+    {
+        eSwId = _DrvFwCtrlMsg22xxGetSwId(EMEM_INFO);
+		
+        DBG("eSwId=0x%x\n", eSwId);
+
+        if (eSwId < MSG22XX_SW_ID_UNDEFINED && eSwId != 0x0000 && eSwId != 0xFFFF)
+        {
+            if (eSwId == MSG22XX_SW_ID_XXXX)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+            else if (eSwId == MSG22XX_SW_ID_YYYY)
+            {
+                for (i = 0; i < (MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE+1); i ++)
+                {
+                    if (i < MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE) // i < 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+                    }
+                    else // i == 48
+                    {
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 512);
+                    }
+                }
+            }
+
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            _gIsUpdateInfoBlockFirst = 0; // Set 0 for indicating main block is broken 
+            _gIsUpdateFirmware = 0x11;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG("The sw id is invalid.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+    else // Case 4. Main Block:FAIL, Info Block:FAIL
+    {
+        DBG("Main block and Info block are broken.\n");
+        DBG("Go to normal boot up process.\n");
+    }
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DrvPlatformLyrEnableFingerTouchReport();
+}
+
+//-------------------------End of SW ID for MSG22XX----------------------------//
+
+//-------------------------Start of SW ID for MSG21XXA----------------------------//
+
+static u32 _DrvFwCtrlMsg21xxaCalculateMainCrcFromEFlash(void) // For MSG21XXA
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop Watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xDF4C); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x9432
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x9432);
+
+    // Read calculated main block CRC from register
+    nRetVal = RegGet16BitValue(0x3C80);
+    nRetVal = (nRetVal << 16) | RegGet16BitValue(0x3C82);
+        
+    DBG("Main Block CRC = 0x%x\n", nRetVal);
+
+    return nRetVal;	
+}
+
+static u32 _DrvFwCtrlMsg21xxaRetrieveMainCrcFromMainBlock(void) // For MSG21XXA
+{
+    u32 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG("*** %s() ***\n", __func__);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+     // Read main block CRC from main block
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[1] = 0x7F;
+    szDbBusTxData[2] = 0xFC;
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+    
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    nRetVal = szDbBusRxData[0];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[1];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[2];
+    nRetVal = (nRetVal << 8) | szDbBusRxData[3];
+   
+    DBG("CRC = 0x%x\n", nRetVal);
+
+    return nRetVal;	
+}
+
+static u16 _DrvFwCtrlMsg21xxaGetSwId(EmemType_e eEmemType) // For MSG21XXA
+{
+    u16 nRetVal = 0; 
+    u16 nRegData = 0;
+    u8 szDbBusTxData[5] = {0};
+    u8 szDbBusRxData[4] = {0};
+
+    DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    // Stop mcu
+    RegSetLByteValue(0x0FE6, 0x01); //bank:mheg5, addr:h0073
+
+    // Stop watchdog
+    RegSet16BitValue(0x3C60, 0xAA55); //bank:reg_PIU_MISC_0, addr:h0030
+
+    // cmd
+    RegSet16BitValue(0x3CE4, 0xA4AB); //bank:reg_PIU_MISC_0, addr:h0072
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x7d60); //bank:chip, addr:h0002
+    RegSet16BitValue(0x1E04, 0x829F);
+
+    // Start mcu
+    RegSetLByteValue(0x0FE6, 0x00); //bank:mheg5, addr:h0073
+    
+    mdelay(100);
+
+    // Polling 0x3CE4 is 0x5B58
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4); //bank:reg_PIU_MISC_0, addr:h0072
+    } while (nRegData != 0x5B58);
+
+    szDbBusTxData[0] = 0x72;
+    if (eEmemType == EMEM_MAIN) // Read SW ID from main block
+    {
+        szDbBusTxData[1] = 0x7F;
+        szDbBusTxData[2] = 0x55;
+    }
+    else if (eEmemType == EMEM_INFO) // Read SW ID from info block
+    {
+        szDbBusTxData[1] = 0x83;
+        szDbBusTxData[2] = 0x00;
+    }
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x04;
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+    DBG("szDbBusRxData[0,1,2,3] = 0x%x,0x%x,0x%x,0x%x\n", szDbBusRxData[0], szDbBusRxData[1], szDbBusRxData[2], szDbBusRxData[3]);
+
+    if ((szDbBusRxData[0] >= 0x30 && szDbBusRxData[0] <= 0x39)
+        &&(szDbBusRxData[1] >= 0x30 && szDbBusRxData[1] <= 0x39)
+        &&(szDbBusRxData[2] >= 0x31 && szDbBusRxData[2] <= 0x39))  
+    {
+        nRetVal = (szDbBusRxData[0]-0x30)*100+(szDbBusRxData[1]-0x30)*10+(szDbBusRxData[2]-0x30);
+    }
+    
+    DBG("SW ID = 0x%x\n", nRetVal);
+
+    return nRetVal;		
+}		
+
+static s32 _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(u8 szFwData[][1024], EmemType_e eEmemType) // For MSG21XXA
+{
+    u32 i, j, nCalculateCrcSize;
+    u32 nCrcMain = 0, nCrcMainTp = 0;
+    u32 nCrcInfo = 0, nCrcInfoTp = 0;
+    u32 nCrcTemp = 0;
+    u16 nRegData = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    // erase main
+    _DrvFwCtrlEraseEmemC33(EMEM_MAIN);
+    mdelay(1000);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x1C70);
+    }
+
+    switch (eEmemType)
+    {
+        case EMEM_ALL:
+            RegSet16BitValue(0x3CE4, 0xE38F);  // for all blocks
+            break;
+        case EMEM_MAIN:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for main block
+            break;
+        case EMEM_INFO:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for info block
+
+            RegSetLByteValue(0x0FE6, 0x01);
+
+            RegSetLByteValue(0x3CE4, 0xC5); 
+            RegSetLByteValue(0x3CE5, 0x78); 
+
+            RegSetLByteValue(0x1E04, 0x9F);
+            RegSetLByteValue(0x1E05, 0x82);
+
+            RegSetLByteValue(0x0FE6, 0x00);
+            mdelay(100);
+            break;
+    }
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    if (eEmemType == EMEM_ALL)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_WHOLE_SIZE;
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE;
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        nCalculateCrcSize = MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE;
+    }
+    else
+    {
+        nCalculateCrcSize = 0;
+    }
+		
+    for (i = 0; i < nCalculateCrcSize; i ++)
+    {
+        if (eEmemType == EMEM_INFO)
+        {
+            i = 32;
+        }
+
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG("nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG("((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG("Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]);
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(szFwData[i][j], nCrcInfo);
+            }
+            
+            if (eEmemType == EMEM_MAIN)
+            {
+                break;
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // write file done and check crc
+        RegSet16BitValue(0x3CE4, 0x1380);
+    }
+    mdelay(10);
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // Polling 0x3CE4 is 0x9432
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x9432);
+    }
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // CRC Main from TP
+        nCrcMainTp = RegGet16BitValue(0x3C80);
+        nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+    }
+
+    if (eEmemType == EMEM_ALL)
+    {
+        // CRC Info from TP
+        nCrcInfoTp = RegGet16BitValue(0x3CA0);
+        nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+    }
+
+    DBG("nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n", nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        if (nCrcMainTp != nCrcMain)
+        {
+            DBG("Update FAILED\n");
+
+            return -1;
+        }
+    }
+
+    if (eEmemType == EMEM_ALL)
+    {
+        if (nCrcInfoTp != nCrcInfo)
+        {
+            DBG("Update FAILED\n");
+
+            return -1;
+        }
+    }
+
+    DBG("Update SUCCESS\n");
+
+    return 0;
+} 
+
+void _DrvFwCtrlMsg21xxaCheckFirmwareUpdateBySwId(void) // For MSG21XXA
+{
+    u32 nCrcMainA, nCrcMainB;
+    u32 i;
+    u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+    u16 nMajor = 0, nMinor = 0;
+    u8 nIsCompareVersion = 0;
+    u8 *pVersion = NULL; 
+    Msg21xxaSwId_e eMainSwId = MSG21XXA_SW_ID_UNDEFINED, eInfoSwId = MSG21XXA_SW_ID_UNDEFINED, eSwId = MSG21XXA_SW_ID_UNDEFINED;
+
+    DBG("*** %s() ***\n", __func__);
+
+    DrvPlatformLyrDisableFingerTouchReport();
+
+    DrvFwCtrlGetCustomerFirmwareVersion(&nMajor, &nMinor, &pVersion);
+
+    nCrcMainA = _DrvFwCtrlMsg21xxaCalculateMainCrcFromEFlash();
+    nCrcMainB = _DrvFwCtrlMsg21xxaRetrieveMainCrcFromMainBlock();
+
+    _gUpdateFirmwareBySwIdWorkQueue = create_singlethread_workqueue("update_firmware_by_sw_id");
+    INIT_WORK(&_gUpdateFirmwareBySwIdWork, _DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+    DBG("nCrcMainA=0x%x, nCrcMainB=0x%x\n", nCrcMainA, nCrcMainB);
+               
+    if (nCrcMainA == nCrcMainB) 
+    {
+        eMainSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_MAIN);
+        eInfoSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_INFO);
+    		
+        DBG("Check firmware integrity success\n");
+        DBG("eMainSwId=0x%x, eInfoSwId=0x%x\n", eMainSwId, eInfoSwId);
+
+        if (eMainSwId == eInfoSwId)
+        {
+        		eSwId = eMainSwId;
+        		nIsCompareVersion = 1;
+        }
+        else
+        {
+        		eSwId = eInfoSwId;
+        		nIsCompareVersion = 0;
+        }
+        
+        if (eSwId == MSG21XXA_SW_ID_XXXX)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg2xxx_xxxx_update_bin[31][0x34F]<<8 | msg2xxx_xxxx_update_bin[31][0x34E];
+            nUpdateBinMinor = msg2xxx_xxxx_update_bin[31][0x351]<<8 | msg2xxx_xxxx_update_bin[31][0x350];
+#else // By one dimensional array
+            nUpdateBinMajor = msg2xxx_xxxx_update_bin[0x7F4F]<<8 | msg2xxx_xxxx_update_bin[0x7F4E];
+            nUpdateBinMinor = msg2xxx_xxxx_update_bin[0x7F51]<<8 | msg2xxx_xxxx_update_bin[0x7F50];
+#endif
+        }
+        else if (eSwId == MSG21XXA_SW_ID_YYYY)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+            nUpdateBinMajor = msg2xxx_yyyy_update_bin[31][0x34F]<<8 | msg2xxx_yyyy_update_bin[31][0x34E];
+            nUpdateBinMinor = msg2xxx_yyyy_update_bin[31][0x351]<<8 | msg2xxx_yyyy_update_bin[31][0x350];
+#else // By one dimensional array
+            nUpdateBinMajor = msg2xxx_yyyy_update_bin[0x7F4F]<<8 | msg2xxx_yyyy_update_bin[0x7F4E];
+            nUpdateBinMinor = msg2xxx_yyyy_update_bin[0x7F51]<<8 | msg2xxx_yyyy_update_bin[0x7F50];
+#endif
+        }
+        else //eSwId == MSG21XXA_SW_ID_UNDEFINED
+        {
+            DBG("eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+            eSwId = MSG21XXA_SW_ID_UNDEFINED;
+            nUpdateBinMajor = 0;
+            nUpdateBinMinor = 0;    		        						
+        }
+    		        
+        DBG("eSwId=0x%x, nMajor=%d, nMinor=%d, nUpdateBinMajor=%d, nUpdateBinMinor=%d\n", eSwId, nMajor, nMinor, nUpdateBinMajor, nUpdateBinMinor);
+
+        if ((nUpdateBinMinor > nMinor && nIsCompareVersion == 1) || (nIsCompareVersion == 0))
+        {
+            if (eSwId < MSG21XXA_SW_ID_UNDEFINED && eSwId != 0xFFFF)
+            {
+                if (eSwId == MSG21XXA_SW_ID_XXXX)
+                {
+                    for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                    {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                        _DrvFwCtrlStoreFirmwareData(msg2xxx_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+#endif
+                    }
+                }
+                else if (eSwId == MSG21XXA_SW_ID_YYYY)
+                {
+                    for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                    {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                        _DrvFwCtrlStoreFirmwareData(msg2xxx_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                        _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+#endif
+                    }
+                }
+
+                g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+                _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+                queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+                return;
+            }
+            else
+            {
+                DBG("The sw id is invalid.\n");
+                DBG("Go to normal boot up process.\n");
+            }
+        }
+        else
+        {
+            DBG("The update bin version is older than or equal to the current firmware version on e-flash.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+    else
+    {
+        eSwId = _DrvFwCtrlMsg21xxaGetSwId(EMEM_INFO);
+    		
+        DBG("Check firmware integrity failed\n");
+        DBG("eSwId=0x%x\n", eSwId);
+
+        if (eSwId < MSG21XXA_SW_ID_UNDEFINED && eSwId != 0xFFFF)
+        {
+            if (eSwId == MSG21XXA_SW_ID_XXXX)
+            {
+                for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg2xxx_xxxx_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg2xxx_xxxx_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+            else if (eSwId == MSG21XXA_SW_ID_YYYY)
+            {
+                for (i = 0; i < MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE; i ++)
+                {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY // By two dimensional array
+                    _DrvFwCtrlStoreFirmwareData(msg2xxx_yyyy_update_bin[i], 1024);
+#else // By one dimensional array
+                    _DrvFwCtrlStoreFirmwareData(&(msg2xxx_yyyy_update_bin[i*1024]), 1024);
+#endif
+                }
+            }
+
+            g_FwDataCount = 0; // Reset g_FwDataCount to 0 after copying update firmware data to temp buffer
+
+            _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+            return;
+        }
+        else
+        {
+            DBG("The sw id is invalid.\n");
+            DBG("Go to normal boot up process.\n");
+        }
+    }
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DrvPlatformLyrEnableFingerTouchReport();
+}
+
+//-------------------------End of SW ID for MSG21XXA----------------------------//
+
+static void _DrvFwCtrlUpdateFirmwareBySwIdDoWork(struct work_struct *pWork)
+{
+    s32 nRetVal = 0;
+    
+    DBG("*** %s() _gUpdateRetryCount = %d ***\n", __func__, _gUpdateRetryCount);
+
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+    {
+        nRetVal = _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(g_FwData, EMEM_MAIN);
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)    
+    {
+        nRetVal = _DrvFwCtrlMsg22xxUpdateFirmwareBySwId();
+    }
+    else
+    {
+        DBG("This chip type (%d) does not support update firmware by sw id\n", g_ChipType);
+
+        DrvPlatformLyrTouchDeviceResetHw(); 
+
+        DrvPlatformLyrEnableFingerTouchReport();
+
+        nRetVal = -1;
+        return;
+    }
+    
+    DBG("*** update firmware by sw id result = %d ***\n", nRetVal);
+    
+    if (nRetVal == 0)
+    {
+        DBG("update firmware by sw id success\n");
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        DrvPlatformLyrEnableFingerTouchReport();
+
+        if (g_ChipType == CHIP_TYPE_MSG22XX)    
+        {
+            _gIsUpdateInfoBlockFirst = 0;
+            _gIsUpdateFirmware = 0x00;
+        }
+    }
+    else //nRetVal == -1
+    {
+        _gUpdateRetryCount --;
+        if (_gUpdateRetryCount > 0)
+        {
+            DBG("_gUpdateRetryCount = %d\n", _gUpdateRetryCount);
+            queue_work(_gUpdateFirmwareBySwIdWorkQueue, &_gUpdateFirmwareBySwIdWork);
+        }
+        else
+        {
+            DBG("update firmware by sw id failed\n");
+
+            DrvPlatformLyrTouchDeviceResetHw();
+
+            DrvPlatformLyrEnableFingerTouchReport();
+
+            if (g_ChipType == CHIP_TYPE_MSG22XX)    
+            {
+                _gIsUpdateInfoBlockFirst = 0;
+                _gIsUpdateFirmware = 0x00;
+            }
+        }
+    }
+}
+
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
+
+static void _DrvFwCtrlReadInfoC33(void)
+{
+    u8 szDbBusTxData[5] = {0};
+    u16 nRegData = 0;
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u32 i;
+#endif 
+
+    DBG("*** %s() ***\n", __func__);
+    
+    mdelay(300);
+
+    // Stop Watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    RegSet16BitValue(0x3CE4, 0xA4AB);
+
+    RegSet16BitValue(0x1E04, 0x7d60);
+
+    // TP SW reset
+    RegSet16BitValue(0x1E04, 0x829F);
+    mdelay(1);
+    
+    szDbBusTxData[0] = 0x10;
+    szDbBusTxData[1] = 0x0F;
+    szDbBusTxData[2] = 0xE6;
+    szDbBusTxData[3] = 0x00;
+    IicWriteData(SLAVE_I2C_ID_DBBUS, szDbBusTxData, 4);    
+    mdelay(100);
+
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x5B58);
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[3] = 0x00;
+    szDbBusTxData[4] = 0x80; // read 128 bytes
+
+    for (i = 0; i < 8; i ++)
+    {
+        szDbBusTxData[1] = 0x80 + (((i*128)&0xff00)>>8);
+        szDbBusTxData[2] = (i*128)&0x00ff;
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+
+        mdelay(50);
+
+        // Receive info data
+        IicReadData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[i*128], 128);
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    szDbBusTxData[0] = 0x72;
+    szDbBusTxData[1] = 0x80;
+    szDbBusTxData[2] = 0x00;
+    szDbBusTxData[3] = 0x04; // read 1024 bytes
+    szDbBusTxData[4] = 0x00;
+    
+    IicWriteData(SLAVE_I2C_ID_DWI2C, szDbBusTxData, 5);
+
+    mdelay(50);
+
+    // Receive info data
+    IicReadData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[0], 1024);
+#endif
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareC32(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u32 i, j;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u32 nCrcTemp;
+    u16 nRegData = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    /////////////////////////
+    // Erase  all
+    /////////////////////////
+    _DrvFwCtrlEraseEmemC32();
+    mdelay(1000); 
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+
+    // Reset watch dog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x1C70);
+
+    RegSet16BitValue(0x3CE4, 0xE38F);  // for all-blocks
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    for (i = 0; i < 33; i ++) // total  33 KB : 2 byte per R/W
+    {
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG("nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG("((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG("Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]);
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(szFwData[i][j], nCrcInfo);
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    // Write file done
+    RegSet16BitValue(0x3CE4, 0x1380);
+
+    mdelay(10); 
+    // Polling 0x3CE4 is 0x9432
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x9432);
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    // CRC Main from TP
+    nCrcMainTp = RegGet16BitValue(0x3C80);
+    nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+ 
+    // CRC Info from TP
+    nCrcInfoTp = RegGet16BitValue(0x3CA0);
+    nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+
+    DBG("nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n",
+               nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+    {
+        DBG("Update FAILED\n");
+
+        return -1;
+    }
+
+    DBG("Update SUCCESS\n");
+
+    return 0;
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareC33(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u8 szLifeCounter[2];
+    u32 i, j;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u32 nCrcTemp;
+    u16 nRegData = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    nCrcMain = 0xffffffff;
+    nCrcInfo = 0xffffffff;
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    _DrvFwCtrlReadInfoC33();
+
+    if (_gDwIicInfoData[0] == 'M' && _gDwIicInfoData[1] == 'S' && _gDwIicInfoData[2] == 'T' && _gDwIicInfoData[3] == 'A' && _gDwIicInfoData[4] == 'R' && _gDwIicInfoData[5] == 'T' && _gDwIicInfoData[6] == 'P' && _gDwIicInfoData[7] == 'C')
+    {
+        _gDwIicInfoData[8] = szFwData[32][8];
+        _gDwIicInfoData[9] = szFwData[32][9];
+        _gDwIicInfoData[10] = szFwData[32][10];
+        _gDwIicInfoData[11] = szFwData[32][11];
+        // updata life counter
+        szLifeCounter[1] = ((((_gDwIicInfoData[13] << 8) | _gDwIicInfoData[12]) + 1) >> 8) & 0xFF;
+        szLifeCounter[0] = (((_gDwIicInfoData[13] << 8) | _gDwIicInfoData[12]) + 1) & 0xFF;
+        _gDwIicInfoData[12] = szLifeCounter[0];
+        _gDwIicInfoData[13] = szLifeCounter[1];
+        
+        RegSet16BitValue(0x3CE4, 0x78C5);
+        RegSet16BitValue(0x1E04, 0x7d60);
+        // TP SW reset
+        RegSet16BitValue(0x1E04, 0x829F);
+
+        mdelay(50);
+
+        // Polling 0x3CE4 is 0x2F43
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x2F43);
+
+        // Transmit lk info data
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &_gDwIicInfoData[0], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+    }
+
+    // erase main
+    _DrvFwCtrlEraseEmemC33(EMEM_MAIN);
+    mdelay(1000);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    // Polling 0x3CE4 is 0x1C70
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x1C70);
+    }
+
+    switch (eEmemType)
+    {
+        case EMEM_ALL:
+            RegSet16BitValue(0x3CE4, 0xE38F);  // for all blocks
+            break;
+        case EMEM_MAIN:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for main block
+            break;
+        case EMEM_INFO:
+            RegSet16BitValue(0x3CE4, 0x7731);  // for info block
+
+            RegSetLByteValue(0x0FE6, 0x01);
+
+            RegSetLByteValue(0x3CE4, 0xC5); 
+            RegSetLByteValue(0x3CE5, 0x78); 
+
+            RegSetLByteValue(0x1E04, 0x9F);
+            RegSetLByteValue(0x1E05, 0x82);
+
+            RegSetLByteValue(0x0FE6, 0x00);
+            mdelay(100);
+            break;
+    }
+
+    // Polling 0x3CE4 is 0x2F43
+    do
+    {
+        nRegData = RegGet16BitValue(0x3CE4);
+    } while (nRegData != 0x2F43);
+
+    // Calculate CRC 32
+    DrvCommonCrcInitTable();
+
+    for (i = 0; i < 33; i ++) // total 33 KB : 2 byte per R/W
+    {
+        if (eEmemType == EMEM_INFO)
+        {
+            i = 32;
+        }
+
+        if (i < 32)   // emem_main
+        {
+            if (i == 31)
+            {
+                szFwData[i][1014] = 0x5A;
+                szFwData[i][1015] = 0xA5;
+
+                for (j = 0; j < 1016; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+
+                nCrcTemp = nCrcMain;
+                nCrcTemp = nCrcTemp ^ 0xffffffff;
+
+                DBG("nCrcTemp=%x\n", nCrcTemp); // add for debug
+
+                for (j = 0; j < 4; j ++)
+                {
+                    szFwData[i][1023-j] = ((nCrcTemp>>(8*j)) & 0xFF);
+
+                    DBG("((nCrcTemp>>(8*%d)) & 0xFF)=%x\n", j, ((nCrcTemp>>(8*j)) & 0xFF)); // add for debug
+                    DBG("Update main clock crc32 into bin buffer szFwData[%d][%d]=%x\n", i, (1020+j), szFwData[i][1020+j]); // add for debug
+                }
+            }
+            else
+            {
+                for (j = 0; j < 1024; j ++)
+                {
+                    nCrcMain = DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for (j = 0; j < 1024; j ++)
+            {
+                nCrcInfo = DrvCommonCrcGetValue(_gDwIicInfoData[j], nCrcInfo);
+            }
+            
+            if (eEmemType == EMEM_MAIN)
+            {
+                break;
+            }
+        }
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+        for (j = 0; j < 8; j ++)
+        {
+            IicWriteData(SLAVE_I2C_ID_DWI2C, &szFwData[i][j*128], 128);
+        }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+        IicWriteData(SLAVE_I2C_ID_DWI2C, szFwData[i], 1024);
+#endif
+
+        // Polling 0x3CE4 is 0xD0BC
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0xD0BC);
+
+        RegSet16BitValue(0x3CE4, 0x2F43);
+    }
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // write file done and check crc
+        RegSet16BitValue(0x3CE4, 0x1380);
+    }
+    mdelay(10);
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // Polling 0x3CE4 is 0x9432
+        do
+        {
+            nRegData = RegGet16BitValue(0x3CE4);
+        } while (nRegData != 0x9432);
+    }
+
+    nCrcMain = nCrcMain ^ 0xffffffff;
+    nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        // CRC Main from TP
+        nCrcMainTp = RegGet16BitValue(0x3C80);
+        nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+
+        // CRC Info from TP
+        nCrcInfoTp = RegGet16BitValue(0x3CA0);
+        nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+    }
+    DBG("nCrcMain=0x%x, nCrcInfo=0x%x, nCrcMainTp=0x%x, nCrcInfoTp=0x%x\n", nCrcMain, nCrcInfo, nCrcMainTp, nCrcInfoTp);
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if ((eEmemType == EMEM_ALL) || (eEmemType == EMEM_MAIN))
+    {
+        if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+        {
+            DBG("Update FAILED\n");
+
+            return -1;
+        }
+    }
+    
+    DBG("Update SUCCESS\n");
+
+    return 0;
+}
+
+static s32 _DrvFwCtrlMsg22xxUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    u32 i, index;
+    u32 nCrcMain, nCrcMainTp;
+    u32 nCrcInfo, nCrcInfoTp;
+    u32 nRemainSize, nBlockSize, nSize;
+    u16 nRegData = 0;
+    u8 szDbBusTxData[1024] = {0};
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    u32 nSizePerWrite = 125;
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+    u32 nSizePerWrite = 1021;
+#endif
+
+    DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    _DrvFwCtrlMsg22xxConvertFwDataTwoDimenToOneDimen(szFwData, _gOneDimenFwData);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    
+    DBG("Erase start\n");
+
+    // Stop mcu
+    RegSet16BitValue(0x0FE6, 0x0001);
+
+    // Disable watchdog
+    RegSetLByteValue(0x3C60, 0x55);
+    RegSetLByteValue(0x3C61, 0xAA);
+
+    // Set PROGRAM password
+    RegSetLByteValue(0x161A, 0xBA);
+    RegSetLByteValue(0x161B, 0xAB);
+
+    if (eEmemType == EMEM_ALL) // 48KB + 512Byte
+    {
+        DBG("Erase all block\n");
+
+        // Clear pce
+        RegSetLByteValue(0x1618, 0x80);
+        mdelay(100);
+
+        // Chip erase
+        RegSet16BitValue(0x160E, BIT3);
+
+        DBG("Wait erase done flag\n");
+
+        do // Wait erase done flag
+        {
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            mdelay(50);
+        } while((nRegData & BIT1) != BIT1);
+    }
+    else if (eEmemType == EMEM_MAIN) // 48KB (32+8+8)
+    {
+        DBG("Erase main block\n");
+
+        for (i = 0; i < 3; i ++)
+        {
+            // Clear pce
+            RegSetLByteValue(0x1618, 0x80);
+            mdelay(10);
+
+            if (i == 0)
+            {
+                RegSet16BitValue(0x1600, 0x0000);
+            }
+            else if (i == 1)
+            {
+                RegSet16BitValue(0x1600, 0x8000);
+            }
+            else if (i == 2)
+            {
+                RegSet16BitValue(0x1600, 0xA000);
+            }
+
+            // Sector erase
+            RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+            DBG("Wait erase done flag\n");
+
+            do // Wait erase done flag
+            {
+                nRegData = RegGet16BitValue(0x1610); // Memory status
+                mdelay(50);
+            } while((nRegData & BIT1) != BIT1);
+        }   
+    }
+    else if (eEmemType == EMEM_INFO) // 512Byte
+    {
+        DBG("Erase info block\n");
+
+        // Clear pce
+        RegSetLByteValue(0x1618, 0x80);
+        mdelay(10);
+
+        RegSet16BitValue(0x1600, 0xC000);
+        
+        // Sector erase
+        RegSet16BitValue(0x160E, (RegGet16BitValue(0x160E) | BIT2));
+
+        DBG("Wait erase done flag\n");
+
+        do // Wait erase done flag
+        {
+            nRegData = RegGet16BitValue(0x1610); // Memory status
+            mdelay(50);
+        } while((nRegData & BIT1) != BIT1);
+    }
+    
+    DBG("Erase end\n");
+    
+    // Hold reset pin before program
+    RegSetLByteValue(0x1E06, 0x00);
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_MAIN) // 48KB
+    {
+        DBG("Program main block start\n");
+		
+        // Program main block
+        RegSet16BitValue(0x161A, 0xABBA);
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+		
+        RegSet16BitValue(0x1600, 0x0000); // Set start address of main block
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+		
+        // Program start
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+		
+        szDbBusTxData[0] = 0x20;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+		
+        nRemainSize = MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024; //48KB
+        index = 0;
+		    
+        while (nRemainSize > 0)
+        {
+            if (nRemainSize > nSizePerWrite)
+            {
+                nBlockSize = nSizePerWrite;
+            }
+            else
+            {
+                nBlockSize = nRemainSize;
+            }
+		
+            szDbBusTxData[0] = 0x10;
+            szDbBusTxData[1] = 0x16;
+            szDbBusTxData[2] = 0x02;
+		
+            nSize = 3;
+		
+            for (i = 0; i < nBlockSize; i ++)
+            {
+                szDbBusTxData[3+i] = _gOneDimenFwData[index*nSizePerWrite+i];
+                nSize ++; 
+            }
+            index ++;
+		
+            IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+		        
+            nRemainSize = nRemainSize - nBlockSize;
+        }
+		
+        // Program end
+        szDbBusTxData[0] = 0x21;
+		
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+		
+        nRegData = RegGet16BitValue(0x160C); 
+        RegSet16BitValue(0x160C, nRegData & (~0x01));      
+		
+        DBG("Wait main block write done flag\n");
+		
+        // Polling 0x1610 is 0x0002
+        do
+        {
+            nRegData = RegGet16BitValue(0x1610);
+            nRegData = nRegData & BIT1;
+            mdelay(10);
+		
+        } while (nRegData != BIT1); // Wait write done flag
+		
+        DBG("Program main block end\n");
+    }
+    
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_INFO) // 512 Byte
+    {
+        DBG("Program info block start\n");
+
+        // Program info block
+        RegSet16BitValue(0x161A, 0xABBA);
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xC000); // Set start address of info block
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01)); // Enable burst mode
+
+        // Program start
+        szDbBusTxData[0] = 0x10;
+        szDbBusTxData[1] = 0x16;
+        szDbBusTxData[2] = 0x02;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);    
+
+        szDbBusTxData[0] = 0x20;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+        nRemainSize = MSG22XX_FIRMWARE_INFO_BLOCK_SIZE; //512Byte
+        index = 0;
+    
+        while (nRemainSize > 0)
+        {
+            if (nRemainSize > nSizePerWrite)
+            {
+                nBlockSize = nSizePerWrite;
+            }
+            else
+            {
+                nBlockSize = nRemainSize;
+            }
+
+            szDbBusTxData[0] = 0x10;
+            szDbBusTxData[1] = 0x16;
+            szDbBusTxData[2] = 0x02;
+
+            nSize = 3;
+
+            for (i = 0; i < nBlockSize; i ++)
+            {
+                szDbBusTxData[3+i] = _gOneDimenFwData[(MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE*1024)+(index*nSizePerWrite)+i];
+                nSize ++; 
+            }
+            index ++;
+
+            IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], nSize);
+        
+            nRemainSize = nRemainSize - nBlockSize;
+        }
+
+        // Program end
+        szDbBusTxData[0] = 0x21;
+
+        IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 1);    
+
+        nRegData = RegGet16BitValue(0x160C); 
+        RegSet16BitValue(0x160C, nRegData & (~0x01));      
+
+        DBG("Wait info block write done flag\n");
+
+        // Polling 0x1610 is 0x0002
+        do
+        {
+            nRegData = RegGet16BitValue(0x1610);
+            nRegData = nRegData & BIT1;
+            mdelay(10);
+
+        } while (nRegData != BIT1); // Wait write done flag
+
+        DBG("Program info block end\n");
+    }
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_MAIN)
+    {
+        // Get CRC 32 from updated firmware bin file
+        nCrcMain  = _gOneDimenFwData[0xBFFF] << 24;
+        nCrcMain |= _gOneDimenFwData[0xBFFE] << 16;
+        nCrcMain |= _gOneDimenFwData[0xBFFD] << 8;
+        nCrcMain |= _gOneDimenFwData[0xBFFC];
+
+        // CRC Main from TP
+        DBG("Get Main CRC from TP\n");
+
+        nCrcMainTp = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_MAIN);
+    
+        DBG("nCrcMain=0x%x, nCrcMainTp=0x%x\n", nCrcMain, nCrcMainTp);
+    }
+
+    if (eEmemType == EMEM_ALL || eEmemType == EMEM_INFO)
+    {
+        nCrcInfo  = _gOneDimenFwData[0xC1FF] << 24;
+        nCrcInfo |= _gOneDimenFwData[0xC1FE] << 16;
+        nCrcInfo |= _gOneDimenFwData[0xC1FD] << 8;
+        nCrcInfo |= _gOneDimenFwData[0xC1FC];
+
+        // CRC Info from TP
+        DBG("Get Info CRC from TP\n");
+
+        nCrcInfoTp = _DrvFwCtrlMsg22xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+        DBG("nCrcInfo=0x%x, nCrcInfoTp=0x%x\n", nCrcInfo, nCrcInfoTp);
+    }
+
+    g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+#ifdef CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif //CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM
+
+    if (eEmemType == EMEM_ALL)
+    {
+        if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo))
+        {
+            DBG("Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    else if (eEmemType == EMEM_MAIN)
+    {
+        if (nCrcMainTp != nCrcMain)
+        {
+            DBG("Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    else if (eEmemType == EMEM_INFO)
+    {
+        if (nCrcInfoTp != nCrcInfo)
+        {
+            DBG("Update FAILED\n");
+          
+            return -1;
+        } 
+    }
+    
+    DBG("Update SUCCESS\n");
+
+    return 0;
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareCash(u8 szFwData[][1024])
+{
+    DBG("*** %s() ***\n", __func__);
+
+    DBG("chip type = 0x%x\n", g_ChipType);
+    
+    if (g_ChipType == CHIP_TYPE_MSG21XXA) // (0x02)
+    {
+//        u16 nChipType;
+        u8 nChipVersion = 0;
+
+        DrvPlatformLyrTouchDeviceResetHw();
+
+        // Erase TP Flash first
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        mdelay(300);
+    
+        // Stop MCU
+        RegSetLByteValue(0x0FE6, 0x01);
+
+        // Disable watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+    
+        /////////////////////////
+        // Difference between C2 and C3
+        /////////////////////////
+        // c2:MSG2133(1) c32:MSG2133A(2) c33:MSG2138A(2)
+        // check ic type
+//        nChipType = RegGet16BitValue(0x1ECC) & 0xFF;
+            
+        // check ic version
+        nChipVersion = RegGet16BitValue(0x3CEA) & 0xFF;
+
+        DBG("chip version = 0x%x\n", nChipVersion);
+
+        if (nChipVersion == 3)
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+            return _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(szFwData, EMEM_MAIN);
+#else
+            return _DrvFwCtrlUpdateFirmwareC33(szFwData, EMEM_MAIN);
+#endif        
+        }
+        else
+        {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+            return _DrvFwCtrlMsg21xxaUpdateFirmwareBySwId(szFwData, EMEM_MAIN);
+#else
+            return _DrvFwCtrlUpdateFirmwareC32(szFwData, EMEM_ALL);
+#endif        
+        }
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX) // (0x7A)
+    {
+//        _DrvFwCtrlMsg22xxGetTpVendorCode(_gTpVendorCode);
+        
+//        if (_gTpVendorCode[0] == 'C' && _gTpVendorCode[1] == 'N' && _gTpVendorCode[2] == 'T') // for specific TP vendor which store some important information in info block, only update firmware for main block, do not update firmware for info block.
+//        {
+//            return _DrvFwCtrlMsg22xxUpdateFirmware(szFwData, EMEM_MAIN);
+//        }
+//        else
+//        {
+            return _DrvFwCtrlMsg22xxUpdateFirmware(szFwData, EMEM_ALL);
+//        }
+    }
+    else // CHIP_TYPE_MSG21XX (0x01)
+    {
+        DBG("Can not update firmware. Catch-2 is no need to be maintained now.\n");
+        g_FwDataCount = 0; // Reset g_FwDataCount to 0 after update firmware
+
+        return -1;
+    }
+}
+
+/*=============================================================*/
+// GLOBAL FUNCTION DEFINITION
+/*=============================================================*/
+
+u8 DrvFwCtrlGetChipType(void)
+{
+    u8 nChipType = 0;
+
+    DBG("*** %s() ***\n", __func__);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+
+    // Erase TP Flash first
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(300);
+
+    // Stop MCU
+    RegSetLByteValue(0x0FE6, 0x01);
+
+    // Disable watchdog
+    RegSet16BitValue(0x3C60, 0xAA55);
+    
+    /////////////////////////
+    // Difference between C2 and C3
+    /////////////////////////
+    // c2:MSG2133(1) c32:MSG2133A(2) c33:MSG2138A(2)
+    // check ic type
+    nChipType = RegGet16BitValue(0x1ECC) & 0xFF;
+
+    if (nChipType != CHIP_TYPE_MSG21XX &&   // (0x01) 
+        nChipType != CHIP_TYPE_MSG21XXA &&  // (0x02) 
+        nChipType != CHIP_TYPE_MSG26XXM &&  // (0x03) 
+        nChipType != CHIP_TYPE_MSG22XX)     // (0x7A) 
+    {
+        nChipType = 0;
+    }
+
+    DBG("*** Chip Type = 0x%x ***\n", nChipType);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    return nChipType;
+}
+
+void DrvFwCtrlGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion)
+{
+    DBG("*** %s() ***\n", __func__);
+    
+    if (g_ChipType == CHIP_TYPE_MSG21XXA || g_ChipType == CHIP_TYPE_MSG21XX)
+    {
+        u8 szDbBusTxData[3] = {0};
+        u8 szDbBusRxData[4] = {0};
+
+        szDbBusTxData[0] = 0x53;
+        szDbBusTxData[1] = 0x00;
+
+        if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {    
+            szDbBusTxData[2] = 0x2A;
+        }
+        else if (g_ChipType == CHIP_TYPE_MSG21XX)
+        {
+            szDbBusTxData[2] = 0x74;
+        }
+        else
+        {
+            szDbBusTxData[2] = 0x2A;
+        }
+
+        mutex_lock(&g_Mutex);
+
+        IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+        mutex_unlock(&g_Mutex);
+
+        *pMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+        *pMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)
+    {
+        u16 nRegData1, nRegData2;
+
+        mutex_lock(&g_Mutex);
+
+        DrvPlatformLyrTouchDeviceResetHw();
+    
+        DbBusEnterSerialDebugMode();
+        DbBusStopMCU();
+        DbBusIICUseBus();
+        DbBusIICReshape();
+        mdelay(100);
+        
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        // Clear pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xBFF4); // Set start address for customer firmware version on main block
+    
+        // Enable burst mode
+//        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        // Set pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+        RegSetLByteValue(0x160E, 0x01); 
+
+        nRegData1 = RegGet16BitValue(0x1604);
+        nRegData2 = RegGet16BitValue(0x1606);
+
+        *pMajor = (((nRegData1 >> 8) & 0xFF) << 8) + (nRegData1 & 0xFF);
+        *pMinor = (((nRegData2 >> 8) & 0xFF) << 8) + (nRegData2 & 0xFF);
+
+        // Clear burst mode
+//        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        DbBusIICNotUseBus();
+        DbBusNotStopMCU();
+        DbBusExitSerialDebugMode();
+
+        DrvPlatformLyrTouchDeviceResetHw();
+        mdelay(100);
+
+        mutex_unlock(&g_Mutex);
+    }
+
+    DBG("*** major = %d ***\n", *pMajor);
+    DBG("*** minor = %d ***\n", *pMinor);
+
+    if (*ppVersion == NULL)
+    {
+        *ppVersion = kzalloc(sizeof(u8)*6, GFP_KERNEL);
+    }
+    
+    sprintf(*ppVersion, "%03d%03d", *pMajor, *pMinor);
+}
+
+void DrvFwCtrlGetPlatformFirmwareVersion(u8 **ppVersion)
+{
+    u32 i;
+    u16 nRegData1, nRegData2;
+    u8 szDbBusRxData[12] = {0};
+
+    DBG("*** %s() ***\n", __func__);
+
+    mutex_lock(&g_Mutex);
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    
+    DbBusEnterSerialDebugMode();
+    DbBusStopMCU();
+    DbBusIICUseBus();
+    DbBusIICReshape();
+    mdelay(100);
+
+    if (g_ChipType == CHIP_TYPE_MSG22XX) // Only MSG22XX support platform firmware version
+    {
+        // Stop mcu
+        RegSetLByteValue(0x0FE6, 0x01); 
+
+        // Stop watchdog
+        RegSet16BitValue(0x3C60, 0xAA55);
+
+        // RIU password
+        RegSet16BitValue(0x161A, 0xABBA); 
+
+        // Clear pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x80));
+
+        RegSet16BitValue(0x1600, 0xC1F2); // Set start address for platform firmware version on info block(Actually, start reading from 0xC1F0)
+    
+        // Enable burst mode
+        RegSet16BitValue(0x160C, (RegGet16BitValue(0x160C) | 0x01));
+
+        // Set pce
+        RegSet16BitValue(0x1618, (RegGet16BitValue(0x1618) | 0x40)); 
+    
+        for (i = 0; i < 3; i ++)
+        {
+            RegSetLByteValue(0x160E, 0x01); 
+
+            nRegData1 = RegGet16BitValue(0x1604);
+            nRegData2 = RegGet16BitValue(0x1606);
+
+            szDbBusRxData[i*4+0] = (nRegData1 & 0xFF);
+            szDbBusRxData[i*4+1] = ((nRegData1 >> 8 ) & 0xFF);
+            
+//            DBG("szDbBusRxData[%d] = 0x%x , %c \n", i*4+0, szDbBusRxData[i*4+0], szDbBusRxData[i*4+0]); // add for debug
+//            DBG("szDbBusRxData[%d] = 0x%x , %c \n", i*4+1, szDbBusRxData[i*4+1], szDbBusRxData[i*4+1]); // add for debug
+            
+            szDbBusRxData[i*4+2] = (nRegData2 & 0xFF);
+            szDbBusRxData[i*4+3] = ((nRegData2 >> 8 ) & 0xFF);
+
+//            DBG("szDbBusRxData[%d] = 0x%x , %c \n", i*4+2, szDbBusRxData[i*4+2], szDbBusRxData[i*4+2]); // add for debug
+//            DBG("szDbBusRxData[%d] = 0x%x , %c \n", i*4+3, szDbBusRxData[i*4+3], szDbBusRxData[i*4+3]); // add for debug
+        }
+
+        // Clear burst mode
+        RegSet16BitValue(0x160C, RegGet16BitValue(0x160C) & (~0x01));      
+
+        RegSet16BitValue(0x1600, 0x0000); 
+
+        // Clear RIU password
+        RegSet16BitValue(0x161A, 0x0000); 
+
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*10, GFP_KERNEL);
+        }
+    
+        sprintf(*ppVersion, "%c%c%c%c%c%c%c%c%c%c", szDbBusRxData[2], szDbBusRxData[3], szDbBusRxData[4],
+            szDbBusRxData[5], szDbBusRxData[6], szDbBusRxData[7], szDbBusRxData[8], szDbBusRxData[9], szDbBusRxData[10], szDbBusRxData[11]);
+    }
+    else
+    {
+        if (*ppVersion == NULL)
+        {
+            *ppVersion = kzalloc(sizeof(u8)*10, GFP_KERNEL);
+        }
+    
+        sprintf(*ppVersion, "%s", "N/A");
+    }
+
+    DbBusIICNotUseBus();
+    DbBusNotStopMCU();
+    DbBusExitSerialDebugMode();
+
+    DrvPlatformLyrTouchDeviceResetHw();
+    mdelay(100);
+
+    mutex_unlock(&g_Mutex);
+    
+    DBG("*** platform firmware version = %s ***\n", *ppVersion);
+}
+
+s32 DrvFwCtrlUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType)
+{
+    DBG("*** %s() ***\n", __func__);
+
+    return _DrvFwCtrlUpdateFirmwareCash(szFwData);
+}	
+
+void DrvFwCtrlHandleFingerTouch(void)
+{
+    TouchInfo_t tInfo;
+    u32 i;
+    u8 nTouchKeyCode = 0;
+    static u32 nLastKeyCode = 0;
+    u8 *pPacket = NULL;
+    u16 nReportPacketLength = 0;
+
+//    DBG("*** %s() ***\n", __func__);
+    
+    memset(&tInfo, 0x0, sizeof(tInfo));
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+    if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE)
+    {
+        DBG("FIRMWARE_MODE_DEMO_MODE\n");
+
+        nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+        pPacket = g_DemoModePacket;
+    }
+    else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE)
+    {
+        DBG("FIRMWARE_MODE_DEBUG_MODE\n");
+
+        if (g_FirmwareInfo.nLogModePacketHeader != 0x62)
+        {
+            DBG("WRONG DEBUG MODE HEADER : 0x%x\n", g_FirmwareInfo.nLogModePacketHeader);
+            return;
+        }
+
+        if (g_LogModePacket == NULL)
+        {
+            g_LogModePacket = kzalloc(sizeof(u8)*g_FirmwareInfo.nLogModePacketLength, GFP_KERNEL);
+        }
+        
+        nReportPacketLength = g_FirmwareInfo.nLogModePacketLength;
+        pPacket = g_LogModePacket;
+    }
+    else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE)
+    {
+        DBG("FIRMWARE_MODE_RAW_DATA_MODE\n");
+
+        if (g_FirmwareInfo.nLogModePacketHeader != 0x62)
+        {
+            DBG("WRONG RAW DATA MODE HEADER : 0x%x\n", g_FirmwareInfo.nLogModePacketHeader);
+            return;
+        }
+
+        if (g_LogModePacket == NULL)
+        {
+            g_LogModePacket = kzalloc(sizeof(u8)*g_FirmwareInfo.nLogModePacketLength, GFP_KERNEL);
+        }
+        
+        nReportPacketLength = g_FirmwareInfo.nLogModePacketLength;
+        pPacket = g_LogModePacket;
+    }
+    else
+    {
+        DBG("WRONG FIRMWARE MODE : 0x%x\n", g_FirmwareMode);
+        return;
+    }
+#else
+    DBG("FIRMWARE_MODE_DEMO_MODE\n");
+
+    nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+    pPacket = g_DemoModePacket;
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        DBG("Set gesture wakeup packet length, g_ChipType=%d\n", g_ChipType);
+        
+        if (g_ChipType == CHIP_TYPE_MSG22XX)
+        {
+            if (_gGestureWakeupPacket == NULL)
+            {
+                _gGestureWakeupPacket = kzalloc(sizeof(u8)*GESTURE_WAKEUP_PACKET_LENGTH, GFP_KERNEL);
+            }
+
+            nReportPacketLength = GESTURE_WAKEUP_PACKET_LENGTH;
+            pPacket = _gGestureWakeupPacket;
+        } 
+        else if (g_ChipType == CHIP_TYPE_MSG21XXA)
+        {
+            if (_gGestureWakeupPacket == NULL)
+            {
+                _gGestureWakeupPacket = kzalloc(sizeof(u8)*DEMO_MODE_PACKET_LENGTH, GFP_KERNEL);
+            }
+
+        		nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+            pPacket = _gGestureWakeupPacket;
+        }
+        else
+        {
+            DBG("This chip type does not support gesture wakeup.\n");
+            return;
+        }
+    }
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM)
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+    if (g_GestureWakeupFlag == 1)
+    {
+        u32 i = 0, rc;
+        
+        while (i < 5)
+        {
+            mdelay(50);
+
+            rc = IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+            
+            if (rc > 0)
+            {
+                break;
+            }
+            
+            i ++;
+        }
+    }
+    else
+    {
+        IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+    }
+#else
+    IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP   
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaAlloc();
+#endif //CONFIG_ENABLE_DMA_IIC
+    IicReadData(SLAVE_I2C_ID_DWI2C, &pPacket[0], nReportPacketLength);
+#ifdef CONFIG_ENABLE_DMA_IIC
+    DmaFree();
+#endif //CONFIG_ENABLE_DMA_IIC
+#endif
+    
+    if (0 == _DrvFwCtrlParsePacket(pPacket, nReportPacketLength, &tInfo))
+    {
+        //report...
+        if ((tInfo.nFingerNum) == 0)   //touch end
+        {
+            if (nLastKeyCode != 0)
+            {
+                DBG("key touch released\n");
+
+                input_report_key(g_InputDevice, BTN_TOUCH, 0);
+                input_report_key(g_InputDevice, nLastKeyCode, 0);
+                    
+                nLastKeyCode = 0; //clear key status..
+            }
+            else
+            {
+                DrvPlatformLyrFingerTouchReleased(0, 0);
+            }
+        }
+        else //touch on screen
+        {
+            if (tInfo.nTouchKeyCode != 0)
+            {
+#ifdef CONFIG_TP_HAVE_KEY
+                if (tInfo.nTouchKeyCode == 4) // TOUCH_KEY_HOME
+                {
+                    nTouchKeyCode = g_TpVirtualKey[1];           
+                }
+                else if (tInfo.nTouchKeyCode == 1) // TOUCH_KEY_MENU
+                {
+                    nTouchKeyCode = g_TpVirtualKey[0];
+                }           
+                else if (tInfo.nTouchKeyCode == 2) // TOUCH_KEY_BACK
+                {
+                    nTouchKeyCode = g_TpVirtualKey[2];
+                }           
+                else if (tInfo.nTouchKeyCode == 8) // TOUCH_KEY_SEARCH 
+                {	
+                    nTouchKeyCode = g_TpVirtualKey[3];           
+                }
+
+                if (nLastKeyCode != nTouchKeyCode)
+                {
+                    DBG("key touch pressed\n");
+                    DBG("nTouchKeyCode = %d, nLastKeyCode = %d\n", nTouchKeyCode, nLastKeyCode);
+                    
+                    nLastKeyCode = nTouchKeyCode;
+
+                    input_report_key(g_InputDevice, BTN_TOUCH, 1);
+                    input_report_key(g_InputDevice, nTouchKeyCode, 1);
+                }
+#endif //CONFIG_TP_HAVE_KEY
+            }
+            else
+            {
+                DBG("tInfo->nFingerNum = %d...............\n", tInfo.nFingerNum);
+                
+                for (i = 0; i < tInfo.nFingerNum; i ++) 
+                {
+                    DrvPlatformLyrFingerTouchPressed(tInfo.tPoint[i].nX, tInfo.tPoint[i].nY, 0, 0);
+                }
+            }
+        }
+        
+        input_sync(g_InputDevice);
+    }
+}
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+void DrvFwCtrlOpenGestureWakeup(u16 nMode)
+{
+    u8 szDbBusTxData[3] = {0};
+    u32 i = 0;
+    s32 rc;
+
+    DBG("*** %s() ***\n", __func__);
+
+    DBG("wakeup mode = 0x%x\n", nMode);
+
+    szDbBusTxData[0] = 0x58;
+    szDbBusTxData[1] = (nMode >> 8) & 0xFF;
+    szDbBusTxData[2] = nMode & 0xFF;
+
+    while (i < 5)
+    {
+        rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+        
+        if (rc > 0)
+        {
+            DBG("Enable gesture wakeup success\n");
+            break;
+        }
+        
+        i ++;
+    }
+    
+    if (i == 5)
+    {
+        DBG("Enable gesture wakeup failed\n");		
+    }
+/*
+    rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+    if (rc < 0)
+    {
+        DBG("Enable gesture wakeup failed\n");
+    }
+    else
+    {
+        DBG("Enable gesture wakeup success\n");
+    }
+*/    
+    g_GestureWakeupFlag = 1; // gesture wakeup is enabled
+}
+
+void DrvFwCtrlCloseGestureWakeup(void)
+{
+//    u8 szDbBusTxData[3] = {0};
+//    s32 rc;
+
+    DBG("*** %s() ***\n", __func__);
+/*   
+    szDbBusTxData[0] = 0x58;
+    szDbBusTxData[1] = 0x00;
+    szDbBusTxData[2] = 0x00;
+
+    rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+    if (rc < 0)
+    {
+        DBG("Disable gesture wakeup failed\n");
+    }
+    else
+    {
+        DBG("Disable gesture wakeup success\n");
+    }
+*/
+    g_GestureWakeupFlag = 0; // gesture wakeup is disabled
+}
+
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+u16 DrvFwCtrlChangeFirmwareMode(u16 nMode)
+{
+    u8 szDbBusTxData[2] = {0};
+
+    DBG("*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x02;
+    szDbBusTxData[1] = (u8)nMode;
+
+    mdelay(20);
+    
+    mutex_lock(&g_Mutex);
+
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 2);
+
+    mutex_unlock(&g_Mutex);
+
+    return nMode;
+}
+
+void DrvFwCtrlGetFirmwareInfo(FirmwareInfo_t *pInfo)
+{
+    u8 szDbBusTxData[1] = {0};
+    u8 szDbBusRxData[8] = {0};
+    
+    DBG("*** %s() ***\n", __func__);
+
+    szDbBusTxData[0] = 0x01;
+
+    mutex_lock(&g_Mutex);
+    
+    mdelay(300);
+    IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+    mdelay(20);
+    IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 8);
+
+    mutex_unlock(&g_Mutex);
+    
+    if ((szDbBusRxData[1] & 0x80) == 0x80)
+    {
+        pInfo->nIsCanChangeFirmwareMode = 0;	
+    }
+    else
+    {
+        pInfo->nIsCanChangeFirmwareMode = 1;	
+    }
+    
+    pInfo->nFirmwareMode = szDbBusRxData[1] & 0x7F;
+    pInfo->nLogModePacketHeader = szDbBusRxData[2];
+    pInfo->nLogModePacketLength = (szDbBusRxData[3]<<8) + szDbBusRxData[4];
+
+    DBG("pInfo->nFirmwareMode=0x%x, pInfo->nLogModePacketHeader=0x%x, pInfo->nLogModePacketLength=%d, pInfo->nIsCanChangeFirmwareMode=%d\n", pInfo->nFirmwareMode, pInfo->nLogModePacketHeader, pInfo->nLogModePacketLength, pInfo->nIsCanChangeFirmwareMode);
+}
+
+void DrvFwCtrlRestoreFirmwareModeToLogDataMode(void)
+{
+    FirmwareInfo_t tInfo;
+    
+    DBG("*** %s() ***\n", __func__);
+
+    memset(&tInfo, 0x0, sizeof(FirmwareInfo_t));
+
+    DrvFwCtrlGetFirmwareInfo(&tInfo);
+
+    DBG("g_FirmwareMode = 0x%x, tInfo.nFirmwareMode = 0x%x\n", g_FirmwareMode, tInfo.nFirmwareMode);
+
+    // Since reset_hw() will reset the firmware mode to demo mode, we must reset the firmware mode again after reset_hw().
+    if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE && FIRMWARE_MODE_DEBUG_MODE != tInfo.nFirmwareMode)
+    {
+        g_FirmwareMode = DrvFwCtrlChangeFirmwareMode(FIRMWARE_MODE_DEBUG_MODE);
+    }
+    else if (g_FirmwareMode == FIRMWARE_MODE_RAW_DATA_MODE && FIRMWARE_MODE_RAW_DATA_MODE != tInfo.nFirmwareMode)
+    {
+        g_FirmwareMode = DrvFwCtrlChangeFirmwareMode(FIRMWARE_MODE_RAW_DATA_MODE);
+    }
+    else
+    {
+        DBG("firmware mode is not restored\n");
+    }
+}
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+//------------------------------------------------------------------------------//
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+void DrvFwCtrlCheckFirmwareUpdateBySwId(void)
+{
+    if (g_ChipType == CHIP_TYPE_MSG21XXA)   
+    {
+        _DrvFwCtrlMsg21xxaCheckFirmwareUpdateBySwId();
+    }
+    else if (g_ChipType == CHIP_TYPE_MSG22XX)    
+    {
+        _DrvFwCtrlMsg22xxCheckFirmwareUpdateBySwId();
+    }
+    else
+    {
+        DBG("This chip type (%d) does not support update firmware by sw id\n", g_ChipType);
+    }
+}	
+
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+//------------------------------------------------------------------------------//
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_self_fw_control.h b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_self_fw_control.h
new file mode 100644
index 0000000..d7cd0bf
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_self_fw_control.h
@@ -0,0 +1,154 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_self_fw_control.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_SELF_FW_CONTROL_H__
+#define __MSTAR_DRV_SELF_FW_CONTROL_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* COMPILE OPTION DEFINITION                                                */
+/*--------------------------------------------------------------------------*/
+
+//#define CONFIG_SWAP_X_Y
+
+//#define CONFIG_REVERSE_X
+//#define CONFIG_REVERSE_Y
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define DEMO_MODE_PACKET_LENGTH    (8)
+#define MAX_TOUCH_NUM           (2)     
+
+#define MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE (32) //32K
+#define MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE (1)  //1K
+#define MSG21XXA_FIRMWARE_WHOLE_SIZE (MSG21XXA_FIRMWARE_MAIN_BLOCK_SIZE+MSG21XXA_FIRMWARE_INFO_BLOCK_SIZE) //33K
+
+#define MSG22XX_FIRMWARE_MAIN_BLOCK_SIZE (48)  //48K
+#define MSG22XX_FIRMWARE_INFO_BLOCK_SIZE (512) //512Byte
+
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+#define FIRMWARE_MODE_DEMO_MODE      (0x00)
+#define FIRMWARE_MODE_DEBUG_MODE     (0x01)
+#define FIRMWARE_MODE_RAW_DATA_MODE  (0x02)
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+#define UPDATE_FIRMWARE_RETRY_COUNT (2)
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*--------------------------------------------------------------------------*/
+/* DATA TYPE DEFINITION                                                     */
+/*--------------------------------------------------------------------------*/
+
+typedef struct
+{
+    u16 nX;
+    u16 nY;
+} TouchPoint_t;
+
+typedef struct
+{
+    u8 nTouchKeyMode;
+    u8 nTouchKeyCode;
+    u8 nFingerNum;
+    TouchPoint_t tPoint[MAX_TOUCH_NUM];
+} TouchInfo_t;
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+typedef struct
+{
+    u8 nFirmwareMode;
+    u8 nLogModePacketHeader;
+    u16 nLogModePacketLength;
+    u8 nIsCanChangeFirmwareMode;
+} FirmwareInfo_t;
+
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+/*
+ * Note.
+ * The following is sw id enum definition for MSG22XX.
+ * 0x0000 and 0xFFFF are not allowed to be defined as SW ID.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum value depends on the TP vendor that you are using.
+ */
+typedef enum {
+    MSG22XX_SW_ID_XXXX = 0x0001,
+    MSG22XX_SW_ID_YYYY = 0x0002,  
+    MSG22XX_SW_ID_UNDEFINED
+} Msg22xxSwId_e;
+
+
+/*
+ * Note.
+ * The following is sw id enum definition for MSG21XXA.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum value depends on the TP vendor that you are using.
+ */
+typedef enum {
+    MSG21XXA_SW_ID_XXXX = 0,  
+    MSG21XXA_SW_ID_YYYY,
+    MSG21XXA_SW_ID_UNDEFINED
+} Msg21xxaSwId_e;
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern void DrvFwCtrlOpenGestureWakeup(u16 nMode);
+extern void DrvFwCtrlCloseGestureWakeup(void);
+#endif //CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_FIRMWARE_DATA_LOG
+extern u16 DrvFwCtrlChangeFirmwareMode(u16 nMode);        
+extern void DrvFwCtrlGetFirmwareInfo(FirmwareInfo_t *pInfo);
+extern void DrvFwCtrlRestoreFirmwareModeToLogDataMode(void);
+#endif //CONFIG_ENABLE_FIRMWARE_DATA_LOG
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+extern void DrvFwCtrlCheckFirmwareUpdateBySwId(void);
+#endif //CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+extern u8 DrvFwCtrlGetChipType(void);
+extern void DrvFwCtrlGetCustomerFirmwareVersion(u16 *pMajor, u16 *pMinor, u8 **ppVersion);
+extern void DrvFwCtrlGetPlatformFirmwareVersion(u8 **ppVersion);
+extern void DrvFwCtrlHandleFingerTouch(void);
+extern s32 DrvFwCtrlUpdateFirmware(u8 szFwData[][1024], EmemType_e eEmemType);
+        
+#endif  /* __MSTAR_DRV_SELF_FW_CONTROL_H__ */
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_utility_adaption.c b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_utility_adaption.c
new file mode 100644
index 0000000..a2eea38
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_utility_adaption.c
@@ -0,0 +1,406 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_utility_adaption.c
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+#include "mstar_drv_utility_adaption.h"
+
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Constant
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Variables
+////////////////////////////////////////////////////////////
+extern struct i2c_client *g_I2cClient;
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Function Implementation
+////////////////////////////////////////////////////////////
+
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+#include <linux/dma-mapping.h>
+#include <linux/mm_types.h>
+#include <linux/mm.h>
+#include <asm/uaccess.h>
+#include <asm/page.h>
+#include <linux/vmalloc.h>
+
+static unsigned char *I2CDMABuf_va = NULL;
+static volatile unsigned int I2CDMABuf_pa = NULL;
+
+void DmaAlloc(void)
+{
+    if (NULL == I2CDMABuf_va)
+    {
+        I2CDMABuf_va = (u8 *)dma_alloc_coherent(NULL, 4096, &I2CDMABuf_pa, GFP_KERNEL);
+    }
+    
+    if (NULL == I2CDMABuf_va)
+    {
+        DBG("DrvCommonDmaAlloc FAILED!");
+    }
+    else
+    {
+        DBG("DrvCommonDmaAlloc SUCCESS!");
+    }
+}
+
+void DmaFree(void)
+{
+    if (NULL != I2CDMABuf_va)
+    {
+        dma_free_coherent(NULL, 4096, I2CDMABuf_va, I2CDMABuf_pa);
+	      I2CDMABuf_va = NULL;
+	      I2CDMABuf_pa = 0;
+    }
+}
+#endif //CONFIG_ENABLE_DMA_IIC
+
+//------------------------------------------------------------------------------//
+
+u16 RegGet16BitValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+    u8 rx_data[2] = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data[0], 2);
+
+    return (rx_data[1] << 8 | rx_data[0]);
+}
+
+u8 RegGetLByteValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+    u8 rx_data = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data, 1);
+
+    return (rx_data);
+}
+
+u8 RegGetHByteValue(u16 nAddr)
+{
+    u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, (nAddr & 0xFF) + 1};
+    u8 rx_data = {0};
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+    IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data, 1);
+
+    return (rx_data);
+}
+
+void RegSet16BitValue(u16 nAddr, u16 nData)
+{
+    u8 tx_data[5] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF, nData & 0xFF, nData >> 8};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 5);
+}
+
+void RegSetLByteValue(u16 nAddr, u8 nData)
+{
+    u8 tx_data[4] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF, nData};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 4);
+}
+
+void RegSetHByteValue(u16 nAddr, u8 nData)
+{
+    u8 tx_data[4] = {0x10, (nAddr >> 8) & 0xFF, (nAddr & 0xFF) + 1, nData};
+    IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 4);
+}
+
+void RegSet16BitValueOn(u16 nAddr, u16 nData) //Set bit on nData from 0 to 1
+{
+    u16 rData = RegGet16BitValue(nAddr);
+    rData |= nData;
+    RegSet16BitValue(nAddr, rData);
+}
+
+void RegSet16BitValueOff(u16 nAddr, u16 nData) //Set bit on nData from 1 to 0
+{
+    u16 rData = RegGet16BitValue(nAddr);
+    rData &= (~nData);
+    RegSet16BitValue(nAddr, rData);
+}
+
+void DbBusEnterSerialDebugMode(void)
+{
+    u8 data[5];
+
+    // Enter the Serial Debug Mode
+    data[0] = 0x53;
+    data[1] = 0x45;
+    data[2] = 0x52;
+    data[3] = 0x44;
+    data[4] = 0x42;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 5);
+}
+
+void DbBusExitSerialDebugMode(void)
+{
+    u8 data[1];
+
+    // Exit the Serial Debug Mode
+    data[0] = 0x45;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+    
+    // Delay some interval to guard the next transaction
+//    udelay(200);        // delay about 0.2ms
+}
+
+void DbBusIICUseBus(void)
+{
+    u8 data[1];
+
+    // IIC Use Bus
+    data[0] = 0x35;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusIICNotUseBus(void)
+{
+    u8 data[1];
+
+    // IIC Not Use Bus
+    data[0] = 0x34;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusIICReshape(void)
+{
+    u8 data[1];
+
+    // IIC Re-shape
+    data[0] = 0x71;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusStopMCU(void)
+{
+    u8 data[1];
+
+    // Stop the MCU
+    data[0] = 0x37;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusNotStopMCU(void)
+{
+    u8 data[1];
+
+    // Not Stop the MCU
+    data[0] = 0x36;
+
+    IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+s32 IicWriteData(u8 nSlaveId, u8* pBuf, u16 nSize)
+{
+    s32 rc = 0;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    struct i2c_msg msgs[] =
+    {
+        {
+            .addr = nSlaveId,
+            .flags = 0, // if read flag is undefined, then it means write flag.
+            .len = nSize,
+            .buf = pBuf,
+        },
+    };
+
+    /* If everything went ok (i.e. 1 msg transmitted), return #bytes
+       transmitted, else error code. */
+    if (g_I2cClient != NULL)
+    {
+        rc = i2c_transfer(g_I2cClient->adapter, msgs, 1);
+        if (rc < 0)
+        {
+            PRINTF_ERR("IicWriteData() error %d\n", rc);
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (g_I2cClient != NULL)
+    {
+        u8 nAddrBefore = g_I2cClient->addr;
+        g_I2cClient->addr = nSlaveId;
+//        g_I2cClient->addr = (g_I2cClient->addr & I2C_MASK_FLAG ) | (I2C_ENEXT_FLAG);
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+        if (nSize > 8 && NULL != I2CDMABuf_va)
+        {
+            s32 i = 0;
+	          
+            for (i = 0; i < nSize; i ++)
+            {
+                I2CDMABuf_va[i] = pBuf[i];
+            }
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag | I2C_DMA_FLAG;
+            rc = i2c_master_send(g_I2cClient, (unsigned char *)I2CDMABuf_pa, nSize);
+        }
+        else
+        {
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag & (~I2C_DMA_FLAG);	
+            rc = i2c_master_send(g_I2cClient, pBuf, nSize);
+        }
+#else
+        rc = i2c_master_send(g_I2cClient, pBuf, nSize);
+#endif //CONFIG_ENABLE_DMA_IIC
+        g_I2cClient->addr = nAddrBefore;
+
+        if (rc < 0)
+        {
+            PRINTF_ERR("IicWriteData() error %d, nSlaveId=%d, nSize=%d\n", rc, nSlaveId, nSize);
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#endif
+    
+    return rc;
+}
+
+s32 IicReadData(u8 nSlaveId, u8* pBuf, u16 nSize)
+{
+    s32 rc = 0;
+
+#if defined(CONFIG_TOUCH_DRIVER_RUN_ON_SPRD_PLATFORM) || defined(CONFIG_TOUCH_DRIVER_RUN_ON_QCOM_PLATFORM)
+    struct i2c_msg msgs[] =
+    {
+        {
+            .addr = nSlaveId,
+            .flags = I2C_M_RD, // read flag
+            .len = nSize,
+            .buf = pBuf,
+        },
+    };
+
+    /* If everything went ok (i.e. 1 msg transmitted), return #bytes
+       transmitted, else error code. */
+    if (g_I2cClient != NULL)
+    {
+        rc = i2c_transfer(g_I2cClient->adapter, msgs, 1);
+        if (rc < 0)
+        {
+            PRINTF_ERR("IicReadData() error %d\n", rc);
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#elif defined(CONFIG_TOUCH_DRIVER_RUN_ON_MTK_PLATFORM)
+    if (g_I2cClient != NULL)
+    {
+        u8 nAddrBefore = g_I2cClient->addr;
+        g_I2cClient->addr = nSlaveId;
+//        g_I2cClient->addr = (g_I2cClient->addr & I2C_MASK_FLAG) | (I2C_ENEXT_FLAG);
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+        if (nSize > 8 && NULL != I2CDMABuf_va)
+        {
+            s32 i = 0;
+        
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag | I2C_DMA_FLAG;
+            rc = i2c_master_recv(g_I2cClient, (unsigned char *)I2CDMABuf_pa, nSize);
+        
+            for (i = 0; i < nSize; i ++)
+            {
+                pBuf[i] = I2CDMABuf_va[i];
+            }
+        }
+        else
+        {
+            g_I2cClient->ext_flag = g_I2cClient->ext_flag & (~I2C_DMA_FLAG);	
+            rc = i2c_master_recv(g_I2cClient, pBuf, nSize);
+        }
+#else
+        rc = i2c_master_recv(g_I2cClient, pBuf, nSize);
+#endif //CONFIG_ENABLE_DMA_IIC
+        g_I2cClient->addr = nAddrBefore;
+
+        if (rc < 0)
+        {
+            PRINTF_ERR("IicReadData() error %d, nSlaveId=%d, nSize=%d\n", rc, nSlaveId, nSize);
+        }
+    }
+    else
+    {
+        PRINTF_ERR("i2c client is NULL\n");
+    }
+#endif
+    
+    return rc;
+}
+
+void mstpMemSet(void *pDst, s8 nVal, u32 nSize)
+{
+    memset(pDst, nVal, nSize);
+}
+
+void mstpMemCopy(void *pDst, void *pSource, u32 nSize)
+{
+    memcpy(pDst, pSource, nSize);
+}
+
+void mstpDelay(u32 nTime)
+{
+    mdelay(nTime);
+}
+
+//------------------------------------------------------------------------------//
diff --git a/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_utility_adaption.h b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_utility_adaption.h
new file mode 100644
index 0000000..5e72956
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg2133/mstar_drv_utility_adaption.h
@@ -0,0 +1,101 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2006-2012 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses, costs and expenses resulting therefrom.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+/**
+ *
+ * @file    mstar_drv_utility_adaption.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ * @version v2.2.0.0
+ *
+ */
+
+#ifndef __MSTAR_DRV_UTILITY_ADAPTION_H__
+#define __MSTAR_DRV_UTILITY_ADAPTION_H__ (1)
+
+
+////////////////////////////////////////////////////////////
+/// Included Files
+////////////////////////////////////////////////////////////
+
+#include "mstar_drv_common.h"
+
+////////////////////////////////////////////////////////////
+/// Constant
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Data Types
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Variables
+////////////////////////////////////////////////////////////
+
+
+////////////////////////////////////////////////////////////
+/// Macro
+////////////////////////////////////////////////////////////
+#define BK_REG8_WL(addr,val)    ( RegSetLByteValue( addr, val ) )
+#define BK_REG8_WH(addr,val)    ( RegSetHByteValue( addr, val ) )
+#define BK_REG16_W(addr,val)    ( RegSet16BitValue( addr, val ) )
+#define BK_REG8_RL(addr)        ( RegGetLByteValue( addr ) )
+#define BK_REG8_RH(addr)        ( RegGetHByteValue( addr ) )
+#define BK_REG16_R(addr)        ( RegGet16BitValue( addr ) )
+
+#define PRINTF_EMERG(fmt, ...)  printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_ALERT(fmt, ...)  printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_CRIT(fmt, ...)   printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__) 
+#define PRINTF_ERR(fmt, ...)    printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_WARN(fmt, ...)   printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_NOTICE(fmt, ...) printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_INFO(fmt, ...)   printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_DEBUG(fmt, ...)  printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__) 
+
+////////////////////////////////////////////////////////////
+/// Function Prototypes
+////////////////////////////////////////////////////////////
+
+#ifdef CONFIG_ENABLE_DMA_IIC
+extern void DmaAlloc(void);
+extern void DmaFree(void);
+#endif //CONFIG_ENABLE_DMA_IIC
+extern u16  RegGet16BitValue(u16 nAddr);
+extern u8   RegGetLByteValue(u16 nAddr);
+extern u8   RegGetHByteValue(u16 nAddr);
+extern void RegSet16BitValue(u16 nAddr, u16 nData);
+extern void RegSetLByteValue(u16 nAddr, u8 nData);
+extern void RegSetHByteValue(u16 nAddr, u8 nData);
+extern void RegSet16BitValueOn(u16 nAddr, u16 nData);
+extern void RegSet16BitValueOff(u16 nAddr, u16 nData);
+extern void DbBusEnterSerialDebugMode(void);
+extern void DbBusExitSerialDebugMode(void);
+extern void DbBusIICUseBus(void);
+extern void DbBusIICNotUseBus(void);
+extern void DbBusIICReshape(void);
+extern void DbBusStopMCU(void);
+extern void DbBusNotStopMCU(void);
+extern s32 IicWriteData(u8 nSlaveId, u8* pBuf, u16 nSize);
+extern s32 IicReadData(u8 nSlaveId, u8* pBuf, u16 nSize);
+extern void mstpMemSet(void *pDst, s8 nVal, u32 nSize);
+extern void mstpMemCopy(void *pDst, void *pSource, u32 nSize);
+extern void mstpDelay(u32 nTime);
+
+#endif // __MSTAR_DRV_UTILITY_ADAPTION_H__
-- 
1.9.1

