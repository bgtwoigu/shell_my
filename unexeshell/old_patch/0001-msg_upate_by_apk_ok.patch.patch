From 345ebe818edc186f782f1970666975358895e217 Mon Sep 17 00:00:00 2001
From: "haolong.zhang" <haolong.zhang@ck-telecom.com>
Date: Fri, 17 Oct 2014 17:34:07 +0800
Subject: [PATCH] msg_upate_by_apk_ok.patch

Change-Id: Icfd70d2fcaf7c4b0977ee46f442075c881039a66
---
 mediatek/config/ckt95_lw_kk/ProjectConfig.mk       |    2 +-
 .../touchpanel/msg_test/msg2133_driver_gesture.c   | 3852 ++++++++++++++++++++
 .../touchpanel/msg_test/tpd_custom_msg2133.h       |  156 +
 3 files changed, 4009 insertions(+), 1 deletion(-)
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg_test/msg2133_driver_gesture.c
 create mode 100644 mediatek/custom/common/kernel/touchpanel/msg_test/tpd_custom_msg2133.h

diff --git a/mediatek/config/ckt95_lw_kk/ProjectConfig.mk b/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
index fda8f33..5f984cb 100755
--- a/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
+++ b/mediatek/config/ckt95_lw_kk/ProjectConfig.mk
@@ -169,7 +169,7 @@ CUSTOM_KERNEL_SUB_IMGSENSOR=
 CUSTOM_KERNEL_SUB_LENS=
 
 # touch driver  need to report correct touch axes
-CUSTOM_KERNEL_TOUCHPANEL=msg2133_and_ektf2k  #GT9XX_hotknot
+CUSTOM_KERNEL_TOUCHPANEL=msg_test  #GT9XX_hotknot
 
 # Configuration for USB PHY
 CUSTOM_KERNEL_USB=mt6577
diff --git a/mediatek/custom/common/kernel/touchpanel/msg_test/msg2133_driver_gesture.c b/mediatek/custom/common/kernel/touchpanel/msg_test/msg2133_driver_gesture.c
new file mode 100644
index 0000000..c1fa855
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg_test/msg2133_driver_gesture.c
@@ -0,0 +1,3852 @@
+#include "tpd.h"
+#include <linux/interrupt.h>
+#include <cust_eint.h>
+#include <linux/i2c.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/rtpm_prio.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <mach/mt_gpio.h>//hanwc
+#include "tpd_custom_msg2133.h"
+
+#include <mach/mt_pm_ldo.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_boot.h>
+#include "cust_gpio_usage.h"
+
+/*Open OR Close Debug Info*/
+#define __TPD_DEBUG__ 
+#define TP_DEBUG_ERR  printk
+/*Ctp Power Off In Sleep ? */
+//#define TPD_CLOSE_POWER_IN_SLEEP
+
+ //#define MSG_GESTURE_FUNCTION
+ 
+#ifdef __TP_PROXIMITY_SUPPORT__	// add by gpg
+#include <linux/hwmsensor.h>
+#include <linux/hwmsen_dev.h>
+#include <linux/wakelock.h>
+
+#define APS_TAG                  "[ALS/PS] "
+#define APS_FUN(f)               printk(KERN_INFO APS_TAG"%s\n", __FUNCTION__)
+#define APS_ERR(fmt, args...)    printk(KERN_ERR  APS_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
+#define APS_LOG(fmt, args...)    printk(KERN_INFO APS_TAG fmt, ##args)
+#define APS_DBG(fmt, args...)    printk(KERN_INFO APS_TAG fmt, ##args)   
+
+static DEFINE_MUTEX(msg2133_sensor_mutex);
+
+static int g_bPsSensorOpen = 0;
+static int g_nPsSensorDate = 0;
+static int g_bSuspend = 0;
+static struct wake_lock ps_lock;
+
+static int msg2133_enable_ps(int enable);
+static void tpd_initialize_ps_sensor_function();
+extern bool g_call_state;
+#endif
+ 
+extern struct tpd_device *tpd;
+
+/*Use For Get CTP Data By I2C*/ 
+static struct i2c_client *i2c_client = NULL;
+
+/*Use For Firmware Update By I2C*/
+//static struct i2c_client     *msg21xx_i2c_client = NULL;
+
+//struct task_struct *thread = NULL;
+
+
+#ifdef MSG_GESTURE_FUNCTION
+#define MSG_GESTURE_FUNCTION_NODE_PROC
+#define CTP_GESTURE_FUNCTION_AUTHORITY_PROC 0777 
+
+
+#define MSG_GESTURE_FUNCTION_DOUBLECLICK_FLAG  0x01    ///0000 0001
+#define MSG_GESTURE_FUNCTION_UPDIRECT_FLAG     0x02    ///0000 0010
+#define MSG_GESTURE_FUNCTION_DOWNDIRECT_FLAG   0x04    ///0000 0100
+#define MSG_GESTURE_FUNCTION_LEFTDIRECT_FLAG   0x08    ///0000 1000
+#define MSG_GESTURE_FUNCTION_RIGHTDIRECT_FLAG  0x10    ///0001 0000
+
+static u8 tpd_gesture_flag = 0;////if 1,enter gesture mode success;
+
+///if 1; the tp return mode is this mode 
+static u8 tpd_gesture_double_click_mode = 0;
+static u8 tpd_gesture_up_direct_mode = 0;
+static u8 tpd_gesture_down_direct_mode = 0;
+static u8 tpd_gesture_left_direct_mode = 0;
+static u8 tpd_gesture_right_direct_mode = 0;
+
+static u8 set_gesture_flag = 0;  
+
+/////1:want to open this mode
+static u8 set_gesture_double_click_mode = 0x01;
+static u8 set_gesture_up_direct_mode = 0x02;
+static u8 set_gesture_down_direct_mode = 0x04;
+static u8 set_gesture_left_direct_mode = 0x08; 
+static u8 set_gesture_right_direct_mode = 0x10;
+
+////right_flag | left_flag | down_flag | up_flag | doubleclick_flag
+static u8 set_gesture_mode = 0;////
+#endif
+
+
+
+static DECLARE_WAIT_QUEUE_HEAD(waiter);
+//static DEFINE_MUTEX(i2c_access);
+//#define SWAP_X_Y
+typedef struct
+{
+    u16 X;
+    u16 Y;
+} TouchPoint_t;
+
+/*CTP Data Package*/
+typedef struct
+{
+    u8 nTouchKeyMode;
+    u8 nTouchKeyCode;
+    u8 nFingerNum;
+    TouchPoint_t Point[MAX_TOUCH_FINGER];
+} TouchScreenInfo_t;
+
+ 
+static void tpd_eint_interrupt_handler(void);
+static struct work_struct    msg21xx_wq;
+
+#ifdef TPD_HAVE_BUTTON 
+static int tpd_keys_local[TPD_KEY_COUNT] = TPD_KEYS;
+static int tpd_keys_dim_local[TPD_KEY_COUNT][4] = TPD_KEYS_DIM;
+#endif
+
+#if 0
+extern void mt65xx_eint_unmask(unsigned int line);
+extern void mt65xx_eint_mask(unsigned int line);
+extern void mt65xx_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
+extern unsigned int mt65xx_eint_set_sens(unsigned int eint_num, unsigned int sens);
+extern void mt65xx_eint_registration(unsigned int eint_num, unsigned int is_deb_en, unsigned int pol, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
+#endif
+
+ 
+static int tpd_probe(struct i2c_client *client, const struct i2c_device_id *id);
+static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info);
+static int tpd_remove(struct i2c_client *client);
+static int touch_event_handler(void *unused);
+ 
+
+static int tpd_flag = 0;
+static int tpd_halt=0;
+static int point_num = 0;
+static int p_point_num = 0;
+#if 0    
+#ifdef GPIO_CTP_RST_PIN
+#undef GPIO_CTP_RST_PIN
+
+#define GPIO_CTP_RST_PIN GPIO87
+#endif
+#endif
+#define TPD_OK 0
+
+ 
+ static const struct i2c_device_id msg2133_tpd_id[] = {{"msg2133",0},{}};
+
+ static struct i2c_board_info __initdata msg2133_i2c_tpd={ I2C_BOARD_INFO("msg2133", (0x26))};
+ 
+ 
+ static struct i2c_driver tpd_i2c_driver = {
+  .driver = {
+	 .name = "msg2133",//.name = TPD_DEVICE,
+//	 .owner = THIS_MODULE,
+  },
+  .probe = tpd_probe,
+  .remove = tpd_remove,
+  .id_table = msg2133_tpd_id,
+  .detect = tpd_detect,
+//  .address_data = &addr_data,
+ };
+ //start for update firmware //msz   for update firmware 20121126
+#define __FIRMWARE_UPDATE__
+#ifdef __FIRMWARE_UPDATE__
+
+#define FW_ADDR_MSG21XX   (0xC4>>1)
+#define FW_ADDR_MSG21XX_TP   (0x4C>>1)
+#define FW_UPDATE_ADDR_MSG21XX   (0x92>>1)
+
+static  char *fw_version;
+static u8 temp[94][1024];
+static int FwDataCnt;
+struct class *firmware_class;
+struct device *firmware_cmd_dev;
+
+static void HalTscrCReadI2CSeq(u8 addr, u8* read_data, u16 size)
+{
+    int ret;
+    i2c_client->addr = addr;
+    ret = i2c_master_recv(i2c_client, read_data, size);
+    i2c_client->addr = FW_ADDR_MSG21XX_TP;
+    
+    if(ret <= 0)
+    {
+		TP_DEBUG_ERR("HalTscrCReadI2CSeq error %d,addr = %d\n", ret,addr);
+	}
+}
+
+static void HalTscrCDevWriteI2CSeq(u8 addr, u8* data, u16 size)
+{
+    int ret;
+    i2c_client->addr = addr;
+    ret = i2c_master_send(i2c_client, data, size);
+    i2c_client->addr = FW_ADDR_MSG21XX_TP;
+
+    if(ret <= 0)
+    {
+		TP_DEBUG_ERR("HalTscrCDevWriteI2CSeq error %d,addr = %d\n", ret,addr);
+	}
+}
+
+
+static void dbbusDWIICEnterSerialDebugMode( void )
+{
+    u8 data[5];
+
+    // Enter the Serial Debug Mode
+    data[0] = 0x53;
+    data[1] = 0x45;
+    data[2] = 0x52;
+    data[3] = 0x44;
+    data[4] = 0x42;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, data, 5 );
+}
+
+static void dbbusDWIICStopMCU( void )
+{
+    u8 data[1];
+
+    // Stop the MCU
+    data[0] = 0x37;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, data, 1 );
+}
+
+static void dbbusDWIICIICUseBus( void )
+{
+    u8 data[1];
+
+    // IIC Use Bus
+    data[0] = 0x35;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, data, 1 );
+}
+
+static void dbbusDWIICIICReshape( void )
+{
+    u8 data[1];
+
+    // IIC Re-shape
+    data[0] = 0x71;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, data, 1 );
+}
+
+static void dbbusDWIICIICNotUseBus( void )
+{
+    u8 data[1];
+
+    // IIC Not Use Bus
+    data[0] = 0x34;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, data, 1 );
+}
+
+static void dbbusDWIICNotStopMCU( void )
+{
+    u8 data[1];
+
+    // Not Stop the MCU
+    data[0] = 0x36;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, data, 1 );
+}
+
+static void dbbusDWIICExitSerialDebugMode( void )
+{
+    u8 data[1];
+
+    // Exit the Serial Debug Mode
+    data[0] = 0x45;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, data, 1 );
+
+    // Delay some interval to guard the next transaction
+    //udelay ( 200 );        // delay about 0.2ms
+}
+
+static void drvISP_EntryIspMode( void )
+{
+    u8 bWriteData[5] =
+    {
+        0x4D, 0x53, 0x54, 0x41, 0x52
+    };
+
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 5 );
+}
+
+static u8 drvISP_Read( u8 n, u8* pDataToRead )  //First it needs send 0x11 to notify we want to get flash data back.
+{
+    u8 Read_cmd = 0x11;
+    unsigned char dbbus_rx_data[2] = {0xFF, 0xFF};
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &Read_cmd, 1 );
+    msleep(1);         // delay about 1000us*****
+    if( n == 1 )
+    {
+        HalTscrCReadI2CSeq( FW_UPDATE_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+
+        // Ideally, the obtained dbbus_rx_data[0~1] stands for the following meaning:
+        //  dbbus_rx_data[0]  |  dbbus_rx_data[1]  | status
+        // -------------------+--------------------+--------
+        //       0x00         |       0x00         |  0x00
+        // -------------------+--------------------+--------
+        //       0x??         |       0x00         |  0x??
+        // -------------------+--------------------+--------
+        //       0x00         |       0x??         |  0x??
+        //                 
+        // Therefore, we build this field patch to return the status to *pDataToRead.
+        *pDataToRead = ( (dbbus_rx_data[0] >= dbbus_rx_data[1] )? \
+                          dbbus_rx_data[0]  : dbbus_rx_data[1] );
+    }
+    else
+    {
+        HalTscrCReadI2CSeq( FW_UPDATE_ADDR_MSG21XX, pDataToRead, n );
+    }
+
+    return 0;
+}
+
+static void drvISP_WriteEnable( void )
+{
+    u8 bWriteData[2] =
+    {
+        0x10, 0x06
+    };
+    u8 bWriteData1 = 0x12;
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 2 );
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+}
+
+
+static void drvISP_ExitIspMode( void )
+{
+    u8 bWriteData = 0x24;
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData, 1 );
+}
+
+static u8 drvISP_ReadStatus( void )
+{
+    u8 bReadData = 0;
+    u8 bWriteData[2] =
+    {
+        0x10, 0x05
+    };
+    u8 bWriteData1 = 0x12;
+
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 2 );
+    udelay(100);         // delay about 100us*****
+    drvISP_Read( 1, &bReadData );
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+    return bReadData;
+}
+
+
+static void drvISP_ChipErase()
+{
+    u8 bWriteData[5] = { 0x00, 0x00, 0x00, 0x00, 0x00 };
+    u8 bWriteData1 = 0x12;
+    u32 timeOutCount = 0;
+    drvISP_WriteEnable();
+
+    //Enable write status register
+    bWriteData[0] = 0x10;
+    bWriteData[1] = 0x50;
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 2 );
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+
+    //Write Status
+    bWriteData[0] = 0x10;
+    bWriteData[1] = 0x01;
+    bWriteData[2] = 0x00;
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 3 );
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+
+    //Write disable
+    bWriteData[0] = 0x10;
+    bWriteData[1] = 0x04;
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 2 );
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+    udelay( 100 );         // delay about 100us*****
+    timeOutCount = 0;
+    while( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+    {
+        timeOutCount++;
+        if( timeOutCount >= 100000 ) break;  /* around 1 sec timeout */
+    }
+    drvISP_WriteEnable();
+
+    bWriteData[0] = 0x10;
+    bWriteData[1] = 0xC7;
+
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 2 );
+    HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+    udelay( 100 );         // delay about 100us*****
+    timeOutCount = 0;
+    while( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+    {
+        timeOutCount++;
+        if( timeOutCount >= 500000 ) break;  /* around 5 sec timeout */
+    }
+}
+
+static void drvISP_Program( u16 k, u8* pDataToWrite )
+{
+    u16 i = 0;
+    u16 j = 0;
+    //u16 n = 0;
+    u8 TX_data[133];
+    u8 bWriteData1 = 0x12;
+    u32 addr = k * 1024;
+    u32 timeOutCount = 0;
+    for( j = 0; j < 8; j++ )  //128*8 cycle
+    {
+        TX_data[0] = 0x10;
+        TX_data[1] = 0x02;// Page Program CMD
+        TX_data[2] = ( addr + 128 * j ) >> 16;
+        TX_data[3] = ( addr + 128 * j ) >> 8;
+        TX_data[4] = ( addr + 128 * j );
+        for( i = 0; i < 128; i++ )
+        {
+            TX_data[5 + i] = pDataToWrite[j * 128 + i];
+        }
+        udelay( 100 );         // delay about 100us*****
+
+        timeOutCount = 0;
+        while( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+        {
+            timeOutCount++;
+            if( timeOutCount >= 100000 ) break;  /* around 1 sec timeout */
+        }
+
+
+
+        drvISP_WriteEnable();
+        HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, TX_data, 133 ); //write 133 byte per cycle
+        HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );
+    }
+}
+
+
+static void drvISP_Verify( u16 k, u8* pDataToVerify )
+{
+    u16 i = 0, j = 0;
+    u8 bWriteData[5] =
+    {
+        0x10, 0x03, 0, 0, 0
+    };
+    u8 RX_data[256];
+    u8 bWriteData1 = 0x12;
+    u32 addr = k * 1024;
+    u8 index = 0;
+    u32 timeOutCount;
+    for( j = 0; j < 8; j++ )  //128*8 cycle
+    {
+        bWriteData[2] = ( u8 )( ( addr + j * 128 ) >> 16 );
+        bWriteData[3] = ( u8 )( ( addr + j * 128 ) >> 8 );
+        bWriteData[4] = ( u8 )( addr + j * 128 );
+        udelay( 100 );         // delay about 100us*****
+
+
+        timeOutCount = 0;
+        while( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+        {
+            timeOutCount++;
+            if( timeOutCount >= 100000 ) break;  /* around 1 sec timeout */
+        }
+
+
+
+        HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 5 );  //write read flash addr
+        udelay( 100 );          // delay about 100us*****
+        drvISP_Read( 128, RX_data );
+        HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );  //cmd end
+        for( i = 0; i < 128; i++ )  //log out if verify error
+        {
+            if( ( RX_data[i] != 0 ) && index < 10 )
+            {
+                //TPD_DEBUG("j=%d,RX_data[%d]=0x%x\n",j,i,RX_data[i]);
+                index++;
+            }
+            if( RX_data[i] != pDataToVerify[128 * j + i] )
+            {
+                TPD_DEBUG( "k=%d,j=%d,i=%d===============Update Firmware Error================", k, j, i );
+            }
+        }
+    }
+}
+
+static ssize_t firmware_update_show( struct device *dev,
+                                     struct device_attribute *attr, char *buf )
+{
+    return sprintf( buf, "%s\n", fw_version );
+}
+
+static void _HalTscrHWReset( void )
+{
+#if 0
+    gpio_direction_output( MSG21XX_RESET_GPIO, 1 );
+    gpio_set_value( MSG21XX_RESET_GPIO, 1 );
+    gpio_set_value( MSG21XX_RESET_GPIO, 0 );
+    mdelay( 10 ); /* Note that the RST must be in LOW 10ms at least */
+    gpio_set_value( MSG21XX_RESET_GPIO, 1 );
+    /* Enable the interrupt service thread/routine for INT after 50ms */
+    mdelay( 50 );
+#endif
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
+	msleep(10);
+	TPD_DMESG("############# msg2133 reset\n");
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+	mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+	msleep(300);
+
+}
+
+
+/* update the firmware part, used by apk*/
+/*show the fw version*/
+#define _FW_UPDATE_C3_
+#ifdef _FW_UPDATE_C3_
+#define u8         unsigned char
+#define u32        unsigned int
+#define s32        signed int
+
+u32 crc_tab[256];
+static u8 g_dwiic_info_data[1024];   // Buffer for info data
+#define N_BYTE_PER_TIME (8)//adai
+#define UPDATE_TIMES (1024/N_BYTE_PER_TIME)
+
+static ssize_t firmware_update_c2 ( struct device *dev,
+                                    struct device_attribute *attr, const char *buf, size_t size )
+	{
+		u8 i;
+		u8 dbbus_tx_data[4];
+		unsigned char dbbus_rx_data[2] = {0};
+	
+	
+		_HalTscrHWReset();
+		//1.Erase TP Flash first
+		dbbusDWIICEnterSerialDebugMode();
+		dbbusDWIICStopMCU();
+		dbbusDWIICIICUseBus();
+		dbbusDWIICIICReshape();
+		msleep( 300 );
+	
+	
+		// Disable the Watchdog
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x3C;
+		dbbus_tx_data[2] = 0x60;
+		dbbus_tx_data[3] = 0x55;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x3C;
+		dbbus_tx_data[2] = 0x61;
+		dbbus_tx_data[3] = 0xAA;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		//Stop MCU
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x0F;
+		dbbus_tx_data[2] = 0xE6;
+		dbbus_tx_data[3] = 0x01;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+		//set FRO to 50M
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x11;
+		dbbus_tx_data[2] = 0xE2;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+		dbbus_rx_data[0] = 0;
+		dbbus_rx_data[1] = 0;
+		HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+		TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+		dbbus_tx_data[3] = dbbus_rx_data[0] & 0xF7;  //Clear Bit 3
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+	
+		//set MCU clock,SPI clock =FRO
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x22;
+		dbbus_tx_data[3] = 0x00;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x23;
+		dbbus_tx_data[3] = 0x00;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+		// Enable slave's ISP ECO mode
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x08;
+		dbbus_tx_data[2] = 0x0c;
+		dbbus_tx_data[3] = 0x08;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		//Enable SPI Pad
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x02;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+		HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+		TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+		dbbus_tx_data[3] = ( dbbus_rx_data[0] | 0x20 ); //Set Bit 5
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+		//WP overwrite
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x0E;
+		dbbus_tx_data[3] = 0x02;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+		//set pin high
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x10;
+		dbbus_tx_data[3] = 0x08;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		dbbusDWIICIICNotUseBus();
+		dbbusDWIICNotStopMCU();
+		dbbusDWIICExitSerialDebugMode();
+	
+	
+	
+		drvISP_EntryIspMode();
+		drvISP_ChipErase();
+		_HalTscrHWReset();
+		mdelay( 300 );
+	
+		//2.Program and Verify
+		dbbusDWIICEnterSerialDebugMode();
+		dbbusDWIICStopMCU();
+		dbbusDWIICIICUseBus();
+		dbbusDWIICIICReshape();
+	
+	
+	
+		// Disable the Watchdog
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x3C;
+		dbbus_tx_data[2] = 0x60;
+		dbbus_tx_data[3] = 0x55;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x3C;
+		dbbus_tx_data[2] = 0x61;
+		dbbus_tx_data[3] = 0xAA;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		//Stop MCU
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x0F;
+		dbbus_tx_data[2] = 0xE6;
+		dbbus_tx_data[3] = 0x01;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+		//set FRO to 50M
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x11;
+		dbbus_tx_data[2] = 0xE2;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+		dbbus_rx_data[0] = 0;
+		dbbus_rx_data[1] = 0;
+		HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+		TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+		dbbus_tx_data[3] = dbbus_rx_data[0] & 0xF7;  //Clear Bit 3
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+	
+		//set MCU clock,SPI clock =FRO
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x22;
+		dbbus_tx_data[3] = 0x00;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x23;
+		dbbus_tx_data[3] = 0x00;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		// Enable slave's ISP ECO mode
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x08;
+		dbbus_tx_data[2] = 0x0c;
+		dbbus_tx_data[3] = 0x08;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		//Enable SPI Pad
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x02;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+		HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+		TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+		dbbus_tx_data[3] = ( dbbus_rx_data[0] | 0x20 ); //Set Bit 5
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+		//WP overwrite
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x0E;
+		dbbus_tx_data[3] = 0x02;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+	
+		//set pin high
+		dbbus_tx_data[0] = 0x10;
+		dbbus_tx_data[1] = 0x1E;
+		dbbus_tx_data[2] = 0x10;
+		dbbus_tx_data[3] = 0x08;
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	
+		dbbusDWIICIICNotUseBus();
+		dbbusDWIICNotStopMCU();
+		dbbusDWIICExitSerialDebugMode();
+	
+		///////////////////////////////////////
+		// Start to load firmware
+		///////////////////////////////////////
+		drvISP_EntryIspMode();
+	
+		for( i = 0; i < 94; i++ )  // total  94 KB : 1 byte per R/W
+		{
+			drvISP_Program( i, temp[i] );  // program to slave's flash
+			drvISP_Verify( i, temp[i] );  //verify data
+		}
+		TPD_DEBUG( "update OK\n" );
+		drvISP_ExitIspMode();
+		FwDataCnt = 0;
+		return size;
+	}
+
+
+static u32 Reflect ( u32 ref, char ch ) //unsigned int Reflect(unsigned int ref, char ch)
+{
+    u32 value = 0;
+    u32 i = 0;
+
+    for ( i = 1; i < ( ch + 1 ); i++ )
+    {
+        if ( ref & 1 )
+        {
+            value |= 1 << ( ch - i );
+        }
+        ref >>= 1;
+    }
+    return value;
+}
+
+u32 Get_CRC ( u32 text, u32 prevCRC, u32 *crc32_table )
+{
+    u32  ulCRC = prevCRC;
+	ulCRC = ( ulCRC >> 8 ) ^ crc32_table[ ( ulCRC & 0xFF ) ^ text];
+    return ulCRC ;
+}
+static void Init_CRC32_Table ( u32 *crc32_table )
+{
+    u32 magicnumber = 0x04c11db7;
+    u32 i = 0, j;
+
+    for ( i = 0; i <= 0xFF; i++ )
+    {
+        crc32_table[i] = Reflect ( i, 8 ) << 24;
+        for ( j = 0; j < 8; j++ )
+        {
+            crc32_table[i] = ( crc32_table[i] << 1 ) ^ ( crc32_table[i] & ( 0x80000000L ) ? magicnumber : 0 );
+        }
+        crc32_table[i] = Reflect ( crc32_table[i], 32 );
+    }
+}
+
+typedef enum
+{
+	EMEM_ALL = 0,
+	EMEM_MAIN,
+	EMEM_INFO,
+} EMEM_TYPE_t;
+
+static void drvDB_WriteReg8Bit ( u8 bank, u8 addr, u8 data )
+{
+    u8 tx_data[4] = {0x10, bank, addr, data};
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 4 );
+}
+
+static void drvDB_WriteReg ( u8 bank, u8 addr, u16 data )
+{
+    u8 tx_data[5] = {0x10, bank, addr, data & 0xFF, data >> 8};
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 5 );
+}
+
+static unsigned short drvDB_ReadReg ( u8 bank, u8 addr )
+{
+    u8 tx_data[3] = {0x10, bank, addr};
+    u8 rx_data[2] = {0};
+
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, tx_data, 3 );
+    HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &rx_data[0], 2 );
+    return ( rx_data[1] << 8 | rx_data[0] );
+}
+
+static int drvTP_erase_emem_c32 ( void )
+{
+    /////////////////////////
+    //Erase  all
+    /////////////////////////
+    
+    //enter gpio mode
+    drvDB_WriteReg ( 0x16, 0x1E, 0xBEAF );
+
+    // before gpio mode, set the control pin as the orginal status
+    drvDB_WriteReg ( 0x16, 0x08, 0x0000 );
+    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
+    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
+
+    // ptrim = 1, h'04[2]
+    drvDB_WriteReg8Bit ( 0x16, 0x08, 0x04 );
+    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
+    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
+
+    // ptm = 6, h'04[12:14] = b'110
+    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x60 );
+    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
+
+    // pmasi = 1, h'04[6]
+    drvDB_WriteReg8Bit ( 0x16, 0x08, 0x44 );
+    // pce = 1, h'04[11]
+    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x68 );
+    // perase = 1, h'04[7]
+    drvDB_WriteReg8Bit ( 0x16, 0x08, 0xC4 );
+    // pnvstr = 1, h'04[5]
+    drvDB_WriteReg8Bit ( 0x16, 0x08, 0xE4 );
+    // pwe = 1, h'04[9]
+    drvDB_WriteReg8Bit ( 0x16, 0x09, 0x6A );
+    // trigger gpio load
+    drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x10 );
+
+    return ( 1 );
+}
+
+static ssize_t firmware_update_c32 ( struct device *dev, struct device_attribute *attr,
+                                     const char *buf, size_t size,  EMEM_TYPE_t emem_type )
+{
+    u8  dbbus_tx_data[4];
+    u8  dbbus_rx_data[2] = {0};
+      // Buffer for slave's firmware
+
+    u32 i, j;
+    u32 crc_main, crc_main_tp;
+    u32 crc_info, crc_info_tp;
+    u16 reg_data = 0;
+
+    crc_main = 0xffffffff;
+    crc_info = 0xffffffff;
+
+#if 1
+    /////////////////////////
+    // Erase  all
+    /////////////////////////
+    drvTP_erase_emem_c32();
+    mdelay ( 1000 ); //MCR_CLBK_DEBUG_DELAY ( 1000, MCU_LOOP_DELAY_COUNT_MS );
+
+    //ResetSlave();
+    _HalTscrHWReset();
+    //drvDB_EnterDBBUS();
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+    mdelay ( 300 );
+
+    // Reset Watchdog
+    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
+    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+/*
+    //polling 0x3CE4 is 0x1C70
+    do
+    {
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }
+    while ( reg_data != 0x1C70 );
+
+
+    drvDB_WriteReg ( 0x3C, 0xE4, 0xE38F );  // for all-blocks
+
+    //polling 0x3CE4 is 0x2F43
+    do
+    {
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }
+    while ( reg_data != 0x2F43 );
+
+*/
+    //calculate CRC 32
+    Init_CRC32_Table ( &crc_tab[0] );
+
+    for ( i = 0; i < 33; i++ ) // total  33 KB : 2 byte per R/W
+    {
+        if ( i < 32 )   //emem_main
+        {
+            if ( i == 31 )
+            {
+                temp[i][1014] = 0x5A; //Fmr_Loader[1014]=0x5A;
+                temp[i][1015] = 0xA5; //Fmr_Loader[1015]=0xA5;
+
+                for ( j = 0; j < 1016; j++ )
+                {
+                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
+                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
+                }
+            }
+            else
+            {
+                for ( j = 0; j < 1024; j++ )
+                {
+                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
+                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
+                }
+            }
+        }
+        else  // emem_info
+        {
+            for ( j = 0; j < 1024; j++ )
+            {
+                //crc_info=Get_CRC(Fmr_Loader[j],crc_info,&crc_tab[0]);
+                crc_info = Get_CRC ( temp[i][j], crc_info, &crc_tab[0] );
+            }
+        }
+
+        //drvDWIIC_MasterTransmit( DWIIC_MODE_DWIIC_ID, 1024, Fmr_Loader );
+        //HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i], 1024 );
+        #if 1
+        {
+            u32 n = 0;
+            for(n=0;n<UPDATE_TIMES;n++)
+            {
+                TP_DEBUG_ERR("i=%d,n=%d",i,n);
+                HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i]+n*N_BYTE_PER_TIME, N_BYTE_PER_TIME );
+            }
+        }
+        #else
+        HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i], 1024 );
+        #endif
+        // polling 0x3CE4 is 0xD0BC
+        do
+        {
+            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        }
+        while ( reg_data != 0xD0BC );
+
+        drvDB_WriteReg ( 0x3C, 0xE4, 0x2F43 );
+    }
+
+    //write file done
+    drvDB_WriteReg ( 0x3C, 0xE4, 0x1380 );
+
+    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
+    // polling 0x3CE4 is 0x9432
+    do
+    {
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }
+    while ( reg_data != 0x9432 );
+
+    crc_main = crc_main ^ 0xffffffff;
+    crc_info = crc_info ^ 0xffffffff;
+
+    // CRC Main from TP
+    crc_main_tp = drvDB_ReadReg ( 0x3C, 0x80 );
+    crc_main_tp = ( crc_main_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
+ 
+    //CRC Info from TP
+    crc_info_tp = drvDB_ReadReg ( 0x3C, 0xA0 );
+    crc_info_tp = ( crc_info_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0xA2 );
+
+    //TP_DEBUG ( "crc_main=0x%x, crc_info=0x%x, crc_main_tp=0x%x, crc_info_tp=0x%x\n",
+      //         crc_main, crc_info, crc_main_tp, crc_info_tp );
+
+    //drvDB_ExitDBBUS();
+    if ( ( crc_main_tp != crc_main ) || ( crc_info_tp != crc_info ) )
+    {
+        //TP_DEBUG_ERR ( "update_C32 FAILED\n" );
+		_HalTscrHWReset();
+        FwDataCnt = 0;
+		mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+        return ( 0 );
+    }
+
+    //TP_DEBUG_ERR ( "update_C32 OK\n" );
+	_HalTscrHWReset();
+    FwDataCnt = 0;
+	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+
+    return size;
+#endif
+}
+
+static int drvTP_erase_emem_c33 ( EMEM_TYPE_t emem_type )
+{
+    // stop mcu
+    drvDB_WriteReg ( 0x0F, 0xE6, 0x0001 );
+
+    //disable watch dog
+    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
+    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
+
+    // set PROGRAM password
+    drvDB_WriteReg8Bit ( 0x16, 0x1A, 0xBA );
+    drvDB_WriteReg8Bit ( 0x16, 0x1B, 0xAB );
+
+    //proto.MstarWriteReg(F1.loopDevice, 0x1618, 0x80);
+    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x80 );
+
+    if ( emem_type == EMEM_ALL )
+    {
+        drvDB_WriteReg8Bit ( 0x16, 0x08, 0x10 ); //mark
+    }
+
+    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x40 );
+    mdelay ( 10 );
+
+    drvDB_WriteReg8Bit ( 0x16, 0x18, 0x80 );
+
+    // erase trigger
+    if ( emem_type == EMEM_MAIN )
+    {
+        drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x04 ); //erase main
+    }
+    else
+    {
+        drvDB_WriteReg8Bit ( 0x16, 0x0E, 0x08 ); //erase all block
+    }
+
+    return ( 1 );
+}
+
+static int drvTP_read_emem_dbbus_c33 ( EMEM_TYPE_t emem_type, u16 addr, size_t size, u8 *p, size_t set_pce_high )
+{
+    u32 i;
+
+    // Set the starting address ( must before enabling burst mode and enter riu mode )
+    drvDB_WriteReg ( 0x16, 0x00, addr );
+
+    // Enable the burst mode ( must before enter riu mode )
+    drvDB_WriteReg ( 0x16, 0x0C, drvDB_ReadReg ( 0x16, 0x0C ) | 0x0001 );
+
+    // Set the RIU password
+    drvDB_WriteReg ( 0x16, 0x1A, 0xABBA );
+
+    // Enable the information block if pifren is HIGH
+    if ( emem_type == EMEM_INFO )
+    {
+        // Clear the PCE
+        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0080 );
+        mdelay ( 10 );
+
+        // Set the PIFREN to be HIGH
+        drvDB_WriteReg ( 0x16, 0x08, 0x0010 );
+    }
+
+    // Set the PCE to be HIGH
+    drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
+    mdelay ( 10 );
+
+    // Wait pce becomes 1 ( read data ready )
+    while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
+
+    for ( i = 0; i < size; i += 4 )
+    {
+        // Fire the FASTREAD command
+        drvDB_WriteReg ( 0x16, 0x0E, drvDB_ReadReg ( 0x16, 0x0E ) | 0x0001 );
+
+        // Wait the operation is done
+        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0001 ) != 0x0001 );
+
+        p[i + 0] = drvDB_ReadReg ( 0x16, 0x04 ) & 0xFF;
+        p[i + 1] = ( drvDB_ReadReg ( 0x16, 0x04 ) >> 8 ) & 0xFF;
+        p[i + 2] = drvDB_ReadReg ( 0x16, 0x06 ) & 0xFF;
+        p[i + 3] = ( drvDB_ReadReg ( 0x16, 0x06 ) >> 8 ) & 0xFF;
+    }
+
+    // Disable the burst mode
+    drvDB_WriteReg ( 0x16, 0x0C, drvDB_ReadReg ( 0x16, 0x0C ) & ( ~0x0001 ) );
+
+    // Clear the starting address
+    drvDB_WriteReg ( 0x16, 0x00, 0x0000 );
+
+    //Always return to main block
+    if ( emem_type == EMEM_INFO )
+    {
+        // Clear the PCE before change block
+        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0080 );
+        mdelay ( 10 );
+        // Set the PIFREN to be LOW
+        drvDB_WriteReg ( 0x16, 0x08, drvDB_ReadReg ( 0x16, 0x08 ) & ( ~0x0010 ) );
+
+        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
+        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
+    }
+
+    // Clear the RIU password
+    drvDB_WriteReg ( 0x16, 0x1A, 0x0000 );
+
+    if ( set_pce_high )
+    {
+        // Set the PCE to be HIGH before jumping back to e-flash codes
+        drvDB_WriteReg ( 0x16, 0x18, drvDB_ReadReg ( 0x16, 0x18 ) | 0x0040 );
+        while ( ( drvDB_ReadReg ( 0x16, 0x10 ) & 0x0004 ) != 0x0004 );
+    }
+
+    return ( 1 );
+}
+
+
+static int drvTP_read_info_dwiic_c33 ( void )
+{
+    u8  dwiic_tx_data[5];
+    u8  dwiic_rx_data[4];
+    u16 dwiic_info_addrss,i;
+    u16 reg_data=0;
+    mdelay ( 300 );
+
+    // Stop Watchdog
+    drvDB_WriteReg8Bit ( 0x3C, 0x60, 0x55 );
+    drvDB_WriteReg8Bit ( 0x3C, 0x61, 0xAA );
+
+    drvDB_WriteReg ( 0x3C, 0xE4, 0xA4AB );
+
+	drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
+
+    // TP SW reset
+    drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
+	mdelay ( 1 );
+    dwiic_tx_data[0] = 0x10;
+    dwiic_tx_data[1] = 0x0F;
+    dwiic_tx_data[2] = 0xE6;
+    dwiic_tx_data[3] = 0x00;
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dwiic_tx_data, 4 );	
+    mdelay ( 100 );
+TP_DEBUG_ERR("MSG21332222222222");
+    do{
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }
+    while ( reg_data != 0x5B58 );
+	dwiic_tx_data[0] = 0x72;
+	dwiic_tx_data[1] = 0x80;
+	dwiic_tx_data[2] = 0x00;
+	dwiic_tx_data[3] = 0x04;
+	dwiic_tx_data[4] = 0x00;
+	HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , dwiic_tx_data, 5 );
+	TP_DEBUG_ERR("4444444444444");
+	mdelay ( 50 );
+
+	// recive info data
+	//HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX_TP, &g_dwiic_info_data[0], 1024 );
+	HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX_TP, &g_dwiic_info_data[0], 8 );
+
+
+    // recive info data
+    //HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX_TP, &g_dwiic_info_data[0], 1024 );
+    /*
+    for(i=0;i<128;i++)
+{
+TP_DEBUG_ERR("MSG213333333333333333");
+    dwiic_info_addrss = 0x8000+8*i;
+    dwiic_tx_data[0] = 0x72;
+    dwiic_tx_data[1] = dwiic_info_addrss >>8;
+    dwiic_tx_data[2] = dwiic_info_addrss & 0xFF;
+    dwiic_tx_data[3] = 0x00;
+    dwiic_tx_data[4] = 0x08;
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &dwiic_tx_data[0], 5 );
+    //TP_DEBUG_ERR("MSG21334444444444444");
+    mdelay ( 5 );
+    HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX_TP, &g_dwiic_info_data[i*8], 8 );
+}
+	*/
+    TP_DEBUG_ERR("MSG213355555555555555");
+    return ( 1 );
+}
+
+static int drvTP_info_updata_C33 ( u16 start_index, u8 *data, u16 size )
+{
+    // size != 0, start_index+size !> 1024
+    u16 i;
+    for ( i = 0; i < size; i++ )
+    {
+        g_dwiic_info_data[start_index] = * ( data + i );
+        start_index++;
+    }
+    return ( 1 );
+}
+
+static ssize_t firmware_update_c33 ( struct device *dev, struct device_attribute *attr,
+                                     const char *buf, size_t size, EMEM_TYPE_t emem_type )
+{
+    u8  dbbus_tx_data[4];
+    u8  dbbus_rx_data[2] = {0};
+    u8  life_counter[2];
+    u32 i, j;
+    u32 crc_main, crc_main_tp;
+    u32 crc_info, crc_info_tp;
+    u8 data[5];
+
+    int update_pass = 1;
+    u16 reg_data = 0;
+
+    crc_main = 0xffffffff;
+    crc_info = 0xffffffff;
+    TP_DEBUG_ERR("MSG2133111111111111");
+    drvTP_read_info_dwiic_c33();
+	
+    if (0)//( g_dwiic_info_data[0] == 'M' && g_dwiic_info_data[1] == 'S' && g_dwiic_info_data[2] == 'T' && g_dwiic_info_data[3] == 'A' && g_dwiic_info_data[4] == 'R' && g_dwiic_info_data[5] == 'T' && g_dwiic_info_data[6] == 'P' && g_dwiic_info_data[7] == 'C')
+    {
+        // updata FW Version
+        //drvTP_info_updata_C33 ( 8, &temp[32][8], 5 );
+
+		g_dwiic_info_data[8]=temp[32][8];
+		g_dwiic_info_data[9]=temp[32][9];
+		g_dwiic_info_data[10]=temp[32][10];
+		g_dwiic_info_data[11]=temp[32][11];
+        // updata life counter
+        life_counter[1] = (( ( (g_dwiic_info_data[13] << 8 ) | g_dwiic_info_data[12]) + 1 ) >> 8 ) & 0xFF;
+        life_counter[0] = ( ( (g_dwiic_info_data[13] << 8 ) | g_dwiic_info_data[12]) + 1 ) & 0xFF;
+		g_dwiic_info_data[12]=life_counter[0];
+		g_dwiic_info_data[13]=life_counter[1];
+        //drvTP_info_updata_C33 ( 10, &life_counter[0], 3 );
+        drvDB_WriteReg ( 0x3C, 0xE4, 0x78C5 );
+		drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
+        // TP SW reset
+        drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
+
+        mdelay ( 50 );
+        //TP_DEBUG_ERR("666666666666");
+        //polling 0x3CE4 is 0x2F43
+        do
+        {
+            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+
+        }
+        while ( reg_data != 0x2F43 );
+        //TP_DEBUG_ERR("777777777777");
+        // transmit lk info data
+        HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[0], 1024 );
+        //TP_DEBUG_ERR("88888888888");
+        //polling 0x3CE4 is 0xD0BC
+        do
+        {
+            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        }
+        while ( reg_data != 0xD0BC );
+        //TP_DEBUG_ERR("9999999999999");
+    }
+
+    //erase main
+    TP_DEBUG_ERR("MSG2133aaaaaaaaaaa");
+    drvTP_erase_emem_c33 ( EMEM_MAIN );
+    mdelay ( 1000 );
+
+    //ResetSlave();
+    _HalTscrHWReset();
+#if 0
+    //drvDB_EnterDBBUS();
+    dbbusDWIICEnterSerialDebugMode();
+    mdelay ( 10 );
+    dbbusDWIICEnterSerialDebugMode();
+    mdelay ( 10 );
+    dbbusDWIICEnterSerialDebugMode();
+#endif
+
+#if 0
+    // Enter the Serial Debug Mode
+    data[0] = 0x53;
+    data[1] = 0x45;
+    data[2] = 0x52;
+    data[3] = 0x44;
+    data[4] = 0x42;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, data, 1 );
+
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, &data[1], 1 );
+
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, &data[2], 1 );
+   HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, &data[3], 1 );
+   HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, &data[4], 1 );
+#endif
+//drvDB_EnterDBBUS();
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+    mdelay ( 600 );
+
+    /////////////////////////
+    // Program
+    /////////////////////////
+
+    //polling 0x3CE4 is 0x1C70
+    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+    {
+        do
+        {
+            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        }
+        while ( reg_data != 0x1C70 );
+    }
+
+    switch ( emem_type )
+    {
+        case EMEM_ALL:
+            drvDB_WriteReg ( 0x3C, 0xE4, 0xE38F );  // for all-blocks
+            break;
+        case EMEM_MAIN:
+            drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for main block
+            break;
+        case EMEM_INFO:
+            drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for info block
+
+            drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x01 );
+
+            drvDB_WriteReg8Bit ( 0x3C, 0xE4, 0xC5 ); //
+            drvDB_WriteReg8Bit ( 0x3C, 0xE5, 0x78 ); //
+
+            drvDB_WriteReg8Bit ( 0x1E, 0x04, 0x9F );
+            drvDB_WriteReg8Bit ( 0x1E, 0x05, 0x82 );
+
+            drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x00 );
+            mdelay ( 100 );
+            break;
+    }
+TP_DEBUG_ERR("MSG2133bbbbbbbbbbbbbb");
+    // polling 0x3CE4 is 0x2F43
+    do
+    {
+        reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+    }
+    while ( reg_data != 0x2F43 );
+TP_DEBUG_ERR("MSG2133ccccccccccccc");
+    // calculate CRC 32
+    Init_CRC32_Table ( &crc_tab[0] );
+
+    for ( i = 0; i < 33; i++ ) // total  33 KB : 2 byte per R/W
+    {
+        if ( emem_type == EMEM_INFO )
+			i = 32;
+
+        if ( i < 32 )   //emem_main
+        {
+            if ( i == 31 )
+            {
+                temp[i][1014] = 0x5A; //Fmr_Loader[1014]=0x5A;
+                temp[i][1015] = 0xA5; //Fmr_Loader[1015]=0xA5;
+
+                for ( j = 0; j < 1016; j++ )
+                {
+                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
+                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
+                }
+            }
+            else
+            {
+                for ( j = 0; j < 1024; j++ )
+                {
+                    //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
+                    crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
+                }
+            }
+        }
+        else  //emem_info
+        {
+            for ( j = 0; j < 1024; j++ )
+            {
+                //crc_info=Get_CRC(Fmr_Loader[j],crc_info,&crc_tab[0]);
+                crc_info = Get_CRC ( g_dwiic_info_data[j], crc_info, &crc_tab[0] );
+            }
+            if ( emem_type == EMEM_MAIN ) break;
+        }
+        //drvDWIIC_MasterTransmit( DWIIC_MODE_DWIIC_ID, 1024, Fmr_Loader );
+        TP_DEBUG_ERR("MSG2133dddddddddddddd");
+        #if 1
+        {
+            u32 n = 0;
+            for(n=0;n<UPDATE_TIMES;n++)
+            {
+                TP_DEBUG_ERR("i=%d,n=%d",i,n);
+                HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i]+n*N_BYTE_PER_TIME, N_BYTE_PER_TIME );
+            }
+        }
+        #else
+        HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i], 1024 );
+        #endif
+        TP_DEBUG_ERR("MSG2133eeeeeeeeeeee");
+        // polling 0x3CE4 is 0xD0BC
+        do
+        {
+            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        }
+        while ( reg_data != 0xD0BC );
+        TP_DEBUG_ERR("MSG2133ffffffffffffff");
+        drvDB_WriteReg ( 0x3C, 0xE4, 0x2F43 );
+    }
+        TP_DEBUG_ERR("MSG2133ggggggggg");
+    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+    {
+        // write file done and check crc
+        drvDB_WriteReg ( 0x3C, 0xE4, 0x1380 );
+        TP_DEBUG_ERR("MSG2133hhhhhhhhhhhhhh");
+    }
+    mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
+
+    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+    {
+        // polling 0x3CE4 is 0x9432
+        TP_DEBUG_ERR("MSG2133iiiiiiiiii");
+        do
+        {
+            reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+        }while ( reg_data != 0x9432 );
+        TP_DEBUG_ERR("MSG2133jjjjjjjjjjjjj");
+    }
+
+    crc_main = crc_main ^ 0xffffffff;
+    crc_info = crc_info ^ 0xffffffff;
+
+    if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+    {
+        TP_DEBUG_ERR("MSG2133kkkkkkkkkkk");
+        // CRC Main from TP
+        crc_main_tp = drvDB_ReadReg ( 0x3C, 0x80 );
+        crc_main_tp = ( crc_main_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
+
+        // CRC Info from TP
+        crc_info_tp = drvDB_ReadReg ( 0x3C, 0xA0 );
+        crc_info_tp = ( crc_info_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0xA2 );
+    }
+  //TP_DEBUG ( "crc_main=0x%x, crc_info=0x%x, crc_main_tp=0x%x, crc_info_tp=0x%x\n",
+    //           crc_main, crc_info, crc_main_tp, crc_info_tp );
+
+    //drvDB_ExitDBBUS();
+    TP_DEBUG_ERR("MSG2133lllllllllllll");
+    update_pass = 1;
+	if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+    {
+        if ( crc_main_tp != crc_main )
+            update_pass = 0;
+
+        if ( crc_info_tp != crc_info )
+            update_pass = 0;
+    }
+
+    if ( !update_pass )
+    {
+        TP_DEBUG_ERR ( "MSG2133update_C33 ok111\n" );
+		_HalTscrHWReset();
+        FwDataCnt = 0;
+		(CUST_EINT_TOUCH_PANEL_NUM);
+        return size;
+    }
+
+    TP_DEBUG_ERR ( "MSG2133update_C33 OK\n" );
+	_HalTscrHWReset();
+    FwDataCnt = 0;
+	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+    return size;
+}
+
+
+static ssize_t firmware_update_store ( struct device *dev,
+                                       struct device_attribute *attr, const char *buf, size_t size )
+{
+    u8 i;
+    u8 dbbus_tx_data[4];
+    unsigned char dbbus_rx_data[2] = {0};
+	mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+
+    _HalTscrHWReset();
+
+    // Erase TP Flash first
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+    mdelay ( 300 );
+
+    // Disable the Watchdog
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x3C;
+    dbbus_tx_data[2] = 0x60;
+    dbbus_tx_data[3] = 0x55;
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x3C;
+    dbbus_tx_data[2] = 0x61;
+    dbbus_tx_data[3] = 0xAA;
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+    // Stop MCU
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x0F;
+    dbbus_tx_data[2] = 0xE6;
+    dbbus_tx_data[3] = 0x01;
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+    /////////////////////////
+    // Difference between C2 and C3
+    /////////////////////////
+	// c2:2133 c32:2133a(2) c33:2138
+    //check id
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0xCC;
+    HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+    HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+    TP_DEBUG_ERR ( "MSG2133111dbbus_rx version[0]=0x%x", dbbus_rx_data[0] );
+    if ( dbbus_rx_data[0] == 2 )
+    {
+        // check version
+        dbbus_tx_data[0] = 0x10;
+        dbbus_tx_data[1] = 0x3C;
+        dbbus_tx_data[2] = 0xEA;
+        HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+        HalTscrCReadI2CSeq ( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+        TP_DEBUG_ERR ( "MSG2133dbbus_rx version[0]=0x%x", dbbus_rx_data[0] );
+
+        if ( dbbus_rx_data[0] == 3 ){
+
+            return firmware_update_c33 ( dev, attr, buf, size, EMEM_MAIN );
+
+		}
+        else{
+
+            return firmware_update_c32 ( dev, attr, buf, size, EMEM_ALL );
+        }
+    }
+    else
+    {
+        return firmware_update_c2 ( dev, attr, buf, size );
+    } 
+
+}
+#else
+
+
+
+static ssize_t firmware_update_store( struct device *dev,
+                                      struct device_attribute *attr, const char *buf, size_t size )
+{
+    u8 i;
+    u8 dbbus_tx_data[4];
+    unsigned char dbbus_rx_data[2] = {0};
+
+
+    _HalTscrHWReset();
+    //1.Erase TP Flash first
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+    msleep( 300 );
+
+
+    // Disable the Watchdog
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x3C;
+    dbbus_tx_data[2] = 0x60;
+    dbbus_tx_data[3] = 0x55;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x3C;
+    dbbus_tx_data[2] = 0x61;
+    dbbus_tx_data[3] = 0xAA;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    //Stop MCU
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x0F;
+    dbbus_tx_data[2] = 0xE6;
+    dbbus_tx_data[3] = 0x01;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //set FRO to 50M
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x11;
+    dbbus_tx_data[2] = 0xE2;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+    dbbus_rx_data[0] = 0;
+    dbbus_rx_data[1] = 0;
+    HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+    TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+    dbbus_tx_data[3] = dbbus_rx_data[0] & 0xF7;  //Clear Bit 3
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+
+    //set MCU clock,SPI clock =FRO
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x22;
+    dbbus_tx_data[3] = 0x00;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x23;
+    dbbus_tx_data[3] = 0x00;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    // Enable slave's ISP ECO mode
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x08;
+    dbbus_tx_data[2] = 0x0c;
+    dbbus_tx_data[3] = 0x08;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    //Enable SPI Pad
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x02;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+    HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+    TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+    dbbus_tx_data[3] = ( dbbus_rx_data[0] | 0x20 ); //Set Bit 5
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //WP overwrite
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x0E;
+    dbbus_tx_data[3] = 0x02;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //set pin high
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x10;
+    dbbus_tx_data[3] = 0x08;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    dbbusDWIICIICNotUseBus();
+    dbbusDWIICNotStopMCU();
+    dbbusDWIICExitSerialDebugMode();
+
+
+
+    drvISP_EntryIspMode();
+    drvISP_ChipErase();
+    _HalTscrHWReset();
+    mdelay( 300 );
+
+    //2.Program and Verify
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+
+
+
+    // Disable the Watchdog
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x3C;
+    dbbus_tx_data[2] = 0x60;
+    dbbus_tx_data[3] = 0x55;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x3C;
+    dbbus_tx_data[2] = 0x61;
+    dbbus_tx_data[3] = 0xAA;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    //Stop MCU
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x0F;
+    dbbus_tx_data[2] = 0xE6;
+    dbbus_tx_data[3] = 0x01;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //set FRO to 50M
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x11;
+    dbbus_tx_data[2] = 0xE2;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+    dbbus_rx_data[0] = 0;
+    dbbus_rx_data[1] = 0;
+    HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+    TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+    dbbus_tx_data[3] = dbbus_rx_data[0] & 0xF7;  //Clear Bit 3
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+
+    //set MCU clock,SPI clock =FRO
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x22;
+    dbbus_tx_data[3] = 0x00;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x23;
+    dbbus_tx_data[3] = 0x00;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    // Enable slave's ISP ECO mode
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x08;
+    dbbus_tx_data[2] = 0x0c;
+    dbbus_tx_data[3] = 0x08;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    //Enable SPI Pad
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x02;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+    HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+    TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+    dbbus_tx_data[3] = ( dbbus_rx_data[0] | 0x20 ); //Set Bit 5
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //WP overwrite
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x0E;
+    dbbus_tx_data[3] = 0x02;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //set pin high
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x10;
+    dbbus_tx_data[3] = 0x08;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    dbbusDWIICIICNotUseBus();
+    dbbusDWIICNotStopMCU();
+    dbbusDWIICExitSerialDebugMode();
+
+    ///////////////////////////////////////
+    // Start to load firmware
+    ///////////////////////////////////////
+    drvISP_EntryIspMode();
+
+    for( i = 0; i < 94; i++ )  // total  94 KB : 1 byte per R/W
+    {
+        drvISP_Program( i, temp[i] );  // program to slave's flash
+        drvISP_Verify( i, temp[i] );  //verify data
+    }
+    TPD_DEBUG( "update OK\n" );
+    drvISP_ExitIspMode();
+    FwDataCnt = 0;
+    return size;
+}
+#endif
+static DEVICE_ATTR( update, 0777, firmware_update_show, firmware_update_store );
+
+/*test=================*/
+static ssize_t firmware_clear_show( struct device *dev,
+                                    struct device_attribute *attr, char *buf )
+{
+    u16 k = 0, i = 0, j = 0;
+    u8 bWriteData[5] =
+    {
+        0x10, 0x03, 0, 0, 0
+    };
+    u8 RX_data[256];
+    u8 bWriteData1 = 0x12;
+    u32 addr = 0;
+    u32 timeOutCount = 0;
+    for( k = 0; k < 94; i++ )  // total  94 KB : 1 byte per R/W
+    {
+        addr = k * 1024;
+        for( j = 0; j < 8; j++ )  //128*8 cycle
+        {
+            bWriteData[2] = ( u8 )( ( addr + j * 128 ) >> 16 );
+            bWriteData[3] = ( u8 )( ( addr + j * 128 ) >> 8 );
+            bWriteData[4] = ( u8 )( addr + j * 128 );
+            udelay( 100 );         // delay about 100us*****
+
+            timeOutCount = 0;
+            while( ( drvISP_ReadStatus() & 0x01 ) == 0x01 )
+            {
+                timeOutCount++;
+                if( timeOutCount >= 100000 ) break;  /* around 1 sec timeout */
+            }
+
+
+            HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, bWriteData, 5 );  //write read flash addr
+            udelay( 100 );         // delay about 100us*****
+            drvISP_Read( 128, RX_data );
+            HalTscrCDevWriteI2CSeq( FW_UPDATE_ADDR_MSG21XX, &bWriteData1, 1 );  //cmd end
+            for( i = 0; i < 128; i++ )  //log out if verify error
+            {
+                if( RX_data[i] != 0xFF )
+                {
+                    TPD_DEBUG( "k=%d,j=%d,i=%d===============erase not clean================", k, j, i );
+                }
+            }
+        }
+    }
+    TPD_DEBUG( "read finish\n" );
+    return sprintf( buf, "%s\n", fw_version );
+}
+
+static ssize_t firmware_clear_store( struct device *dev,
+                                     struct device_attribute *attr, const char *buf, size_t size )
+{
+
+    u8 dbbus_tx_data[4];
+    unsigned char dbbus_rx_data[2] = {0};
+
+    _HalTscrHWReset();
+    dbbusDWIICEnterSerialDebugMode();
+    dbbusDWIICStopMCU();
+    dbbusDWIICIICUseBus();
+    dbbusDWIICIICReshape();
+
+
+
+    // Disable the Watchdog
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x3C;
+    dbbus_tx_data[2] = 0x60;
+    dbbus_tx_data[3] = 0x55;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x3C;
+    dbbus_tx_data[2] = 0x61;
+    dbbus_tx_data[3] = 0xAA;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    //Stop MCU
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x0F;
+    dbbus_tx_data[2] = 0xE6;
+    dbbus_tx_data[3] = 0x01;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //set FRO to 50M
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x11;
+    dbbus_tx_data[2] = 0xE2;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+    dbbus_rx_data[0] = 0;
+    dbbus_rx_data[1] = 0;
+    HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+    TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+    dbbus_tx_data[3] = dbbus_rx_data[0] & 0xF7;  //Clear Bit 3
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+
+    //set MCU clock,SPI clock =FRO
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x22;
+    dbbus_tx_data[3] = 0x00;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x23;
+    dbbus_tx_data[3] = 0x00;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    // Enable slave's ISP ECO mode
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x08;
+    dbbus_tx_data[2] = 0x0c;
+    dbbus_tx_data[3] = 0x08;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+    //Enable SPI Pad
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x02;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 3 );
+    HalTscrCReadI2CSeq( FW_ADDR_MSG21XX, &dbbus_rx_data[0], 2 );
+    TPD_DEBUG( "dbbus_rx_data[0]=0x%x", dbbus_rx_data[0] );
+    dbbus_tx_data[3] = ( dbbus_rx_data[0] | 0x20 ); //Set Bit 5
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //WP overwrite
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x0E;
+    dbbus_tx_data[3] = 0x02;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+
+    //set pin high
+    dbbus_tx_data[0] = 0x10;
+    dbbus_tx_data[1] = 0x1E;
+    dbbus_tx_data[2] = 0x10;
+    dbbus_tx_data[3] = 0x08;
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+
+    dbbusDWIICIICNotUseBus();
+    dbbusDWIICNotStopMCU();
+    dbbusDWIICExitSerialDebugMode();
+
+
+    ///////////////////////////////////////
+    // Start to load firmware
+    ///////////////////////////////////////
+    drvISP_EntryIspMode();
+    TPD_DEBUG( "chip erase+\n" );
+    drvISP_ChipErase();
+    TPD_DEBUG( "chip erase-\n" );
+    drvISP_ExitIspMode();
+    return size;
+}
+
+static DEVICE_ATTR( clear, 0777, firmware_clear_show, firmware_clear_store );
+
+/*test=================*/
+/*Add by Tracy.Lin for update touch panel firmware and get fw version*/
+
+static ssize_t firmware_version_show( struct device *dev,
+                                      struct device_attribute *attr, char *buf )
+{
+    TPD_DEBUG( "*** firmware_version_show fw_version = %s***\n", fw_version );
+    return sprintf( buf, "%s\n", fw_version );
+}
+kal_bool Check_msg2133_I2C_state(void)
+{
+    int ret;
+unsigned char dbbus_rx_data[4] ;
+
+    i2c_client->addr = FW_ADDR_MSG21XX_TP;
+    ret = i2c_master_recv(i2c_client, &dbbus_rx_data[0], 4);
+    i2c_client->addr = FW_ADDR_MSG21XX_TP;
+    if(ret <= 0)
+
+    	{
+		return 0;
+	}
+	else
+	{
+		return 1;
+	}
+}
+static ssize_t firmware_version_store( struct device *dev,
+                                       struct device_attribute *attr, const char *buf, size_t size )
+{
+    unsigned char dbbus_tx_data[3];
+    unsigned char dbbus_rx_data[4] ;
+    unsigned short major = 0, minor = 0;
+
+    fw_version = kzalloc( sizeof( char ), GFP_KERNEL );
+    //SM-BUS GET FW VERSION
+    dbbus_tx_data[0] = 0x53;
+    dbbus_tx_data[1] = 0x00;
+    dbbus_tx_data[2] = 0x2a;// 2A
+    HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX_TP, &dbbus_tx_data[0], 3 );
+    HalTscrCReadI2CSeq( FW_ADDR_MSG21XX_TP, &dbbus_rx_data[0], 4 );
+
+    major = ( dbbus_rx_data[1] << 8 ) + dbbus_rx_data[0];
+    minor = ( dbbus_rx_data[3] << 8 ) + dbbus_rx_data[2];
+
+    TPD_DEBUG( "***major = %d ***\n", major );
+    TPD_DEBUG( "***minor = %d ***\n", minor );
+    sprintf( fw_version, "%03d%03d", major, minor );
+    TPD_DEBUG( "***fw_version = %s ***\n", fw_version );
+
+
+    return size;
+}
+static DEVICE_ATTR( version, 0777, firmware_version_show, firmware_version_store );
+
+static ssize_t firmware_data_show( struct device *dev,
+                                   struct device_attribute *attr, char *buf )
+{
+    return FwDataCnt;
+}
+
+static ssize_t firmware_data_store( struct device *dev,
+                                    struct device_attribute *attr, const char *buf, size_t size )
+{
+
+    int i;
+    TPD_DEBUG( "***FwDataCnt = %d ***\n", FwDataCnt );
+    memcpy( temp[FwDataCnt], buf, 1024 );
+    FwDataCnt++;
+    return size;
+}
+static DEVICE_ATTR( data, 0777, firmware_data_show, firmware_data_store );
+#endif
+
+//end for update firmware
+
+#ifdef MSG_GESTURE_FUNCTION
+/////enable 0:no open ; 1:open
+/////if return 0,parameter 'enable' is wrong!
+
+////the first bit
+#define CTP_UPDATE_GESTURE_AUTHORITY_SYS 0777
+
+static int msg_SetGestureDoubleClickDirectValue( int enable )
+{
+	if(enable != 0 && enable != 1)
+		return 0;
+	if(enable)
+		set_gesture_double_click_mode = MSG_GESTURE_FUNCTION_DOUBLECLICK_FLAG;
+	else
+		set_gesture_double_click_mode = 0;
+	
+	return 1;
+}
+////the second bit
+static int msg_SetGestureUpDirectValue( int enable )
+{
+	if(enable != 0 && enable != 1)
+		return 0;
+	if(enable)
+		set_gesture_up_direct_mode = MSG_GESTURE_FUNCTION_UPDIRECT_FLAG;
+	else
+		set_gesture_up_direct_mode = 0;
+	
+	return 1;
+}
+////the third bit
+static int msg_SetGestureDownDirectValue( int enable )
+{
+	if(enable != 0 && enable != 1)
+		return 0;
+	if(enable)
+		set_gesture_down_direct_mode = MSG_GESTURE_FUNCTION_DOWNDIRECT_FLAG;
+	else
+		set_gesture_down_direct_mode = 0;
+	
+	return 1;
+}
+////the fourth bit
+static int msg_SetGestureLeftDirectValue( int enable )
+{
+	if(enable != 0 && enable != 1)
+		return 0;
+	if(enable)
+		set_gesture_left_direct_mode = MSG_GESTURE_FUNCTION_LEFTDIRECT_FLAG;
+	else
+		set_gesture_left_direct_mode = 0;
+	
+	return 1;
+}
+////the fivth bit
+static int msg_SetGestureRightDirectValue( int enable )
+{
+	if(enable != 0 && enable != 1)
+		return 0;
+	if(enable)
+		set_gesture_right_direct_mode = MSG_GESTURE_FUNCTION_RIGHTDIRECT_FLAG;
+	else
+		set_gesture_right_direct_mode = 0;
+	
+	return 1;
+}
+
+static void msg_GetGestureModeValue( void )
+{
+	set_gesture_mode = (set_gesture_right_direct_mode)|(set_gesture_left_direct_mode)|(set_gesture_down_direct_mode)|(set_gesture_up_direct_mode)|(set_gesture_double_click_mode);
+	//TP_DEBUG("***msg_GetGestureModeValue set_gesture_mode = %x ***\n", set_gesture_mode);
+}
+
+///return flage
+int msg_GetDoubleClickModeFlage( void )
+{
+	return tpd_gesture_double_click_mode;
+}
+int msg_GetUpDirectModeFlage( void )
+{
+	return tpd_gesture_up_direct_mode;
+}
+int msg_GetDownDirectModeFlage( void )
+{
+	return tpd_gesture_down_direct_mode;
+}
+int msg_GetLeftDirectModeFlage( void )
+{
+	return tpd_gesture_left_direct_mode;
+}
+int msg_GetRightDirectModeFlage( void )
+{
+	return tpd_gesture_right_direct_mode;
+}
+
+
+/*
+	the result 1: open corection
+			 0: error
+*/
+int msg_OpenGestureFunction( int g_Mode )
+{
+	unsigned char dbbus_tx_data[3];
+	unsigned char dbbus_rx_data[2] = {0};
+
+#ifdef __MSG_DMA_MODE__
+	msg_dma_alloct();
+#endif
+
+	/**********open command*********/
+	dbbus_tx_data[0] = 0x58;
+	
+	dbbus_tx_data[1] = 0xFF;//00
+	/*
+	0000 0001 DoubleClick
+	0000 0010 Up Direction
+	0000 0100 Down Direction
+	0000 1000 Left Direction
+	0001 0000 Right Direction
+	0001 1111 All Of Five Funciton
+	*/
+	dbbus_tx_data[2] = (0xFF&g_Mode);
+	
+	//TP_DEBUG("***msg_OpenGestureFunction MSG_Gesture_Function_type = %x ***\n", dbbus_tx_data[2]);
+	/*if(
+		(dbbus_tx_data[2] >= 0x01)&&
+		(dbbus_tx_data[2] <= 0x1F)
+		)*/
+	{
+		HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX_TP, &dbbus_tx_data[0], 3);//
+		//TP_DEBUG("***msg_OpenGestureFunction write success***\n");
+		tpd_gesture_flag = 1;
+	}
+	
+	/**********open command*********/
+	msleep(20);
+	/**********check command*********/
+  
+	/**********check command*********/
+#ifdef __MSG_DMA_MODE__
+	msg_dma_release();
+#endif
+	return 1;
+}	
+/*
+	the result 1: close corection
+			 0: error
+*/
+int msg_CloseGestureFunction( void )
+{
+	unsigned char dbbus_tx_data[3];
+	unsigned char dbbus_rx_data[2] = {0};
+#ifdef __MSG_DMA_MODE__
+	msg_dma_alloct();
+#endif
+
+	tpd_gesture_flag = 0;
+
+	/*******close command********/
+	dbbus_tx_data[0] = 0x59;
+	
+	dbbus_tx_data[1] = 0x00;
+	//close command is 0x00
+	dbbus_tx_data[2] = 0x00;
+	HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX_TP, &dbbus_tx_data[0], 3);
+	/*******close command********/
+	msleep(20);
+
+	/*******check command**************/
+    dbbus_tx_data[0] = 0x53;
+	
+    dbbus_tx_data[1] = 0x00;
+	///just for Mstar Modefy     u16Reserved10
+    dbbus_tx_data[2] = 0x5e;
+	
+    HalTscrCDevWriteI2CSeq(FW_ADDR_MSG21XX_TP, &dbbus_tx_data[0], 3);
+    HalTscrCReadI2CSeq(FW_ADDR_MSG21XX_TP, &dbbus_rx_data[0], 2);
+
+	if(((dbbus_rx_data[1]<<8)+dbbus_rx_data[0]) != 0)
+	{
+		//TP_DEBUG("***msg_CloseGestureFunction fail:The Close mode is = %x ***\n", ((dbbus_rx_data[1]<<8)+dbbus_rx_data[0]));
+		return 0;
+	}
+	else
+	{	
+		//TP_DEBUG("***msg_CloseGestureFunction success!***\n");
+		return 1;
+	}
+	/*******check command ***************/
+	#ifdef __MSG_DMA_MODE__
+	msg_dma_release();
+	#endif
+
+}
+
+#if 0
+////////////////device node for APP to turn on/off these functions//////////////
+static ssize_t msg_Gesture_Function_Show(struct device *dev,
+                                     struct device_attribute *attr, char *buf)
+{
+	msg_GetGestureModeValue( );
+    return sprintf(buf, "%d\n", set_gesture_mode);
+}
+
+static ssize_t msg_Gesture_Function_Store(struct device *dev,
+                                   struct device_attribute *attr, const char *buf, size_t size)
+{
+	int g_ON_OFF = 0;
+	
+    if(NULL!=buf)
+    {
+        sscanf(buf,"%d",&g_ON_OFF);
+    }
+	
+    if( g_ON_OFF&MSG_GESTURE_FUNCTION_DOUBLECLICK_FLAG == MSG_GESTURE_FUNCTION_DOUBLECLICK_FLAG ) ///turn on 
+    {
+        msg_SetGestureDoubleClickDirectValue(1);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureDoubleClickDirectValue mode =%d",set_gesture_double_click_mode);
+    }
+    else//turn off
+    {
+        msg_SetGestureDoubleClickDirectValue(0);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureDoubleClickDirectValue mode =%d",set_gesture_double_click_mode);
+    }
+	
+    if( g_ON_OFF&MSG_GESTURE_FUNCTION_UPDIRECT_FLAG  == MSG_GESTURE_FUNCTION_UPDIRECT_FLAG ) ///turn on 
+    {
+        msg_SetGestureUpDirectValue(1);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureUpDirectValue mode =%d",set_gesture_up_direct_mode);
+    }
+    else//turn off
+    {
+        msg_SetGestureUpDirectValue(0);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureUpDirectValue mode =%d",set_gesture_up_direct_mode);
+    }
+	
+    if( g_ON_OFF&MSG_GESTURE_FUNCTION_DOWNDIRECT_FLAG == MSG_GESTURE_FUNCTION_DOWNDIRECT_FLAG ) ///turn on 
+    {
+        msg_SetGestureDownDirectValue(1);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureDownDirectValue mode =%d",set_gesture_down_direct_mode);
+    }
+    else//turn off
+    {
+        msg_SetGestureDownDirectValue(0);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureDownDirectValue mode =%d",set_gesture_down_direct_mode);
+    }
+
+    if( g_ON_OFF&MSG_GESTURE_FUNCTION_LEFTDIRECT_FLAG == MSG_GESTURE_FUNCTION_LEFTDIRECT_FLAG ) ///turn on 
+    {
+        msg_SetGestureLeftDirectValue(1);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureLeftDirectValue mode =%d",set_gesture_left_direct_mode);
+    }
+    else//turn off
+    {
+        msg_SetGestureLeftDirectValue(0);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureLeftDirectValue mode =%d",set_gesture_left_direct_mode);
+    }
+
+    if( g_ON_OFF&MSG_GESTURE_FUNCTION_RIGHTDIRECT_FLAG == MSG_GESTURE_FUNCTION_RIGHTDIRECT_FLAG ) ///turn on 
+    {
+        msg_SetGestureRightDirectValue(1);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureRightDirectValue mode =%d",set_gesture_right_direct_mode);
+    }
+    else//turn off
+    {
+        msg_SetGestureRightDirectValue(0);
+        TPD_DEBUG("msg_Gesture_Function_Store msg_SetGestureRightDirectValue mode =%d",set_gesture_right_direct_mode);
+    }
+	return size;
+	
+}
+
+static DEVICE_ATTR(msgGestureFunction, CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_Gesture_Function_Show, msg_Gesture_Function_Store);
+#endif
+static ssize_t msg_Gesture_Function_DoubleClick_Show(struct device *dev,
+                                     struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", set_gesture_double_click_mode);
+}
+static ssize_t msg_Gesture_Function_DoubleClick_Store(struct device *dev,
+                                   struct device_attribute *attr, const char *buf, size_t size)
+{
+	int g_ON_OFF = 0;
+    if(NULL!=buf)
+    {
+        sscanf(buf,"%d",&g_ON_OFF);
+    }
+    if( g_ON_OFF == 1 ) ///turn on 
+    {
+        msg_SetGestureDoubleClickDirectValue(1);
+        TPD_DEBUG("msg_Gesture_Function_DoubleClick_Store set_gesture_double_click_mode =%d",set_gesture_double_click_mode);
+    }
+    else if( g_ON_OFF == 0 ) //turn off
+    {
+        msg_SetGestureDoubleClickDirectValue(0);
+        TPD_DEBUG("msg_Gesture_Function_DoubleClick_Store set_gesture_double_click_mode =%d",set_gesture_double_click_mode);
+    }
+    else
+    {
+        TPD_DEBUG("msg_Gesture_Function_DoubleClick_Store Wrong Command!!!");
+    }
+	return size;
+}
+static DEVICE_ATTR(doubleclick, CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_Gesture_Function_DoubleClick_Show, msg_Gesture_Function_DoubleClick_Store);
+/////////////
+static ssize_t msg_Gesture_Function_UpDirect_Show(struct device *dev,
+                                     struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", set_gesture_up_direct_mode);
+}
+
+static ssize_t msg_Gesture_Function_UpDirect_Store(struct device *dev,
+                                   struct device_attribute *attr, const char *buf, size_t size)
+{
+	int g_ON_OFF = 0;
+	
+    if(NULL!=buf)
+    {
+        sscanf(buf,"%d",&g_ON_OFF);
+    }
+    if( g_ON_OFF == 1 ) ///turn on 
+    {
+        msg_SetGestureUpDirectValue(1);
+        TPD_DEBUG("msg_SetGestureUpDirectValue turn on mode =%d",set_gesture_up_direct_mode);
+    }
+    else if( g_ON_OFF == 0 ) //turn off
+    {
+        msg_SetGestureUpDirectValue(0);
+        TPD_DEBUG("msg_SetGestureUpDirectValue turn off mode =%d",set_gesture_up_direct_mode);
+    }
+    else
+    {
+        TPD_DEBUG("msg_SetGestureUpDirectValue Wrong Command!!!");
+    }
+	return size;
+	
+}
+
+static DEVICE_ATTR(updirect, CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_Gesture_Function_UpDirect_Show, msg_Gesture_Function_UpDirect_Store);
+/////////////
+static ssize_t msg_Gesture_Function_DownDirect_Show(struct device *dev,
+                                     struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", set_gesture_down_direct_mode);
+}
+
+static ssize_t msg_Gesture_Function_DownDirect_Store(struct device *dev,
+                                   struct device_attribute *attr, const char *buf, size_t size)
+{
+	int g_ON_OFF = 0;
+	
+    if(NULL!=buf)
+    {
+        sscanf(buf,"%d",&g_ON_OFF);
+    }
+    if( g_ON_OFF == 1 ) ///turn on 
+    {
+        msg_SetGestureDownDirectValue(1);
+        TPD_DEBUG("msg_Gesture_Function_DownDirect_Store turn on mode =%d",set_gesture_down_direct_mode);
+    }
+    else if( g_ON_OFF == 0 ) //turn off
+    {
+        msg_SetGestureDownDirectValue(0);
+        TPD_DEBUG("msg_Gesture_Function_DownDirect_Store turn off mode =%d",set_gesture_down_direct_mode);
+    }
+    else
+    {
+        TPD_DEBUG("msg_Gesture_Function_DownDirect_Store Wrong Command!!!");
+    }
+	return size;
+	
+}
+
+static DEVICE_ATTR(downdirect, CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_Gesture_Function_DownDirect_Show, msg_Gesture_Function_DownDirect_Store);
+/////////////
+static ssize_t msg_Gesture_Function_LeftDirect_Show(struct device *dev,
+                                     struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", set_gesture_left_direct_mode);
+}
+
+static ssize_t msg_Gesture_Function_LeftDirect_Store(struct device *dev,
+                                   struct device_attribute *attr, const char *buf, size_t size)
+{
+	int g_ON_OFF = 0;
+	
+    if(NULL!=buf)
+    {
+        sscanf(buf,"%d",&g_ON_OFF);
+    }
+    if( g_ON_OFF == 1 ) ///turn on 
+    {
+        msg_SetGestureLeftDirectValue(1);
+        TPD_DEBUG("msg_SetGestureLeftDirectValue turn on mode =%d",set_gesture_left_direct_mode);
+    }
+    else if( g_ON_OFF == 0 ) //turn off
+    {
+        msg_SetGestureLeftDirectValue(0);
+        TPD_DEBUG("msg_SetGestureLeftDirectValue turn off mode =%d",set_gesture_left_direct_mode);
+    }
+    else
+    {
+        TPD_DEBUG("msg_SetGestureLeftDirectValue Wrong Command!!!");
+    }
+	return size;
+	
+}
+
+static DEVICE_ATTR(leftdirect, CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_Gesture_Function_LeftDirect_Show, msg_Gesture_Function_LeftDirect_Store);
+/////////////
+static ssize_t msg_Gesture_Function_RightDirect_Show(struct device *dev,
+                                     struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", set_gesture_right_direct_mode);
+}
+
+static ssize_t msg_Gesture_Function_RightDirect_Store(struct device *dev,
+                                   struct device_attribute *attr, const char *buf, size_t size)
+{
+	int g_ON_OFF = 0;
+	
+    if(NULL!=buf)
+    {
+        sscanf(buf,"%d",&g_ON_OFF);
+    }
+    if( g_ON_OFF == 1 ) ///turn on 
+    {
+        msg_SetGestureRightDirectValue(1);
+        TPD_DEBUG("msg_SetGestureRightDirectValue turn on mode =%d",set_gesture_right_direct_mode);
+    }
+    else if( g_ON_OFF == 0 ) //turn off
+    {
+        msg_SetGestureRightDirectValue(0);
+        TPD_DEBUG("msg_SetGestureRightDirectValue turn off mode =%d",set_gesture_right_direct_mode);
+    }
+    else
+    {
+        TPD_DEBUG("msg_SetGestureRightDirectValue Wrong Command!!!");
+    }
+	return size;
+	
+}
+
+static DEVICE_ATTR(rightdirect, CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_Gesture_Function_RightDirect_Show, msg_Gesture_Function_RightDirect_Store);
+#ifdef MSG_GESTURE_FUNCTION_NODE_PROC
+static int proc_Gesture_Function_DoubleClick_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int cnt= 0;
+    
+    cnt=msg_Gesture_Function_DoubleClick_Show(NULL,NULL, page);
+    
+    *eof = 1;
+    return cnt;
+}
+
+static int proc_Gesture_Function_DoubleClick_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{    
+    msg_Gesture_Function_DoubleClick_Store(NULL, NULL, buffer, 0);
+    return count;
+}
+
+static int proc_Gesture_Function_UpDirect_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int cnt= 0;
+    
+    cnt=msg_Gesture_Function_UpDirect_Show(NULL,NULL, page);
+    
+    *eof = 1;
+    return cnt;
+}
+
+static int proc_Gesture_Function_UpDirect_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{    
+    msg_Gesture_Function_UpDirect_Store(NULL, NULL, buffer, 0);
+    return count;
+}
+
+static int proc_Gesture_Function_DownDirect_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int cnt= 0;
+    
+    cnt=msg_Gesture_Function_DownDirect_Show(NULL,NULL, page);
+    
+    *eof = 1;
+    return cnt;
+}
+
+static int proc_Gesture_Function_DownDirect_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{    
+    msg_Gesture_Function_DownDirect_Store(NULL, NULL, buffer, 0);
+    return count;
+}
+static int proc_Gesture_Function_LeftDirect_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int cnt= 0;
+    
+    cnt=msg_Gesture_Function_LeftDirect_Show(NULL,NULL, page);
+    
+    *eof = 1;
+    return cnt;
+}
+
+static int proc_Gesture_Function_LeftDirect_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{    
+    msg_Gesture_Function_LeftDirect_Store(NULL, NULL, buffer, 0);
+    return count;
+}
+static int proc_Gesture_Function_RightDirect_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+    int cnt= 0;
+    
+    cnt=msg_Gesture_Function_RightDirect_Show(NULL,NULL, page);
+    
+    *eof = 1;
+    return cnt;
+}
+
+static int proc_Gesture_Function_RightDirect_write(struct file *file, const char *buffer, unsigned long count, void *data)
+{    
+    msg_Gesture_Function_RightDirect_Store(NULL, NULL, buffer, 0);
+    return count;
+}
+#endif
+#ifdef PROC_FIRMWARE_UPDATE
+ static int proc_version_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+ {
+	 int cnt= 0;
+	 
+	 cnt=firmware_version_show(NULL,NULL, page);
+	 
+	 *eof = 1;
+	 return cnt;
+ }
+ 
+ static int proc_version_write(struct file *file, const char *buffer, unsigned long count, void *data)
+ {	  
+	 firmware_version_store(NULL, NULL, NULL, 0);
+	 return count;
+ }
+ 
+ static int proc_update_write(struct file *file, const char *buffer, unsigned long count, void *data)
+ {
+	 count = (unsigned long)firmware_update_store(NULL, NULL, NULL, (size_t)count);  
+	 return count;
+ }
+ 
+ static int proc_data_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+ {
+	 int cnt= 0;
+	 
+	 cnt=firmware_data_show(NULL, NULL, page);
+	 
+	 *eof = 1;	  
+	 return cnt;
+ }
+ 
+ static int proc_data_write(struct file *file, const char *buffer, unsigned long count, void *data)
+ {
+	 firmware_data_store(NULL, NULL, buffer, 0);
+	 return count;
+ }
+#endif
+
+#if defined( PROC_FIRMWARE_UPDATE )||defined( MSG_GESTURE_FUNCTION_NODE_PROC )
+ static void msg_Update_Gesture_Fucntion_Proc_File(void)
+ {	
+	 struct proc_dir_entry *msg_class_proc = NULL;
+	 struct proc_dir_entry *msg_msg20xx_proc = NULL;
+	 struct proc_dir_entry *msg_device_proc = NULL;
+	 //////gesture function
+	 #ifdef MSG_GESTURE_FUNCTION_NODE_PROC
+	 struct proc_dir_entry *msg_gesture_function_doubleclick_proc = NULL; 
+	 struct proc_dir_entry *msg_gesture_funciton_updirect_proc = NULL;
+	 struct proc_dir_entry *msg_gesture_funciton_downdirect_proc = NULL;
+	 struct proc_dir_entry *msg_gesture_funciton_leftdirect_proc = NULL;
+	 struct proc_dir_entry *msg_gesture_funciton_rightdirect_proc = NULL;
+	 #endif
+	 ///////update
+	 #ifdef PROC_FIRMWARE_UPDATE
+	 struct proc_dir_entry *msg_version_proc = NULL;
+	 struct proc_dir_entry *msg_update_proc = NULL;
+	 struct proc_dir_entry *msg_data_proc = NULL;
+	 #endif
+	 msg_class_proc = proc_mkdir("class", NULL);
+	 msg_msg20xx_proc = proc_mkdir("ms-touchscreen-msg20xx",msg_class_proc);
+	 msg_device_proc = proc_mkdir("device",msg_msg20xx_proc);
+	 
+#ifdef MSG_GESTURE_FUNCTION_NODE_PROC
+	 msg_gesture_function_doubleclick_proc = create_proc_entry("doubleclick", CTP_GESTURE_FUNCTION_AUTHORITY_PROC, msg_device_proc);
+	 if (msg_gesture_function_doubleclick_proc == NULL) 
+	 {
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_function_doubleclick_proc failed\n");
+	 } 
+	 else 
+	 {
+		 msg_gesture_function_doubleclick_proc->read_proc = proc_Gesture_Function_DoubleClick_read;
+		 msg_gesture_function_doubleclick_proc->write_proc = proc_Gesture_Function_DoubleClick_write;
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_function_doubleclick_proc success\n");
+	 }
+
+	 msg_gesture_funciton_updirect_proc = create_proc_entry("updirect", CTP_GESTURE_FUNCTION_AUTHORITY_PROC, msg_device_proc);
+	 if (msg_gesture_funciton_updirect_proc == NULL) 
+	 {
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_funciton_updirect_proc failed\n");
+	 } 
+	 else 
+	 {
+		 msg_gesture_funciton_updirect_proc->read_proc = proc_Gesture_Function_UpDirect_read;
+		 msg_gesture_funciton_updirect_proc->write_proc = proc_Gesture_Function_UpDirect_write;
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_funciton_updirect_proc success\n");
+	 }
+	 msg_gesture_funciton_downdirect_proc = create_proc_entry("downdirect", CTP_GESTURE_FUNCTION_AUTHORITY_PROC, msg_device_proc);
+	 if (msg_gesture_funciton_downdirect_proc == NULL) 
+	 {
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_funciton_downdirect_proc failed\n");
+	 } 
+	 else 
+	 {
+		 msg_gesture_funciton_downdirect_proc->read_proc = proc_Gesture_Function_DownDirect_read;
+		 msg_gesture_funciton_downdirect_proc->write_proc = proc_Gesture_Function_DownDirect_write;
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_funciton_downdirect_proc success\n");
+	 }	
+	 
+	 msg_gesture_funciton_leftdirect_proc = create_proc_entry("leftdirect", CTP_GESTURE_FUNCTION_AUTHORITY_PROC, msg_device_proc);
+	 if (msg_gesture_funciton_leftdirect_proc == NULL) 
+	 {
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_funciton_leftdirect_proc failed\n");
+	 } 
+	 else 
+	 {
+		 msg_gesture_funciton_leftdirect_proc->read_proc = proc_Gesture_Function_LeftDirect_read;
+		 msg_gesture_funciton_leftdirect_proc->write_proc = proc_Gesture_Function_LeftDirect_write;
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_funciton_leftdirect_proc success\n");
+	 }
+	 msg_gesture_funciton_rightdirect_proc = create_proc_entry("rightdirect", CTP_GESTURE_FUNCTION_AUTHORITY_PROC, msg_device_proc);
+	 if (msg_gesture_funciton_rightdirect_proc == NULL) 
+	 {
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_funciton_rightdirect_proc failed\n");
+	 } 
+	 else 
+	 {
+		 msg_gesture_funciton_rightdirect_proc->read_proc = proc_Gesture_Function_RightDirect_read;
+		 msg_gesture_funciton_rightdirect_proc->write_proc = proc_Gesture_Function_RightDirect_write;
+		 TPD_DEBUG("msg_Gesture_Fucntion_Proc_File msg_gesture_funciton_rightdirect_proc success\n");
+	 }	
+#endif
+
+///////////////uupdate
+#ifdef PROC_FIRMWARE_UPDATE
+	 msg_version_proc = create_proc_entry("version", CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_device_proc);
+	 if (msg_version_proc == NULL) 
+	 {
+		 TPD_DEBUG("create_proc_entry msg_version_proc failed\n");
+	 } 
+	 else 
+	 {
+		 msg_version_proc->read_proc = proc_version_read;
+		 msg_version_proc->write_proc = proc_version_write;
+		 TPD_DEBUG("create_proc_entry msg_version_proc success\n");
+	 }
+	 msg_data_proc = create_proc_entry("data", CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_device_proc);
+	 if (msg_data_proc == NULL) 
+	 {
+		 TPD_DEBUG("create_proc_entry msg_data_proc failed\n");
+	 } 
+	 else 
+	 {
+		 msg_data_proc->read_proc = proc_data_read;
+		 msg_data_proc->write_proc = proc_data_write;
+		 TPD_DEBUG("create_proc_entry msg_data_proc success\n");
+	 }
+	 msg_update_proc = create_proc_entry("update", CTP_UPDATE_GESTURE_AUTHORITY_SYS, msg_device_proc);
+	 if (msg_update_proc == NULL) 
+	 {
+		 TPD_DEBUG("create_proc_entry msg_update_proc failed\n");
+	 } 
+	 else 
+	 {
+		 msg_update_proc->read_proc = NULL;
+		 msg_update_proc->write_proc = proc_update_write;
+		 TPD_DEBUG("create_proc_entry msg_update_proc success\n");
+	 }	  
+#endif
+ }
+#endif
+
+
+#endif
+
+
+ static u8 Calculate_8BitsChecksum( u8 *msg, s32 s32Length )
+ {
+	 s32 s32Checksum = 0;
+	 s32 i;
+ 
+	 for( i = 0 ; i < s32Length; i++ )
+	 {
+		 s32Checksum += msg[i];
+	 }
+ 
+	 return ( u8 )( ( -s32Checksum ) & 0xFF );
+ }
+#ifdef MSG_GESTURE_FUNCTION
+void gesture_key_down(int x, int y)
+{
+	tpd_button(x, y, 1); 
+	tpd_button(x, y, 0);
+}
+#endif
+ static int tpd_touchinfo(TouchScreenInfo_t *touchData)
+ {
+
+    u8 val[8] = {0};
+    u8 Checksum = 0;
+    u8 i;
+    u32 delta_x = 0, delta_y = 0;
+    u32 u32X = 0;
+    u32 u32Y = 0;
+    u8 flag=0;
+#ifdef MSG_GESTURE_FUNCTION
+		int closeGesturnRetval = 0;
+	int temp=0;
+#endif
+    TPD_DEBUG(KERN_ERR "[msg2133]==tpd_touchinfo() \n");
+
+#ifdef SWAP_X_Y
+    int tempx;
+    int tempy;
+#endif
+
+    /*Get Touch Raw Data*/
+    i2c_master_recv( i2c_client, &val[0], REPORT_PACKET_LENGTH );
+    TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--val[0]:%x, REPORT_PACKET_LENGTH:%x \n",val[0], REPORT_PACKET_LENGTH);
+
+    Checksum = Calculate_8BitsChecksum( &val[0], 7 ); //calculate checksum
+    TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--Checksum:%x, val[7]:%x, val[0]:%x \n",Checksum, val[7], val[0]);
+
+#ifdef MSG_GESTURE_FUNCTION
+if (tpd_gesture_flag == 1)
+{							
+	if(( val[0] == 0x52 ) && ( val[1] == 0xFF ) && ( val[2] == 0xFF ) && ( val[3] == 0xFF ) && ( val[4] == 0xFF ) && ( val[6] == 0xFF ) && ( Checksum == val[7] ))
+	{
+		switch(val[5])
+		{
+			case KEY_UP_VALUE:
+			gesture_key_down(KEY_UP_P);
+			break;
+			case KEY_DOWN_VALUE:
+			gesture_key_down(KEY_DOWN_P);
+			break;
+			case KEY_LEFT_VALUE:
+			gesture_key_down(KEY_LEFT_P);
+			break;
+			case KEY_RIGHT_VALUE:
+			gesture_key_down(KEY_RIGHT_P);
+			break;
+			case KEY_DOUBLE_VALUE:
+			gesture_key_down(KEY_DOUBLE_P);
+			temp=1;
+			break;
+			case KEY_M_VALUE:
+			gesture_key_down(KEY_M_P);
+			break;
+			case KEY_O_VALUE:
+			gesture_key_down(KEY_O_P);
+			break;
+			case KEY_W_VALUE:
+			gesture_key_down(KEY_W_P);
+			temp=2;
+			break;
+			case KEY_C_VALUE:
+			gesture_key_down(KEY_C_P);
+			break;
+			case KEY_E_VALUE:
+			gesture_key_down(KEY_E_P);
+			break;
+			case KEY_L_VALUE:
+			gesture_key_down(KEY_L_P);
+			break;
+			case KEY_S_VALUE:
+			gesture_key_down(KEY_S_P);
+			break;
+			case KEY_V_VALUE:
+			gesture_key_down(KEY_V_P);
+			break;
+			case KEY_Z_VALUE:
+			gesture_key_down(KEY_Z_P);
+			break;
+		}
+		return 1;
+	 }
+}  
+#endif
+
+    if( ( Checksum == val[7] ) && ( val[0] == 0x52 )) //check the checksum  of packet
+    #ifdef __TP_PROXIMITY_SUPPORT__
+		if(val[5] == 0x80&&(val[1]==0xFF) &&(val[4]==0xFF) ) // 接近触摸屏  =----->  灭屏
+		{
+			if((g_bPsSensorOpen == 1) && (g_nPsSensorDate == 1))
+			{
+				mutex_lock(&msg2133_sensor_mutex);
+				g_nPsSensorDate = 0;
+				mutex_unlock(&msg2133_sensor_mutex);
+			}
+			return 0;
+								
+		}
+		else if(val[5] == 0x40&&(val[1]==0xFF) &&(val[4]==0xFF) ) // 远离触摸屏---->开屏
+		{			
+			if(/*(g_bPsSensorOpen == 1) && */(g_nPsSensorDate == 0))
+			{
+				mutex_lock(&msg2133_sensor_mutex);
+				g_nPsSensorDate = 1;
+				mutex_unlock(&msg2133_sensor_mutex);
+			}
+			return 0;
+		}
+		else
+#endif
+    {
+        u32X = ( ( ( val[1] & 0xF0 ) << 4 ) | val[2] );   //parse the packet to coordinates
+        u32Y = ( ( ( val[1] & 0x0F ) << 8 ) | val[3] );
+
+        delta_x = ( ( ( val[4] & 0xF0 ) << 4 ) | val[5] );
+        delta_y = ( ( ( val[4] & 0x0F ) << 8 ) | val[6] );
+TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--u32X:%d, u32Y:%d, delta_x:%d, delta_y:%d \n",u32X, u32Y,delta_x, delta_y);
+
+#ifdef SWAP_X_Y
+        tempy = u32X;
+        tempx = u32Y;
+        u32X = tempx;
+        u32Y = tempy;
+
+        tempy = delta_x;
+        tempx = delta_y;
+        delta_x = tempx;
+        delta_y = tempy;
+#endif
+
+#if 0
+#ifdef REVERSE_X
+        u32X = 2047 - u32X;
+        delta_x = 4095 - delta_x;
+#endif
+#ifdef REVERSE_Y
+        u32Y = 2047 - u32Y;
+        delta_y = 4095 - delta_y;
+#endif
+#endif
+	if(temp==1)
+	{
+        u32X = 2047 - u32X;
+        delta_x = 4095 - delta_x;
+	}
+	else if(temp==2)
+	{
+        u32Y = 2047 - u32Y;
+        delta_y = 4095 - delta_y;
+	}
+	
+
+
+TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--u32X:%d, u32Y:%d, delta_x:%d, delta_y:%d \n",u32X, u32Y,delta_x, delta_y);
+
+        if( ( val[1] == 0xFF ) && ( val[2] == 0xFF ) && ( val[3] == 0xFF ) && ( val[4] == 0xFF ) && ( val[6] == 0xFF ) )
+        { 
+            touchData->Point[0].X = 0; // final X coordinate
+            touchData->Point[0].Y = 0; // final Y coordinate
+
+            if( ( val[5] == 0x0 ) || ( val[5] == 0xFF ) )
+            {
+                touchData->nFingerNum = 0; //touch end
+                touchData->nTouchKeyCode = 0; //TouchKeyMode
+                touchData->nTouchKeyMode = 0; //TouchKeyMode
+            }
+            else
+            {
+                touchData->nTouchKeyMode = 1; //TouchKeyMode
+                touchData->nTouchKeyCode = val[5]; //TouchKeyCode
+                touchData->nFingerNum = 1;
+            }
+        }
+        else
+        {
+            touchData->nTouchKeyMode = 0; //Touch on screen...
+
+#if 0
+#ifdef REVERSE_X
+                ( delta_x == 4095 )
+#else
+                ( delta_x == 0 )
+#endif
+                &&
+#ifdef REVERSE_Y
+                ( delta_y == 4095 )
+#else
+                ( delta_y == 0 )
+#endif
+            )
+#endif
+
+	if( ( delta_x == 0 )&&( delta_y == 0 ))
+		flag = 1;
+
+	
+            if(flag)
+            {
+                touchData->nFingerNum = 1; //one touch
+                touchData->Point[0].X = ( u32X * MS_TS_MSG21XX_X_MAX ) / 2048;
+                touchData->Point[0].Y = ( u32Y * MS_TS_MSG21XX_Y_MAX ) / 2048;
+		TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--FingerNum = 1 \n");
+            }
+            else
+            {
+                u32 x2, y2;
+
+                touchData->nFingerNum = 2; //two touch
+
+                /* Finger 1 */
+                touchData->Point[0].X = ( u32X * MS_TS_MSG21XX_X_MAX ) / 2048;
+                touchData->Point[0].Y = ( u32Y * MS_TS_MSG21XX_Y_MAX ) / 2048;
+
+                /* Finger 2 */
+                if( delta_x > 2048 )    //transform the unsigh value to sign value
+                {
+                    delta_x -= 4096;
+                }
+                if( delta_y > 2048 ) 
+                {
+                    delta_y -= 4096;
+                }
+
+                x2 = ( u32 )( u32X + delta_x );
+                y2 = ( u32 )( u32Y + delta_y );
+
+                touchData->Point[1].X = ( x2 * MS_TS_MSG21XX_X_MAX ) / 2048;
+                touchData->Point[1].Y = ( y2 * MS_TS_MSG21XX_Y_MAX ) / 2048;
+				TPD_DEBUG(KERN_ERR"[tpd_touchinfo]--FingerNum = 2 \n");
+            }
+        }	
+		return true;
+
+       
+    }
+    else
+    {
+    
+		return false;
+        //DBG("Packet error 0x%x, 0x%x, 0x%x", val[0], val[1], val[2]);
+        //DBG("             0x%x, 0x%x, 0x%x", val[3], val[4], val[5]);
+        //DBG("             0x%x, 0x%x, 0x%x", val[6], val[7], Checksum);
+        TPD_DEBUG( KERN_ERR "err status in tp\n" );
+    }
+
+    //enable_irq( msg21xx_irq );
+  ///
+
+ };
+ 
+ static  void tpd_down(int x, int y, int p) {
+ 	
+	 // input_report_abs(tpd->dev, ABS_PRESSURE, p);
+	  input_report_key(tpd->dev, BTN_TOUCH, 1);
+	  input_report_abs(tpd->dev, ABS_MT_TOUCH_MAJOR, 25);
+	  input_report_abs(tpd->dev, ABS_MT_POSITION_X, x);
+	  input_report_abs(tpd->dev, ABS_MT_POSITION_Y, y);
+
+	  /* track id Start 0 */
+		//input_report_abs(tpd->dev, ABS_MT_TRACKING_ID, p); 
+	  input_mt_sync(tpd->dev);
+	  if (FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+	  {   
+		tpd_button(x, y, 1);  
+	  }
+	  TPD_EM_PRINT(x, y, x, y, p-1, 1);
+  }
+  
+ static  void tpd_up(int x, int y,int *count) {
+
+	  input_report_key(tpd->dev, BTN_TOUCH, 0);
+	  input_mt_sync(tpd->dev);
+	  TPD_EM_PRINT(x, y, x, y, 0, 0);
+		  
+	  if(FACTORY_BOOT == get_boot_mode()|| RECOVERY_BOOT == get_boot_mode())
+	  {   
+	  	 TPD_DEBUG(KERN_ERR "[msg2133]--tpd_up-BOOT MODE--X:%d, Y:%d; \n", x, y);
+		 tpd_button(x, y, 0); 
+	  } 		  
+ 
+  }
+
+ static int touch_event_handler(void *unused)
+ {
+  
+    TouchScreenInfo_t touchData;
+	u8 touchkeycode = 0;
+	static u32 preKeyStatus = 0;
+	int i=0;
+
+    TPD_DEBUG(KERN_ERR "[msg2133]touch_event_handler() do while \n");
+
+	touchData.nFingerNum = 0;
+	TPD_DEBUG(KERN_ERR "[msg2133]touch_event_handler() do while \n");
+	 
+	if (tpd_touchinfo(&touchData)) 
+	{
+	 
+		TPD_DEBUG(KERN_ERR "[msg2133]--KeyMode:%d, KeyCode:%d, FingerNum =%d \n", touchData.nTouchKeyMode, touchData.nTouchKeyCode, touchData.nFingerNum );
+		//key...
+		if( touchData.nTouchKeyMode )
+		{
+	    	//key mode change virtual key mode
+			touchData.nFingerNum = 1;
+			if( touchData.nTouchKeyCode == 1 )
+			{
+				//touchkeycode = KEY_MENU;
+				touchData.Point[0].X = 250;
+				touchData.Point[0].Y = 900;
+			}
+			if( touchData.nTouchKeyCode == 2 )
+			{
+				//touchkeycode = KEY_HOMEPAGE ;
+				touchData.Point[0].X = 400;//fwvga
+				touchData.Point[0].Y = 900;
+
+			}
+			if( touchData.nTouchKeyCode == 4 )
+			{
+			//touchkeycode = KEY_HOMEPAGE ;
+				touchData.Point[0].X = 100;//fwvga
+				touchData.Point[0].Y = 900;
+
+			}
+			if( touchData.nTouchKeyCode == 8 )
+			{
+				//touchkeycode = KEY_SEARCH;
+				touchData.Point[0].X = 200;
+				touchData.Point[0].Y = 517;
+
+			}
+					
+		}
+				//report
+		{
+	 
+			if( ( touchData.nFingerNum ) == 0 ) //touch end
+			{
+				TPD_DEBUG("------DOWN------ \n");
+			TPD_DEBUG(KERN_ERR "[msg2133]---X:%d, Y:%d; \n", touchData.Point[0].X, touchData.Point[0].Y);
+				tpd_up(touchData.Point[0].X, touchData.Point[0].Y, 0);
+
+				input_sync( tpd->dev );
+			}
+			else //touch on screenMSG2133
+			{
+	 
+				for( i = 0; i < ( (int)touchData.nFingerNum ); i++ )
+				{
+				    TPD_DEBUG("------DOWN------ \n");
+					tpd_down(touchData.Point[i].X, touchData.Point[i].Y, 1);
+					TPD_DEBUG(KERN_ERR "[han_onmsg2133]---X:%d, Y:%d; i=%d \n", touchData.Point[i].X, touchData.Point[i].Y, i);
+				}
+	 
+				input_sync( tpd->dev );
+			}
+		}//end if(touchData->nTouchKeyMode)
+	 
+			}
+
+     mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM); 
+	 return 0;
+ }
+ 
+ static int tpd_detect (struct i2c_client *client, struct i2c_board_info *info) 
+ {
+	 strcpy(info->type, TPD_DEVICE);
+	
+	  return 0;
+ }
+ 
+ static void tpd_eint_interrupt_handler(void)
+ {
+	 mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+	 schedule_work( &msg21xx_wq );
+ }
+
+#ifdef __TP_PROXIMITY_SUPPORT__
+static int msg2133_enable_ps(int enable)
+{
+	u8 ps_store_data[4];
+
+	mutex_lock(&msg2133_sensor_mutex);
+
+	if(enable == 1)
+	{
+		if(g_bPsSensorOpen == 0)
+		{
+			ps_store_data[0] = 0x52;
+			ps_store_data[1] = 0x00;
+            /*if(curr_ic_type==CTP_ID_MSG21XXA)//probe 函数中获取到芯片类型,当然您可以忽略它
+            {
+                ps_store_data[2] = 0x4a;	//ps_store_data[1] ps_store_data[2] 是TP端某变量地址
+            }
+            else if(curr_ic_type==CTP_ID_MSG21XX)
+            {
+                ps_store_data[2] = 0x62;
+            }
+            else*/
+            {
+                ps_store_data[2] = 0x4a;
+            }
+			ps_store_data[3] = 0xa0;		//ps_store_data[4] 是写入TP端变量的值
+
+			HalTscrCDevWriteI2CSeq(0x26, &ps_store_data[0], 4);//发送命令到TP端
+			g_bPsSensorOpen = 1;							//要确保发命令时候TP是可用的状态没有下电
+		}						// suspend()的操作会使TP下电
+	}
+	else
+	{	
+		if(g_bPsSensorOpen == 1)
+		{
+			ps_store_data[0] = 0x52;
+			ps_store_data[1] = 0x00;
+			/*if(curr_ic_type==CTP_ID_MSG21XXA)
+            {
+                ps_store_data[2] = 0x4a;
+            }
+            else if(curr_ic_type==CTP_ID_MSG21XX)
+            {
+                ps_store_data[2] = 0x62;
+            }
+            else*/
+            {
+                ps_store_data[2] = 0x4a;
+            }
+			ps_store_data[3] = 0xa1;
+			HalTscrCDevWriteI2CSeq(0x26, &ps_store_data[0], 4);	
+			g_bPsSensorOpen = 0;			
+		}
+		g_nPsSensorDate = 1;
+	}
+	mutex_unlock(&msg2133_sensor_mutex);
+	return 0;
+}
+
+int msg2133_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
+		void* buff_out, int size_out, int* actualout)
+{
+	int err = 0;
+	int value;
+	hwm_sensor_data* sensor_data;
+
+	//APS_FUN(f);
+	switch (command)
+	{
+		case SENSOR_DELAY:
+			if((buff_in == NULL) || (size_in < sizeof(int)))
+			{
+				APS_ERR("Set delay parameter error!\n");
+				err = -EINVAL;
+			}
+			// Do nothing
+			break;
+
+		case SENSOR_ENABLE:
+			if((buff_in == NULL) || (size_in < sizeof(int)))
+			{
+				APS_ERR("Enable sensor parameter error!\n");
+				err = -EINVAL;
+			}
+			else
+			{				
+				value = *(int *)buff_in;
+				if(value)
+				{
+					wake_lock(&ps_lock);		//wujinyou
+					if(err = msg2133_enable_ps(1))
+					{
+						APS_ERR("enable ps fail: %d\n", err); 
+						return -1;
+					}
+					g_bPsSensorOpen = 1;
+				}
+				else
+				{
+					wake_unlock(&ps_lock);		//wujinyou
+					if(err = msg2133_enable_ps(0))
+					{
+						APS_ERR("disable ps fail: %d\n", err); 
+						return -1;
+					}
+					g_bPsSensorOpen = 0;
+				}
+			}
+			break;
+
+		case SENSOR_GET_DATA:
+			if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
+			{
+				APS_ERR("get sensor data parameter error!\n");
+				err = -EINVAL;
+			}
+			else
+			{
+				sensor_data = (hwm_sensor_data *)buff_out;	
+				sensor_data->values[0] = g_nPsSensorDate;
+				sensor_data->value_divide = 1;
+				sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;			
+			}
+			break;
+		default:
+			APS_ERR("proxmy sensor operate function no this parameter %d!\n", command);
+			err = -1;
+			break;
+	}
+	
+	return err;
+}
+
+
+static void tpd_initialize_ps_sensor_function()
+{
+	struct hwmsen_object obj_ps = {0};
+	int err = 0;
+	
+	g_nPsSensorDate = 1;
+
+	obj_ps.self = NULL;	// no use
+	obj_ps.polling = 1;
+	obj_ps.sensor_operate = msg2133_ps_operate;
+
+	wake_lock_init(&ps_lock,WAKE_LOCK_SUSPEND,"ps wakelock"); //shaohui add
+		
+	if(err = hwmsen_attach(ID_PROXIMITY, &obj_ps))
+	{
+		TPD_DEBUG("attach fail = %d\n", err);
+		return;
+	}
+}
+#endif
+
+#ifdef Auto_Update_Msg2133A
+ static void  Msg2133a_firmware_Auto_update ( void )
+ {
+	 u8  dbbus_tx_data[4];
+	 u8  dbbus_rx_data[2] = {0};
+	 u8  life_counter[2];
+	 u32 i, j;
+	 u32 crc_main, crc_main_tp;
+	 u32 crc_info, crc_info_tp;
+   
+	 int update_pass = 1;
+	 u16 reg_data = 0;
+	 EMEM_TYPE_t emem_type = EMEM_MAIN;
+	 crc_main = 0xffffffff;
+	 crc_info = 0xffffffff;
+	 mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+	 
+	 _HalTscrHWReset();
+	 
+	 // Erase TP Flash first
+	 dbbusDWIICEnterSerialDebugMode();
+	 dbbusDWIICStopMCU();
+	 dbbusDWIICIICUseBus();
+	 dbbusDWIICIICReshape();
+	 mdelay ( 300 );
+	 
+	 // Disable the Watchdog
+	 dbbus_tx_data[0] = 0x10;
+	 dbbus_tx_data[1] = 0x3C;
+	 dbbus_tx_data[2] = 0x60;
+	 dbbus_tx_data[3] = 0x55;
+	 HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	 dbbus_tx_data[0] = 0x10;
+	 dbbus_tx_data[1] = 0x3C;
+	 dbbus_tx_data[2] = 0x61;
+	 dbbus_tx_data[3] = 0xAA;
+	 HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+	 // Stop MCU
+	 dbbus_tx_data[0] = 0x10;
+	 dbbus_tx_data[1] = 0x0F;
+	 dbbus_tx_data[2] = 0xE6;
+	 dbbus_tx_data[3] = 0x01;
+	 HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX, dbbus_tx_data, 4 );
+ 
+ 
+	 drvTP_read_info_dwiic_c33();
+	 
+	 if (0)//( g_dwiic_info_data[0] == 'M' && g_dwiic_info_data[1] == 'S' && g_dwiic_info_data[2] == 'T' && g_dwiic_info_data[3] == 'A' && g_dwiic_info_data[4] == 'R' && g_dwiic_info_data[5] == 'T' && g_dwiic_info_data[6] == 'P' && g_dwiic_info_data[7] == 'C')
+	 {
+		 // updata FW Version
+		 //drvTP_info_updata_C33 ( 8, &temp[32][8], 5 );
+ 
+		 g_dwiic_info_data[8]=temp[32][8];
+		 g_dwiic_info_data[9]=temp[32][9];
+		 g_dwiic_info_data[10]=temp[32][10];
+		 g_dwiic_info_data[11]=temp[32][11];
+		 // updata life counter
+		 life_counter[1] = (( ( (g_dwiic_info_data[13] << 8 ) | g_dwiic_info_data[12]) + 1 ) >> 8 ) & 0xFF;
+		 life_counter[0] = ( ( (g_dwiic_info_data[13] << 8 ) | g_dwiic_info_data[12]) + 1 ) & 0xFF;
+		 g_dwiic_info_data[12]=life_counter[0];
+		 g_dwiic_info_data[13]=life_counter[1];
+		 //drvTP_info_updata_C33 ( 10, &life_counter[0], 3 );
+		 drvDB_WriteReg ( 0x3C, 0xE4, 0x78C5 );
+		 drvDB_WriteReg ( 0x1E, 0x04, 0x7d60 );
+		 // TP SW reset
+		 drvDB_WriteReg ( 0x1E, 0x04, 0x829F );
+ 
+		 mdelay ( 50 );
+		 //TP_DEBUG_ERR("666666666666");
+		 //polling 0x3CE4 is 0x2F43
+		 do
+		 {
+			 reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+ 
+		 }
+		 while ( reg_data != 0x2F43 );
+		 //TP_DEBUG_ERR("777777777777");
+		 // transmit lk info data
+		 HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP , &g_dwiic_info_data[0], 1024 );
+		 //TP_DEBUG_ERR("88888888888");
+		 //polling 0x3CE4 is 0xD0BC
+		 do
+		 {
+			 reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+		 }
+		 while ( reg_data != 0xD0BC );
+		 //TP_DEBUG_ERR("9999999999999");
+	 }
+ 
+	 //erase main
+	 TP_DEBUG_ERR("MSG2133aaaaaaaaaaa");
+	 drvTP_erase_emem_c33 ( EMEM_MAIN );
+	 mdelay ( 1000 );
+ 
+	 //ResetSlave();
+	 _HalTscrHWReset();
+ //drvDB_EnterDBBUS();
+	 dbbusDWIICEnterSerialDebugMode();
+	 dbbusDWIICStopMCU();
+	 dbbusDWIICIICUseBus();
+	 dbbusDWIICIICReshape();
+	 mdelay ( 600 );
+ 
+	 /////////////////////////
+	 // Program
+	 /////////////////////////
+ 
+	 //polling 0x3CE4 is 0x1C70
+	 if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+	 {
+		 do
+		 {
+			 reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+		 }
+		 while ( reg_data != 0x1C70 );
+	 }
+ 
+	 switch ( emem_type )
+	 {
+		 case EMEM_ALL:
+			 drvDB_WriteReg ( 0x3C, 0xE4, 0xE38F );  // for all-blocks
+			 break;
+		 case EMEM_MAIN:
+			 drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for main block
+			 break;
+		 case EMEM_INFO:
+			 drvDB_WriteReg ( 0x3C, 0xE4, 0x7731 );  // for info block
+ 
+			 drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x01 );
+ 
+			 drvDB_WriteReg8Bit ( 0x3C, 0xE4, 0xC5 ); //
+			 drvDB_WriteReg8Bit ( 0x3C, 0xE5, 0x78 ); //
+ 
+			 drvDB_WriteReg8Bit ( 0x1E, 0x04, 0x9F );
+			 drvDB_WriteReg8Bit ( 0x1E, 0x05, 0x82 );
+ 
+			 drvDB_WriteReg8Bit ( 0x0F, 0xE6, 0x00 );
+			 mdelay ( 100 );
+			 break;
+	 }
+ TP_DEBUG_ERR("MSG2133bbbbbbbbbbbbbb");
+	 // polling 0x3CE4 is 0x2F43
+	 do
+	 {
+		 reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+	 }
+	 while ( reg_data != 0x2F43 );
+ TP_DEBUG_ERR("MSG2133ccccccccccccc");
+	 // calculate CRC 32
+	 Init_CRC32_Table ( &crc_tab[0] );
+ 
+	 for ( i = 0; i < 33; i++ ) // total  33 KB : 2 byte per R/W
+	 {
+		 if ( emem_type == EMEM_INFO )
+			 i = 32;
+ 
+		 if ( i < 32 )	 //emem_main
+		 {
+			 if ( i == 31 )
+			 {
+				 temp[i][1014] = 0x5A; //Fmr_Loader[1014]=0x5A;
+				 temp[i][1015] = 0xA5; //Fmr_Loader[1015]=0xA5;
+ 
+				 for ( j = 0; j < 1016; j++ )
+				 {
+					 //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
+					 crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
+				 }
+			 }
+			 else
+			 {
+				 for ( j = 0; j < 1024; j++ )
+				 {
+					 //crc_main=Get_CRC(Fmr_Loader[j],crc_main,&crc_tab[0]);
+					 crc_main = Get_CRC ( temp[i][j], crc_main, &crc_tab[0] );
+				 }
+			 }
+		 }
+		 else  //emem_info
+		 {
+			 for ( j = 0; j < 1024; j++ )
+			 {
+				 //crc_info=Get_CRC(Fmr_Loader[j],crc_info,&crc_tab[0]);
+				 crc_info = Get_CRC ( g_dwiic_info_data[j], crc_info, &crc_tab[0] );
+			 }
+			 if ( emem_type == EMEM_MAIN ) break;
+		 }
+		 //drvDWIIC_MasterTransmit( DWIIC_MODE_DWIIC_ID, 1024, Fmr_Loader );
+		 TP_DEBUG_ERR("MSG2133dddddddddddddd");
+        #if 1
+		 {
+			 u32 n = 0;
+			 for(n=0;n<UPDATE_TIMES;n++)
+			 {
+				 TP_DEBUG_ERR("i=%d,n=%d",i,n);
+				 HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i]+n*N_BYTE_PER_TIME, N_BYTE_PER_TIME );
+			 }
+		 }
+        #else
+		 HalTscrCDevWriteI2CSeq ( FW_ADDR_MSG21XX_TP, temp[i], 1024 );
+        #endif
+		 TP_DEBUG_ERR("MSG2133eeeeeeeeeeee");
+		 // polling 0x3CE4 is 0xD0BC
+		 do
+		 {
+			 reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+		 }
+		 while ( reg_data != 0xD0BC );
+		 TP_DEBUG_ERR("MSG2133ffffffffffffff");
+		 drvDB_WriteReg ( 0x3C, 0xE4, 0x2F43 );
+	 }
+		 TP_DEBUG_ERR("MSG2133ggggggggg");
+	 if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+	 {
+		 // write file done and check crc
+		 drvDB_WriteReg ( 0x3C, 0xE4, 0x1380 );
+		 TP_DEBUG_ERR("MSG2133hhhhhhhhhhhhhh");
+	 }
+	 mdelay ( 10 ); //MCR_CLBK_DEBUG_DELAY ( 10, MCU_LOOP_DELAY_COUNT_MS );
+ 
+	 if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+	 {
+		 // polling 0x3CE4 is 0x9432
+		 TP_DEBUG_ERR("MSG2133iiiiiiiiii");
+		 do
+		 {
+			 reg_data = drvDB_ReadReg ( 0x3C, 0xE4 );
+		 }while ( reg_data != 0x9432 );
+		 TP_DEBUG_ERR("MSG2133jjjjjjjjjjjjj");
+	 }
+ 
+	 crc_main = crc_main ^ 0xffffffff;
+	 crc_info = crc_info ^ 0xffffffff;
+ 
+	 if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+	 {
+		 TP_DEBUG_ERR("MSG2133kkkkkkkkkkk");
+		 // CRC Main from TP
+		 crc_main_tp = drvDB_ReadReg ( 0x3C, 0x80 );
+		 crc_main_tp = ( crc_main_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0x82 );
+ 
+		 // CRC Info from TP
+		 crc_info_tp = drvDB_ReadReg ( 0x3C, 0xA0 );
+		 crc_info_tp = ( crc_info_tp << 16 ) | drvDB_ReadReg ( 0x3C, 0xA2 );
+	 }
+   //TP_DEBUG ( "crc_main=0x%x, crc_info=0x%x, crc_main_tp=0x%x, crc_info_tp=0x%x\n",
+	 // 		  crc_main, crc_info, crc_main_tp, crc_info_tp );
+ 
+	 //drvDB_ExitDBBUS();
+	 TP_DEBUG_ERR("MSG2133lllllllllllll");
+	 update_pass = 1;
+	 if ( ( emem_type == EMEM_ALL ) || ( emem_type == EMEM_MAIN ) )
+	 {
+		 if ( crc_main_tp != crc_main )
+			 update_pass = 0;
+ 
+		 if ( crc_info_tp != crc_info )
+			 update_pass = 0;
+	 }
+ 
+	 if ( !update_pass )
+	 {
+		 TP_DEBUG_ERR ( "MSG2133update_C33 ok111\n" );
+		 _HalTscrHWReset();
+		 FwDataCnt = 0;
+		 mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+		 return 1;
+	 }
+ 
+	 TP_DEBUG_ERR ( "MSG2133update_C33 OK\n" );
+	 _HalTscrHWReset();
+	 FwDataCnt = 0;
+	 mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+	 return 1;
+
+ }
+ 
+#endif
+
+
+ static int  tpd_probe(struct i2c_client *client, const struct i2c_device_id *id)
+ {	 
+ 
+	int retval = TPD_OK;
+	char data;
+	u8 report_rate=0;
+	int err=0;
+	int reset_count = 0;
+	int i = 0;
+	i2c_client = client;
+	//msg21xx_i2c_client = client;
+	
+	/*reset I2C clock*/
+    //i2c_client->timing = 0;
+    
+   INIT_WORK( &msg21xx_wq, touch_event_handler );
+//power on, need confirm with SA
+#ifdef TPD_POWER_SOURCE_CUSTOM
+	hwPowerOn(TPD_POWER_SOURCE_CUSTOM, VOL_2800, "TP");
+#else
+	hwPowerOn(MT65XX_POWER_LDO_VGP2, VOL_2800, "TP");//MT65XX_POWER_LDO_VGP2
+#endif
+#ifdef TPD_POWER_SOURCE_1800
+	hwPowerOn(TPD_POWER_SOURCE_1800, VOL_1800, "TP");
+#endif 
+
+
+#if 1
+	_HalTscrHWReset();	
+#endif
+	if(!Check_msg2133_I2C_state())
+	{
+		return -1;
+	}
+
+	mt_set_gpio_mode(GPIO_CTP_EINT_PIN, GPIO_CTP_EINT_PIN_M_EINT);
+    mt_set_gpio_dir(GPIO_CTP_EINT_PIN, GPIO_DIR_IN);
+   	mt_set_gpio_pull_enable(GPIO_CTP_EINT_PIN, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_select(GPIO_CTP_EINT_PIN, GPIO_PULL_DOWN);
+		
+
+    msleep(10);
+
+	//mt65xx_eint_set_sens(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_SENSITIVE);
+	//mt65xx_eint_set_hw_debounce(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_DEBOUNCE_CN);
+	mt_eint_registration(CUST_EINT_TOUCH_PANEL_NUM, CUST_EINT_TOUCH_PANEL_TYPE, tpd_eint_interrupt_handler, 1);
+	msleep(50);
+	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+	msleep(200);
+
+    tpd_load_status = 1;
+
+	TPD_DMESG("msg2133 Touch Panel Device Probe %s\n", (retval < TPD_OK) ? "FAIL" : "PASS");
+	
+	TPD_DEBUG("msg2133--frameware upgrade \n");
+#ifdef Auto_Update_Msg2133A
+	{
+		unsigned char dbbus_tx_data[3];
+		unsigned char dbbus_rx_data[4] ;
+		unsigned short major = 0, minor = 0,FW_major = 0,FW_minor = 0;
+		dbbusDWIICEnterSerialDebugMode();
+		dbbusDWIICStopMCU();
+		dbbusDWIICIICUseBus();
+		dbbusDWIICIICReshape();
+		//Get_Chip_Version();
+		dbbus_tx_data[0] = 0x53;
+		dbbus_tx_data[1] = 0x00;
+		dbbus_tx_data[2] = 0x2A;
+		//i2c_write(TOUCH_ADDR_MSG20XX, &dbbus_tx_data[0], 3);
+		//i2c_read(TOUCH_ADDR_MSG20XX, &dbbus_rx_data[0], 4);
+		HalTscrCDevWriteI2CSeq( FW_ADDR_MSG21XX_TP, &dbbus_tx_data[0], 3 );
+		HalTscrCReadI2CSeq( FW_ADDR_MSG21XX_TP, &dbbus_rx_data[0], 4 );
+		major = (dbbus_rx_data[1] << 8) + dbbus_rx_data[0];
+		minor = (dbbus_rx_data[3] << 8) + dbbus_rx_data[2];
+		FW_major = (MSG_2133_BIN[0x7F4F] << 8) + MSG_2133_BIN[0x7F4E];
+		FW_minor = (MSG_2133_BIN[0x7F51] << 8) + MSG_2133_BIN[0x7F50];			
+		for(i = 0; i < 33; i++)
+		{
+			memcpy(&temp[i][0], &MSG_2133_BIN[i*1024], 1024);//33779
+		}
+		if(((major == FW_major)&&(minor < FW_minor))||(major != FW_major))
+			Msg2133a_firmware_Auto_update();
+	}
+
+#endif
+    /*frameware upgrade*/	
+#ifdef __FIRMWARE_UPDATE__
+		firmware_class = class_create( THIS_MODULE, "ms-touchscreen-msg20xx" );
+		if( IS_ERR( firmware_class ) )
+			pr_err( "Failed to create class(firmware)!\n" );
+		firmware_cmd_dev = device_create( firmware_class,
+										  NULL, 0, NULL, "device" );
+		if( IS_ERR( firmware_cmd_dev ) )
+			pr_err( "Failed to create device(firmware_cmd_dev)!\n" );
+	
+		// version
+		if( device_create_file( firmware_cmd_dev, &dev_attr_version ) < 0 )
+			pr_err( "Failed to create device file(%s)!\n", dev_attr_version.attr.name );
+		// update
+		if( device_create_file( firmware_cmd_dev, &dev_attr_update ) < 0 )
+			pr_err( "Failed to create device file(%s)!\n", dev_attr_update.attr.name );
+		// data
+		if( device_create_file( firmware_cmd_dev, &dev_attr_data ) < 0 )
+			pr_err( "Failed to create device file(%s)!\n", dev_attr_data.attr.name );
+		// clear
+		if( device_create_file( firmware_cmd_dev, &dev_attr_clear ) < 0 )
+			pr_err( "Failed to create device file(%s)!\n", dev_attr_clear.attr.name );
+
+#ifdef  MSG_GESTURE_FUNCTION
+			// DoubleClick
+			if (device_create_file(firmware_cmd_dev, &dev_attr_doubleclick) < 0)
+				pr_err("Failed to create device file(%s)!\n", dev_attr_doubleclick.attr.name);
+			
+			// UpDirect
+			if (device_create_file(firmware_cmd_dev, &dev_attr_updirect) < 0)
+				pr_err("Failed to create device file(%s)!\n", dev_attr_updirect.attr.name);
+		
+			// DownDirect
+			if (device_create_file(firmware_cmd_dev, &dev_attr_downdirect) < 0)
+				pr_err("Failed to create device file(%s)!\n", dev_attr_downdirect.attr.name);
+		
+			// LeftDirect
+			if (device_create_file(firmware_cmd_dev, &dev_attr_leftdirect) < 0)
+				pr_err("Failed to create device file(%s)!\n", dev_attr_leftdirect.attr.name);
+		
+			// RightDirect
+			if (device_create_file(firmware_cmd_dev, &dev_attr_rightdirect) < 0)
+				pr_err("Failed to create device file(%s)!\n", dev_attr_rightdirect.attr.name);
+#endif
+
+		dev_set_drvdata( firmware_cmd_dev, NULL );
+#endif
+
+#ifdef __TP_PROXIMITY_SUPPORT__
+	tpd_initialize_ps_sensor_function();
+	#ifdef __SHOW_HW_INFORMATION__
+	hw_set_alsps_info(ALSPS_MSG2133);
+	#endif
+#endif
+   return 0;
+   
+ }
+
+ static int  tpd_remove(struct i2c_client *client)
+ 
+ {
+   
+	 TPD_DEBUG("TPD removed\n");
+ 
+   return 0;
+ }
+ 
+ 
+ static int tpd_local_init(void)
+ {
+
+ 
+  	TPD_DMESG("Mstar msg2133 I2C Touchscreen Driver (Built %s @ %s)\n", __DATE__, __TIME__);
+ 
+ 
+    if(i2c_add_driver(&tpd_i2c_driver)!=0)
+   	{
+  		TPD_DMESG("msg2133 unable to add i2c driver.\n");
+	      	return -1;
+    }
+    if(tpd_load_status == 0) 
+    {
+    	TPD_DMESG("msg2133 add error touch panel driver.\n");
+    	i2c_del_driver(&tpd_i2c_driver);
+    	return -1;
+    }
+
+#ifdef TPD_HAVE_BUTTON     
+    tpd_button_setting(TPD_KEY_COUNT, tpd_keys_local, tpd_keys_dim_local);// initialize tpd button data
+#endif   
+  
+//#if (defined(TPD_WARP_START) && defined(TPD_WARP_END))    
+//WARP CHECK IS NEED --XB.PANG
+//#endif 
+
+	TPD_DMESG("end %s, %d\n", __FUNCTION__, __LINE__);  
+		
+    return 0; 
+ }
+
+ static void tpd_resume( struct early_suspend *h )
+ {
+   TPD_DMESG("TPD wake up\n");
+
+#ifdef MSG_GESTURE_FUNCTION
+	 tpd_gesture_flag = 0;
+#endif
+
+#ifdef __TP_PROXIMITY_SUPPORT__
+	if(g_bPsSensorOpen == 1 && (g_bSuspend))
+	{
+		TPD_DMESG("msg sensor resume in calling tp no need to resume\n");
+		return 0;
+	}
+	g_bSuspend = 0;
+	if(g_call_state)
+		return;
+#endif
+#ifdef TPD_CLOSE_POWER_IN_SLEEP	
+	hwPowerOn(TPD_POWER_SOURCE,VOL_2800,"TP");
+#endif
+	msleep(100);
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+	mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
+	msleep(50);
+	TPD_DMESG(" msg2133 reset\n");
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ONE);
+	msleep(200);
+	mt_eint_unmask(CUST_EINT_TOUCH_PANEL_NUM);
+	TPD_DMESG("TPD wake up done\n");
+	
+ }
+
+ static void tpd_suspend( struct early_suspend *h )
+ {
+#ifdef MSG_GESTURE_FUNCTION
+		 int msg_gesturemoderetval = 0;
+#endif
+
+#ifdef __TP_PROXIMITY_SUPPORT__
+	if(g_bPsSensorOpen == 1)
+	{
+		TPD_DMESG("msg suspend in calling tp no need to suspend\n");
+		return 0;
+	}
+	g_bSuspend = 1;
+	if(g_call_state)
+	{
+		return;
+	}
+#endif
+
+#ifdef MSG_GESTURE_FUNCTION
+	
+		msg_GetGestureModeValue();
+		if(set_gesture_mode != 0)
+		{
+			
+			if((set_gesture_mode >= 0x01)&&(set_gesture_mode <= 0x1F))
+			{
+				while(msg_gesturemoderetval == 0){
+					msg_gesturemoderetval = msg_OpenGestureFunction(set_gesture_mode);
+					} ////be sure enter this function
+				return ;
+			}
+			else
+			{
+			   ////command wrong!
+			}
+		}
+#endif
+
+	TPD_DMESG("TPD enter sleep\n");
+	mt_eint_mask(CUST_EINT_TOUCH_PANEL_NUM);
+	
+	mt_set_gpio_mode(GPIO_CTP_RST_PIN, GPIO_CTP_RST_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_CTP_RST_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_CTP_RST_PIN, GPIO_OUT_ZERO);  
+
+#ifdef TPD_CLOSE_POWER_IN_SLEEP	
+	hwPowerDown(TPD_POWER_SOURCE,"TP");
+#else
+	//TP enter sleep mode----XB.PANG NEED CHECK
+	//if have sleep mode
+#endif
+    TPD_DMESG("TPD enter sleep done\n");
+ } 
+
+
+ static struct tpd_driver_t tpd_device_driver = {
+		 .tpd_device_name = "msg2133",
+		 .tpd_local_init = tpd_local_init,
+		 .suspend = tpd_suspend,
+		 .resume = tpd_resume,
+#ifdef TPD_HAVE_BUTTON
+		 .tpd_have_button = 1,
+#else
+		 .tpd_have_button = 0,
+#endif		
+ };
+ /* called when loaded into kernel */
+ static int __init tpd_driver_init(void) {
+	 TPD_DEBUG("MediaTek MSG2133 touch panel driver init\n");
+	   i2c_register_board_info(2, &msg2133_i2c_tpd, 1);//hhhhhhhhhhhhhhhhhhh
+		 if(tpd_driver_add(&tpd_device_driver) < 0)
+			 TPD_DMESG("add MSG2133 driver failed\n");
+
+
+	 return 0;
+ }
+ 
+ /* should never be called */
+ static void __exit tpd_driver_exit(void) {
+	 TPD_DMESG("MediaTek MSG2133 touch panel driver exit\n");
+	 tpd_driver_remove(&tpd_device_driver);
+ }
+ 
+ module_init(tpd_driver_init);
+ module_exit(tpd_driver_exit);
+
+
diff --git a/mediatek/custom/common/kernel/touchpanel/msg_test/tpd_custom_msg2133.h b/mediatek/custom/common/kernel/touchpanel/msg_test/tpd_custom_msg2133.h
new file mode 100644
index 0000000..c8ac938
--- /dev/null
+++ b/mediatek/custom/common/kernel/touchpanel/msg_test/tpd_custom_msg2133.h
@@ -0,0 +1,156 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef __TPD_CUSTOM_MSG2133_H__
+#define __TPD_CUSTOM_MSG2133_H__
+
+#include <pmic_drv.h>
+#define TPD_POWER_SOURCE_CUSTOM PMIC_APP_CAP_TOUCH_VDD
+/* Pre-defined definition */
+#define TPD_TYPE_CAPACITIVE
+#define TPD_I2C_NUMBER           2
+
+#if defined(__TP_GESTURE_WAKEUP__)
+	#define MSG_GESTURE_FUNCTION
+#endif
+//#define TOUCH_ADDR_MSG20XX 0Xc0
+
+#define TPD_DELAY                (2*HZ/100)
+
+//#define SWAP_X_Y
+//#define REVERSE_Y
+//#define REVERSE_X
+#define MAX_TOUCH_FINGER     5
+#if defined(__MAINLCD_480X800__)
+#define MS_TS_MSG21XX_X_MAX  480//480
+	#define MS_TS_MSG21XX_Y_MAX   800
+#else
+#define MS_TS_MSG21XX_X_MAX  240//480
+#define MS_TS_MSG21XX_Y_MAX   320//800
+#endif
+
+#define REPORT_PACKET_LENGTH   8//2--8--128--80
+
+#define TPD_RES_X                240
+#define TPD_RES_Y                320
+
+#define TPD_HAVE_BUTTON
+#define HAVE_TOUCH_KEY
+#define TPD_BUTTON_HEIGHT       900
+//#define TPD_KEY_COUNT           3
+//#define TPD_KEYS                {KEY_BACK, KEY_HOMEPAGE, KEY_MENU}
+//#define TPD_KEYS_DIM        {{40,517,78,38},{120,517,78,38},{200,517,78,38}}
+
+#if defined(__A19_BP_TP__)
+#define TPD_KEY_COUNT           3
+	#define TPD_KEYS                	{ KEY_HOME, KEY_BACK, KEY_MENU}
+	#define TPD_KEYS_DIM            {{100,900,20,40},{250,900,100,40},{400,900,100,40}}
+#else
+	#if defined(MSG_GESTURE_FUNCTION)
+	#define GESTRUE_KEY_X 600
+	#define GESTRUE_KEY_Y 1200
+
+	#define KEY_WIDTH 	2
+	#define KEY_HEIGHT	2
+
+	#define KEY_UP_VALUE	0x29
+	#define KEY_DOWN_VALUE	0x27
+	#define KEY_LEFT_VALUE	0x28
+	#define KEY_RIGHT_VALUE	0x26
+	#define KEY_DOUBLE_VALUE	0x58
+
+	#define KEY_M_VALUE	0x20
+	#define KEY_O_VALUE	0x21
+	#define KEY_W_VALUE	0x22
+	#define KEY_C_VALUE	0x23
+	#define KEY_E_VALUE	0x24
+	#define KEY_L_VALUE	0x25
+	#define KEY_S_VALUE	0x2A
+	#define KEY_V_VALUE	0x2B
+	#define KEY_Z_VALUE	0x2C
+
+	#define KEY_UP_P	(GESTRUE_KEY_X),GESTRUE_KEY_Y
+	#define KEY_DOWN_P	(GESTRUE_KEY_X+10),GESTRUE_KEY_Y
+	#define KEY_LEFT_P	(GESTRUE_KEY_X+20),GESTRUE_KEY_Y
+	#define KEY_RIGHT_P	(GESTRUE_KEY_X+30),GESTRUE_KEY_Y
+	#define KEY_DOUBLE_P	(GESTRUE_KEY_X+40),GESTRUE_KEY_Y
+	#define KEY_M_P		(GESTRUE_KEY_X+50),GESTRUE_KEY_Y
+	#define KEY_O_P		(GESTRUE_KEY_X+60),GESTRUE_KEY_Y
+	#define KEY_W_P		(GESTRUE_KEY_X+70),GESTRUE_KEY_Y
+	#define KEY_C_P		(GESTRUE_KEY_X+80),GESTRUE_KEY_Y
+	#define KEY_E_P		(GESTRUE_KEY_X+90),GESTRUE_KEY_Y
+	#define KEY_L_P		(GESTRUE_KEY_X+100),GESTRUE_KEY_Y
+	#define KEY_S_P		(GESTRUE_KEY_X+110),GESTRUE_KEY_Y
+	#define KEY_V_P		(GESTRUE_KEY_X+120),GESTRUE_KEY_Y
+	#define KEY_Z_P		(GESTRUE_KEY_X+130),GESTRUE_KEY_Y
+	#define KEY_WIDTH_HEIGHT	KEY_WIDTH,KEY_HEIGHT
+
+	#define KEY_UP_D	(GESTRUE_KEY_X),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_DOWN_D	(GESTRUE_KEY_X+10),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_LEFT_D	(GESTRUE_KEY_X+20),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_RIGHT_D	(GESTRUE_KEY_X+30),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_DOULBE_D	(GESTRUE_KEY_X+40),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_M_D		(GESTRUE_KEY_X+50),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_O_D		(GESTRUE_KEY_X+60),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_W_D		(GESTRUE_KEY_X+70),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_C_D		(GESTRUE_KEY_X+80),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_E_D		(GESTRUE_KEY_X+90),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_L_D		(GESTRUE_KEY_X+100),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_S_D		(GESTRUE_KEY_X+110),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_V_D		(GESTRUE_KEY_X+120),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+	#define KEY_Z_D		(GESTRUE_KEY_X+130),GESTRUE_KEY_Y,KEY_WIDTH_HEIGHT
+
+	#define TPD_KEY_COUNT       17    
+	#define TPD_KEYS                { KEY_MENU, KEY_HOME, KEY_BACK, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_POWER,\
+					KEY_M, KEY_O,KEY_W, KEY_C, KEY_E, KEY_L, KEY_S, KEY_V, KEY_Z}
+	#define TPD_KEYS_DIM            {{100,900,20,40},{250,900,100,40},{400,900,100,40},{KEY_UP_D},{KEY_DOWN_D},{KEY_LEFT_D},\
+					{KEY_RIGHT_D},{KEY_DOULBE_D},{KEY_M_D},{KEY_O_D},{KEY_W_D},{KEY_C_D},{KEY_E_D},{KEY_L_D},\
+					{KEY_S_D},{KEY_V_D},{KEY_Z_D}}
+
+	#else
+	#define TPD_KEY_COUNT           3
+	#define TPD_KEYS                	{ KEY_MENU, KEY_HOME,KEY_BACK}
+	#define TPD_KEYS_DIM            {{100,900,20,40},{250,900,100,40},{400,900,100,40}}
+	#endif
+#endif
+
+//#define Auto_Update_Msg2133A// 2133A auto update 
+
+const char MSG_2133_BIN[94*1024]=
+{};
+
+
+
+#endif /* TOUCHPANEL_H__ */
-- 
1.9.1

